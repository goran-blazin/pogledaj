
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model Genre
 * 
 */
export type Genre = $Result.DefaultSelection<Prisma.$GenrePayload>
/**
 * Model Language
 * 
 */
export type Language = $Result.DefaultSelection<Prisma.$LanguagePayload>
/**
 * Model Country
 * 
 */
export type Country = $Result.DefaultSelection<Prisma.$CountryPayload>
/**
 * Model City
 * 
 */
export type City = $Result.DefaultSelection<Prisma.$CityPayload>
/**
 * Model Cinema
 * 
 */
export type Cinema = $Result.DefaultSelection<Prisma.$CinemaPayload>
/**
 * Model CinemaTheater
 * 
 */
export type CinemaTheater = $Result.DefaultSelection<Prisma.$CinemaTheaterPayload>
/**
 * Model CinemaSeatGroup
 * 
 */
export type CinemaSeatGroup = $Result.DefaultSelection<Prisma.$CinemaSeatGroupPayload>
/**
 * Model CinemaSeat
 * 
 */
export type CinemaSeat = $Result.DefaultSelection<Prisma.$CinemaSeatPayload>
/**
 * Model Movie
 * 
 */
export type Movie = $Result.DefaultSelection<Prisma.$MoviePayload>
/**
 * Model Person
 * 
 */
export type Person = $Result.DefaultSelection<Prisma.$PersonPayload>
/**
 * Model MovieActor
 * 
 */
export type MovieActor = $Result.DefaultSelection<Prisma.$MovieActorPayload>
/**
 * Model MovieDirector
 * 
 */
export type MovieDirector = $Result.DefaultSelection<Prisma.$MovieDirectorPayload>
/**
 * Model MovieProducer
 * 
 */
export type MovieProducer = $Result.DefaultSelection<Prisma.$MovieProducerPayload>
/**
 * Model MovieCinemaOverride
 * 
 */
export type MovieCinemaOverride = $Result.DefaultSelection<Prisma.$MovieCinemaOverridePayload>
/**
 * Model MovieProjection
 * 
 */
export type MovieProjection = $Result.DefaultSelection<Prisma.$MovieProjectionPayload>
/**
 * Model ProjectionPrice
 * 
 */
export type ProjectionPrice = $Result.DefaultSelection<Prisma.$ProjectionPricePayload>
/**
 * Model AdminUser
 * 
 */
export type AdminUser = $Result.DefaultSelection<Prisma.$AdminUserPayload>
/**
 * Model Reservation
 * 
 */
export type Reservation = $Result.DefaultSelection<Prisma.$ReservationPayload>
/**
 * Model ReservationSeats
 * 
 */
export type ReservationSeats = $Result.DefaultSelection<Prisma.$ReservationSeatsPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const CinemaSeatGroupPositionEnum: {
  TopLeft: 'TopLeft',
  TopCenter: 'TopCenter',
  TopRight: 'TopRight',
  CenterLeft: 'CenterLeft',
  Center: 'Center',
  CenterRight: 'CenterRight',
  BottomLeft: 'BottomLeft',
  BottomCenter: 'BottomCenter',
  BottomRight: 'BottomRight'
};

export type CinemaSeatGroupPositionEnum = (typeof CinemaSeatGroupPositionEnum)[keyof typeof CinemaSeatGroupPositionEnum]


export const InputProvider: {
  Tmdb: 'Tmdb',
  Imdb: 'Imdb',
  AdminInput: 'AdminInput'
};

export type InputProvider = (typeof InputProvider)[keyof typeof InputProvider]


export const Gender: {
  Male: 'Male',
  Female: 'Female',
  Other: 'Other'
};

export type Gender = (typeof Gender)[keyof typeof Gender]


export const DirectorType: {
  Main: 'Main',
  Assistant: 'Assistant'
};

export type DirectorType = (typeof DirectorType)[keyof typeof DirectorType]


export const ProducerType: {
  Executive: 'Executive',
  Assistant: 'Assistant'
};

export type ProducerType = (typeof ProducerType)[keyof typeof ProducerType]


export const PriceType: {
  Normal: 'Normal'
};

export type PriceType = (typeof PriceType)[keyof typeof PriceType]


export const CurrencyCode: {
  RSD: 'RSD',
  USD: 'USD',
  EUR: 'EUR',
  CHF: 'CHF'
};

export type CurrencyCode = (typeof CurrencyCode)[keyof typeof CurrencyCode]


export const AdminRole: {
  SuperAdmin: 'SuperAdmin',
  Manager: 'Manager',
  Employee: 'Employee'
};

export type AdminRole = (typeof AdminRole)[keyof typeof AdminRole]

}

export type CinemaSeatGroupPositionEnum = $Enums.CinemaSeatGroupPositionEnum

export const CinemaSeatGroupPositionEnum: typeof $Enums.CinemaSeatGroupPositionEnum

export type InputProvider = $Enums.InputProvider

export const InputProvider: typeof $Enums.InputProvider

export type Gender = $Enums.Gender

export const Gender: typeof $Enums.Gender

export type DirectorType = $Enums.DirectorType

export const DirectorType: typeof $Enums.DirectorType

export type ProducerType = $Enums.ProducerType

export const ProducerType: typeof $Enums.ProducerType

export type PriceType = $Enums.PriceType

export const PriceType: typeof $Enums.PriceType

export type CurrencyCode = $Enums.CurrencyCode

export const CurrencyCode: typeof $Enums.CurrencyCode

export type AdminRole = $Enums.AdminRole

export const AdminRole: typeof $Enums.AdminRole

/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Genres
 * const genres = await prisma.genre.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Genres
   * const genres = await prisma.genre.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Executes a typed SQL query and returns a typed result
   * @example
   * ```
   * import { myQuery } from '@prisma/client/sql'
   * 
   * const result = await prisma.$queryRawTyped(myQuery())
   * ```
   */
  $queryRawTyped<T>(typedSql: runtime.TypedSql<unknown[], T>): Prisma.PrismaPromise<T[]>

  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb, ExtArgs>

      /**
   * `prisma.genre`: Exposes CRUD operations for the **Genre** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Genres
    * const genres = await prisma.genre.findMany()
    * ```
    */
  get genre(): Prisma.GenreDelegate<ExtArgs>;

  /**
   * `prisma.language`: Exposes CRUD operations for the **Language** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Languages
    * const languages = await prisma.language.findMany()
    * ```
    */
  get language(): Prisma.LanguageDelegate<ExtArgs>;

  /**
   * `prisma.country`: Exposes CRUD operations for the **Country** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Countries
    * const countries = await prisma.country.findMany()
    * ```
    */
  get country(): Prisma.CountryDelegate<ExtArgs>;

  /**
   * `prisma.city`: Exposes CRUD operations for the **City** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Cities
    * const cities = await prisma.city.findMany()
    * ```
    */
  get city(): Prisma.CityDelegate<ExtArgs>;

  /**
   * `prisma.cinema`: Exposes CRUD operations for the **Cinema** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Cinemas
    * const cinemas = await prisma.cinema.findMany()
    * ```
    */
  get cinema(): Prisma.CinemaDelegate<ExtArgs>;

  /**
   * `prisma.cinemaTheater`: Exposes CRUD operations for the **CinemaTheater** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CinemaTheaters
    * const cinemaTheaters = await prisma.cinemaTheater.findMany()
    * ```
    */
  get cinemaTheater(): Prisma.CinemaTheaterDelegate<ExtArgs>;

  /**
   * `prisma.cinemaSeatGroup`: Exposes CRUD operations for the **CinemaSeatGroup** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CinemaSeatGroups
    * const cinemaSeatGroups = await prisma.cinemaSeatGroup.findMany()
    * ```
    */
  get cinemaSeatGroup(): Prisma.CinemaSeatGroupDelegate<ExtArgs>;

  /**
   * `prisma.cinemaSeat`: Exposes CRUD operations for the **CinemaSeat** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CinemaSeats
    * const cinemaSeats = await prisma.cinemaSeat.findMany()
    * ```
    */
  get cinemaSeat(): Prisma.CinemaSeatDelegate<ExtArgs>;

  /**
   * `prisma.movie`: Exposes CRUD operations for the **Movie** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Movies
    * const movies = await prisma.movie.findMany()
    * ```
    */
  get movie(): Prisma.MovieDelegate<ExtArgs>;

  /**
   * `prisma.person`: Exposes CRUD operations for the **Person** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more People
    * const people = await prisma.person.findMany()
    * ```
    */
  get person(): Prisma.PersonDelegate<ExtArgs>;

  /**
   * `prisma.movieActor`: Exposes CRUD operations for the **MovieActor** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MovieActors
    * const movieActors = await prisma.movieActor.findMany()
    * ```
    */
  get movieActor(): Prisma.MovieActorDelegate<ExtArgs>;

  /**
   * `prisma.movieDirector`: Exposes CRUD operations for the **MovieDirector** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MovieDirectors
    * const movieDirectors = await prisma.movieDirector.findMany()
    * ```
    */
  get movieDirector(): Prisma.MovieDirectorDelegate<ExtArgs>;

  /**
   * `prisma.movieProducer`: Exposes CRUD operations for the **MovieProducer** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MovieProducers
    * const movieProducers = await prisma.movieProducer.findMany()
    * ```
    */
  get movieProducer(): Prisma.MovieProducerDelegate<ExtArgs>;

  /**
   * `prisma.movieCinemaOverride`: Exposes CRUD operations for the **MovieCinemaOverride** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MovieCinemaOverrides
    * const movieCinemaOverrides = await prisma.movieCinemaOverride.findMany()
    * ```
    */
  get movieCinemaOverride(): Prisma.MovieCinemaOverrideDelegate<ExtArgs>;

  /**
   * `prisma.movieProjection`: Exposes CRUD operations for the **MovieProjection** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MovieProjections
    * const movieProjections = await prisma.movieProjection.findMany()
    * ```
    */
  get movieProjection(): Prisma.MovieProjectionDelegate<ExtArgs>;

  /**
   * `prisma.projectionPrice`: Exposes CRUD operations for the **ProjectionPrice** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ProjectionPrices
    * const projectionPrices = await prisma.projectionPrice.findMany()
    * ```
    */
  get projectionPrice(): Prisma.ProjectionPriceDelegate<ExtArgs>;

  /**
   * `prisma.adminUser`: Exposes CRUD operations for the **AdminUser** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AdminUsers
    * const adminUsers = await prisma.adminUser.findMany()
    * ```
    */
  get adminUser(): Prisma.AdminUserDelegate<ExtArgs>;

  /**
   * `prisma.reservation`: Exposes CRUD operations for the **Reservation** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Reservations
    * const reservations = await prisma.reservation.findMany()
    * ```
    */
  get reservation(): Prisma.ReservationDelegate<ExtArgs>;

  /**
   * `prisma.reservationSeats`: Exposes CRUD operations for the **ReservationSeats** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ReservationSeats
    * const reservationSeats = await prisma.reservationSeats.findMany()
    * ```
    */
  get reservationSeats(): Prisma.ReservationSeatsDelegate<ExtArgs>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError
  export import NotFoundError = runtime.NotFoundError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 5.20.0
   * Query Engine version: 06fc58a368dc7be9fbbbe894adf8d445d208c284
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    Genre: 'Genre',
    Language: 'Language',
    Country: 'Country',
    City: 'City',
    Cinema: 'Cinema',
    CinemaTheater: 'CinemaTheater',
    CinemaSeatGroup: 'CinemaSeatGroup',
    CinemaSeat: 'CinemaSeat',
    Movie: 'Movie',
    Person: 'Person',
    MovieActor: 'MovieActor',
    MovieDirector: 'MovieDirector',
    MovieProducer: 'MovieProducer',
    MovieCinemaOverride: 'MovieCinemaOverride',
    MovieProjection: 'MovieProjection',
    ProjectionPrice: 'ProjectionPrice',
    AdminUser: 'AdminUser',
    Reservation: 'Reservation',
    ReservationSeats: 'ReservationSeats'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb extends $Utils.Fn<{extArgs: $Extensions.InternalArgs, clientOptions: PrismaClientOptions }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], this['params']['clientOptions']>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> = {
    meta: {
      modelProps: "genre" | "language" | "country" | "city" | "cinema" | "cinemaTheater" | "cinemaSeatGroup" | "cinemaSeat" | "movie" | "person" | "movieActor" | "movieDirector" | "movieProducer" | "movieCinemaOverride" | "movieProjection" | "projectionPrice" | "adminUser" | "reservation" | "reservationSeats"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      Genre: {
        payload: Prisma.$GenrePayload<ExtArgs>
        fields: Prisma.GenreFieldRefs
        operations: {
          findUnique: {
            args: Prisma.GenreFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GenrePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.GenreFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GenrePayload>
          }
          findFirst: {
            args: Prisma.GenreFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GenrePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.GenreFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GenrePayload>
          }
          findMany: {
            args: Prisma.GenreFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GenrePayload>[]
          }
          create: {
            args: Prisma.GenreCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GenrePayload>
          }
          createMany: {
            args: Prisma.GenreCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.GenreCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GenrePayload>[]
          }
          delete: {
            args: Prisma.GenreDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GenrePayload>
          }
          update: {
            args: Prisma.GenreUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GenrePayload>
          }
          deleteMany: {
            args: Prisma.GenreDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.GenreUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.GenreUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GenrePayload>
          }
          aggregate: {
            args: Prisma.GenreAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateGenre>
          }
          groupBy: {
            args: Prisma.GenreGroupByArgs<ExtArgs>
            result: $Utils.Optional<GenreGroupByOutputType>[]
          }
          count: {
            args: Prisma.GenreCountArgs<ExtArgs>
            result: $Utils.Optional<GenreCountAggregateOutputType> | number
          }
        }
      }
      Language: {
        payload: Prisma.$LanguagePayload<ExtArgs>
        fields: Prisma.LanguageFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LanguageFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LanguagePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LanguageFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LanguagePayload>
          }
          findFirst: {
            args: Prisma.LanguageFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LanguagePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LanguageFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LanguagePayload>
          }
          findMany: {
            args: Prisma.LanguageFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LanguagePayload>[]
          }
          create: {
            args: Prisma.LanguageCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LanguagePayload>
          }
          createMany: {
            args: Prisma.LanguageCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.LanguageCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LanguagePayload>[]
          }
          delete: {
            args: Prisma.LanguageDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LanguagePayload>
          }
          update: {
            args: Prisma.LanguageUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LanguagePayload>
          }
          deleteMany: {
            args: Prisma.LanguageDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LanguageUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.LanguageUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LanguagePayload>
          }
          aggregate: {
            args: Prisma.LanguageAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLanguage>
          }
          groupBy: {
            args: Prisma.LanguageGroupByArgs<ExtArgs>
            result: $Utils.Optional<LanguageGroupByOutputType>[]
          }
          count: {
            args: Prisma.LanguageCountArgs<ExtArgs>
            result: $Utils.Optional<LanguageCountAggregateOutputType> | number
          }
        }
      }
      Country: {
        payload: Prisma.$CountryPayload<ExtArgs>
        fields: Prisma.CountryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CountryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CountryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CountryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CountryPayload>
          }
          findFirst: {
            args: Prisma.CountryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CountryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CountryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CountryPayload>
          }
          findMany: {
            args: Prisma.CountryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CountryPayload>[]
          }
          create: {
            args: Prisma.CountryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CountryPayload>
          }
          createMany: {
            args: Prisma.CountryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CountryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CountryPayload>[]
          }
          delete: {
            args: Prisma.CountryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CountryPayload>
          }
          update: {
            args: Prisma.CountryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CountryPayload>
          }
          deleteMany: {
            args: Prisma.CountryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CountryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CountryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CountryPayload>
          }
          aggregate: {
            args: Prisma.CountryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCountry>
          }
          groupBy: {
            args: Prisma.CountryGroupByArgs<ExtArgs>
            result: $Utils.Optional<CountryGroupByOutputType>[]
          }
          count: {
            args: Prisma.CountryCountArgs<ExtArgs>
            result: $Utils.Optional<CountryCountAggregateOutputType> | number
          }
        }
      }
      City: {
        payload: Prisma.$CityPayload<ExtArgs>
        fields: Prisma.CityFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CityFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CityPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CityFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CityPayload>
          }
          findFirst: {
            args: Prisma.CityFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CityPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CityFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CityPayload>
          }
          findMany: {
            args: Prisma.CityFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CityPayload>[]
          }
          create: {
            args: Prisma.CityCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CityPayload>
          }
          createMany: {
            args: Prisma.CityCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CityCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CityPayload>[]
          }
          delete: {
            args: Prisma.CityDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CityPayload>
          }
          update: {
            args: Prisma.CityUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CityPayload>
          }
          deleteMany: {
            args: Prisma.CityDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CityUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CityUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CityPayload>
          }
          aggregate: {
            args: Prisma.CityAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCity>
          }
          groupBy: {
            args: Prisma.CityGroupByArgs<ExtArgs>
            result: $Utils.Optional<CityGroupByOutputType>[]
          }
          count: {
            args: Prisma.CityCountArgs<ExtArgs>
            result: $Utils.Optional<CityCountAggregateOutputType> | number
          }
        }
      }
      Cinema: {
        payload: Prisma.$CinemaPayload<ExtArgs>
        fields: Prisma.CinemaFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CinemaFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CinemaPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CinemaFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CinemaPayload>
          }
          findFirst: {
            args: Prisma.CinemaFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CinemaPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CinemaFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CinemaPayload>
          }
          findMany: {
            args: Prisma.CinemaFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CinemaPayload>[]
          }
          create: {
            args: Prisma.CinemaCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CinemaPayload>
          }
          createMany: {
            args: Prisma.CinemaCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CinemaCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CinemaPayload>[]
          }
          delete: {
            args: Prisma.CinemaDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CinemaPayload>
          }
          update: {
            args: Prisma.CinemaUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CinemaPayload>
          }
          deleteMany: {
            args: Prisma.CinemaDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CinemaUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CinemaUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CinemaPayload>
          }
          aggregate: {
            args: Prisma.CinemaAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCinema>
          }
          groupBy: {
            args: Prisma.CinemaGroupByArgs<ExtArgs>
            result: $Utils.Optional<CinemaGroupByOutputType>[]
          }
          count: {
            args: Prisma.CinemaCountArgs<ExtArgs>
            result: $Utils.Optional<CinemaCountAggregateOutputType> | number
          }
        }
      }
      CinemaTheater: {
        payload: Prisma.$CinemaTheaterPayload<ExtArgs>
        fields: Prisma.CinemaTheaterFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CinemaTheaterFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CinemaTheaterPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CinemaTheaterFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CinemaTheaterPayload>
          }
          findFirst: {
            args: Prisma.CinemaTheaterFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CinemaTheaterPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CinemaTheaterFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CinemaTheaterPayload>
          }
          findMany: {
            args: Prisma.CinemaTheaterFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CinemaTheaterPayload>[]
          }
          create: {
            args: Prisma.CinemaTheaterCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CinemaTheaterPayload>
          }
          createMany: {
            args: Prisma.CinemaTheaterCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CinemaTheaterCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CinemaTheaterPayload>[]
          }
          delete: {
            args: Prisma.CinemaTheaterDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CinemaTheaterPayload>
          }
          update: {
            args: Prisma.CinemaTheaterUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CinemaTheaterPayload>
          }
          deleteMany: {
            args: Prisma.CinemaTheaterDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CinemaTheaterUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CinemaTheaterUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CinemaTheaterPayload>
          }
          aggregate: {
            args: Prisma.CinemaTheaterAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCinemaTheater>
          }
          groupBy: {
            args: Prisma.CinemaTheaterGroupByArgs<ExtArgs>
            result: $Utils.Optional<CinemaTheaterGroupByOutputType>[]
          }
          count: {
            args: Prisma.CinemaTheaterCountArgs<ExtArgs>
            result: $Utils.Optional<CinemaTheaterCountAggregateOutputType> | number
          }
        }
      }
      CinemaSeatGroup: {
        payload: Prisma.$CinemaSeatGroupPayload<ExtArgs>
        fields: Prisma.CinemaSeatGroupFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CinemaSeatGroupFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CinemaSeatGroupPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CinemaSeatGroupFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CinemaSeatGroupPayload>
          }
          findFirst: {
            args: Prisma.CinemaSeatGroupFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CinemaSeatGroupPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CinemaSeatGroupFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CinemaSeatGroupPayload>
          }
          findMany: {
            args: Prisma.CinemaSeatGroupFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CinemaSeatGroupPayload>[]
          }
          create: {
            args: Prisma.CinemaSeatGroupCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CinemaSeatGroupPayload>
          }
          createMany: {
            args: Prisma.CinemaSeatGroupCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CinemaSeatGroupCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CinemaSeatGroupPayload>[]
          }
          delete: {
            args: Prisma.CinemaSeatGroupDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CinemaSeatGroupPayload>
          }
          update: {
            args: Prisma.CinemaSeatGroupUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CinemaSeatGroupPayload>
          }
          deleteMany: {
            args: Prisma.CinemaSeatGroupDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CinemaSeatGroupUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CinemaSeatGroupUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CinemaSeatGroupPayload>
          }
          aggregate: {
            args: Prisma.CinemaSeatGroupAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCinemaSeatGroup>
          }
          groupBy: {
            args: Prisma.CinemaSeatGroupGroupByArgs<ExtArgs>
            result: $Utils.Optional<CinemaSeatGroupGroupByOutputType>[]
          }
          count: {
            args: Prisma.CinemaSeatGroupCountArgs<ExtArgs>
            result: $Utils.Optional<CinemaSeatGroupCountAggregateOutputType> | number
          }
        }
      }
      CinemaSeat: {
        payload: Prisma.$CinemaSeatPayload<ExtArgs>
        fields: Prisma.CinemaSeatFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CinemaSeatFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CinemaSeatPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CinemaSeatFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CinemaSeatPayload>
          }
          findFirst: {
            args: Prisma.CinemaSeatFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CinemaSeatPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CinemaSeatFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CinemaSeatPayload>
          }
          findMany: {
            args: Prisma.CinemaSeatFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CinemaSeatPayload>[]
          }
          create: {
            args: Prisma.CinemaSeatCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CinemaSeatPayload>
          }
          createMany: {
            args: Prisma.CinemaSeatCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CinemaSeatCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CinemaSeatPayload>[]
          }
          delete: {
            args: Prisma.CinemaSeatDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CinemaSeatPayload>
          }
          update: {
            args: Prisma.CinemaSeatUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CinemaSeatPayload>
          }
          deleteMany: {
            args: Prisma.CinemaSeatDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CinemaSeatUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CinemaSeatUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CinemaSeatPayload>
          }
          aggregate: {
            args: Prisma.CinemaSeatAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCinemaSeat>
          }
          groupBy: {
            args: Prisma.CinemaSeatGroupByArgs<ExtArgs>
            result: $Utils.Optional<CinemaSeatGroupByOutputType>[]
          }
          count: {
            args: Prisma.CinemaSeatCountArgs<ExtArgs>
            result: $Utils.Optional<CinemaSeatCountAggregateOutputType> | number
          }
        }
      }
      Movie: {
        payload: Prisma.$MoviePayload<ExtArgs>
        fields: Prisma.MovieFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MovieFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MoviePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MovieFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MoviePayload>
          }
          findFirst: {
            args: Prisma.MovieFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MoviePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MovieFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MoviePayload>
          }
          findMany: {
            args: Prisma.MovieFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MoviePayload>[]
          }
          create: {
            args: Prisma.MovieCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MoviePayload>
          }
          createMany: {
            args: Prisma.MovieCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MovieCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MoviePayload>[]
          }
          delete: {
            args: Prisma.MovieDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MoviePayload>
          }
          update: {
            args: Prisma.MovieUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MoviePayload>
          }
          deleteMany: {
            args: Prisma.MovieDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MovieUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.MovieUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MoviePayload>
          }
          aggregate: {
            args: Prisma.MovieAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMovie>
          }
          groupBy: {
            args: Prisma.MovieGroupByArgs<ExtArgs>
            result: $Utils.Optional<MovieGroupByOutputType>[]
          }
          count: {
            args: Prisma.MovieCountArgs<ExtArgs>
            result: $Utils.Optional<MovieCountAggregateOutputType> | number
          }
        }
      }
      Person: {
        payload: Prisma.$PersonPayload<ExtArgs>
        fields: Prisma.PersonFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PersonFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PersonPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PersonFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PersonPayload>
          }
          findFirst: {
            args: Prisma.PersonFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PersonPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PersonFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PersonPayload>
          }
          findMany: {
            args: Prisma.PersonFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PersonPayload>[]
          }
          create: {
            args: Prisma.PersonCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PersonPayload>
          }
          createMany: {
            args: Prisma.PersonCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PersonCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PersonPayload>[]
          }
          delete: {
            args: Prisma.PersonDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PersonPayload>
          }
          update: {
            args: Prisma.PersonUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PersonPayload>
          }
          deleteMany: {
            args: Prisma.PersonDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PersonUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PersonUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PersonPayload>
          }
          aggregate: {
            args: Prisma.PersonAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePerson>
          }
          groupBy: {
            args: Prisma.PersonGroupByArgs<ExtArgs>
            result: $Utils.Optional<PersonGroupByOutputType>[]
          }
          count: {
            args: Prisma.PersonCountArgs<ExtArgs>
            result: $Utils.Optional<PersonCountAggregateOutputType> | number
          }
        }
      }
      MovieActor: {
        payload: Prisma.$MovieActorPayload<ExtArgs>
        fields: Prisma.MovieActorFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MovieActorFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MovieActorPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MovieActorFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MovieActorPayload>
          }
          findFirst: {
            args: Prisma.MovieActorFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MovieActorPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MovieActorFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MovieActorPayload>
          }
          findMany: {
            args: Prisma.MovieActorFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MovieActorPayload>[]
          }
          create: {
            args: Prisma.MovieActorCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MovieActorPayload>
          }
          createMany: {
            args: Prisma.MovieActorCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MovieActorCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MovieActorPayload>[]
          }
          delete: {
            args: Prisma.MovieActorDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MovieActorPayload>
          }
          update: {
            args: Prisma.MovieActorUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MovieActorPayload>
          }
          deleteMany: {
            args: Prisma.MovieActorDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MovieActorUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.MovieActorUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MovieActorPayload>
          }
          aggregate: {
            args: Prisma.MovieActorAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMovieActor>
          }
          groupBy: {
            args: Prisma.MovieActorGroupByArgs<ExtArgs>
            result: $Utils.Optional<MovieActorGroupByOutputType>[]
          }
          count: {
            args: Prisma.MovieActorCountArgs<ExtArgs>
            result: $Utils.Optional<MovieActorCountAggregateOutputType> | number
          }
        }
      }
      MovieDirector: {
        payload: Prisma.$MovieDirectorPayload<ExtArgs>
        fields: Prisma.MovieDirectorFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MovieDirectorFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MovieDirectorPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MovieDirectorFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MovieDirectorPayload>
          }
          findFirst: {
            args: Prisma.MovieDirectorFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MovieDirectorPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MovieDirectorFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MovieDirectorPayload>
          }
          findMany: {
            args: Prisma.MovieDirectorFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MovieDirectorPayload>[]
          }
          create: {
            args: Prisma.MovieDirectorCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MovieDirectorPayload>
          }
          createMany: {
            args: Prisma.MovieDirectorCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MovieDirectorCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MovieDirectorPayload>[]
          }
          delete: {
            args: Prisma.MovieDirectorDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MovieDirectorPayload>
          }
          update: {
            args: Prisma.MovieDirectorUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MovieDirectorPayload>
          }
          deleteMany: {
            args: Prisma.MovieDirectorDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MovieDirectorUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.MovieDirectorUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MovieDirectorPayload>
          }
          aggregate: {
            args: Prisma.MovieDirectorAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMovieDirector>
          }
          groupBy: {
            args: Prisma.MovieDirectorGroupByArgs<ExtArgs>
            result: $Utils.Optional<MovieDirectorGroupByOutputType>[]
          }
          count: {
            args: Prisma.MovieDirectorCountArgs<ExtArgs>
            result: $Utils.Optional<MovieDirectorCountAggregateOutputType> | number
          }
        }
      }
      MovieProducer: {
        payload: Prisma.$MovieProducerPayload<ExtArgs>
        fields: Prisma.MovieProducerFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MovieProducerFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MovieProducerPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MovieProducerFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MovieProducerPayload>
          }
          findFirst: {
            args: Prisma.MovieProducerFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MovieProducerPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MovieProducerFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MovieProducerPayload>
          }
          findMany: {
            args: Prisma.MovieProducerFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MovieProducerPayload>[]
          }
          create: {
            args: Prisma.MovieProducerCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MovieProducerPayload>
          }
          createMany: {
            args: Prisma.MovieProducerCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MovieProducerCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MovieProducerPayload>[]
          }
          delete: {
            args: Prisma.MovieProducerDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MovieProducerPayload>
          }
          update: {
            args: Prisma.MovieProducerUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MovieProducerPayload>
          }
          deleteMany: {
            args: Prisma.MovieProducerDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MovieProducerUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.MovieProducerUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MovieProducerPayload>
          }
          aggregate: {
            args: Prisma.MovieProducerAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMovieProducer>
          }
          groupBy: {
            args: Prisma.MovieProducerGroupByArgs<ExtArgs>
            result: $Utils.Optional<MovieProducerGroupByOutputType>[]
          }
          count: {
            args: Prisma.MovieProducerCountArgs<ExtArgs>
            result: $Utils.Optional<MovieProducerCountAggregateOutputType> | number
          }
        }
      }
      MovieCinemaOverride: {
        payload: Prisma.$MovieCinemaOverridePayload<ExtArgs>
        fields: Prisma.MovieCinemaOverrideFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MovieCinemaOverrideFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MovieCinemaOverridePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MovieCinemaOverrideFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MovieCinemaOverridePayload>
          }
          findFirst: {
            args: Prisma.MovieCinemaOverrideFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MovieCinemaOverridePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MovieCinemaOverrideFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MovieCinemaOverridePayload>
          }
          findMany: {
            args: Prisma.MovieCinemaOverrideFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MovieCinemaOverridePayload>[]
          }
          create: {
            args: Prisma.MovieCinemaOverrideCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MovieCinemaOverridePayload>
          }
          createMany: {
            args: Prisma.MovieCinemaOverrideCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MovieCinemaOverrideCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MovieCinemaOverridePayload>[]
          }
          delete: {
            args: Prisma.MovieCinemaOverrideDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MovieCinemaOverridePayload>
          }
          update: {
            args: Prisma.MovieCinemaOverrideUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MovieCinemaOverridePayload>
          }
          deleteMany: {
            args: Prisma.MovieCinemaOverrideDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MovieCinemaOverrideUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.MovieCinemaOverrideUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MovieCinemaOverridePayload>
          }
          aggregate: {
            args: Prisma.MovieCinemaOverrideAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMovieCinemaOverride>
          }
          groupBy: {
            args: Prisma.MovieCinemaOverrideGroupByArgs<ExtArgs>
            result: $Utils.Optional<MovieCinemaOverrideGroupByOutputType>[]
          }
          count: {
            args: Prisma.MovieCinemaOverrideCountArgs<ExtArgs>
            result: $Utils.Optional<MovieCinemaOverrideCountAggregateOutputType> | number
          }
        }
      }
      MovieProjection: {
        payload: Prisma.$MovieProjectionPayload<ExtArgs>
        fields: Prisma.MovieProjectionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MovieProjectionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MovieProjectionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MovieProjectionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MovieProjectionPayload>
          }
          findFirst: {
            args: Prisma.MovieProjectionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MovieProjectionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MovieProjectionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MovieProjectionPayload>
          }
          findMany: {
            args: Prisma.MovieProjectionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MovieProjectionPayload>[]
          }
          create: {
            args: Prisma.MovieProjectionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MovieProjectionPayload>
          }
          createMany: {
            args: Prisma.MovieProjectionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MovieProjectionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MovieProjectionPayload>[]
          }
          delete: {
            args: Prisma.MovieProjectionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MovieProjectionPayload>
          }
          update: {
            args: Prisma.MovieProjectionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MovieProjectionPayload>
          }
          deleteMany: {
            args: Prisma.MovieProjectionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MovieProjectionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.MovieProjectionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MovieProjectionPayload>
          }
          aggregate: {
            args: Prisma.MovieProjectionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMovieProjection>
          }
          groupBy: {
            args: Prisma.MovieProjectionGroupByArgs<ExtArgs>
            result: $Utils.Optional<MovieProjectionGroupByOutputType>[]
          }
          count: {
            args: Prisma.MovieProjectionCountArgs<ExtArgs>
            result: $Utils.Optional<MovieProjectionCountAggregateOutputType> | number
          }
        }
      }
      ProjectionPrice: {
        payload: Prisma.$ProjectionPricePayload<ExtArgs>
        fields: Prisma.ProjectionPriceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProjectionPriceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectionPricePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProjectionPriceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectionPricePayload>
          }
          findFirst: {
            args: Prisma.ProjectionPriceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectionPricePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProjectionPriceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectionPricePayload>
          }
          findMany: {
            args: Prisma.ProjectionPriceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectionPricePayload>[]
          }
          create: {
            args: Prisma.ProjectionPriceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectionPricePayload>
          }
          createMany: {
            args: Prisma.ProjectionPriceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ProjectionPriceCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectionPricePayload>[]
          }
          delete: {
            args: Prisma.ProjectionPriceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectionPricePayload>
          }
          update: {
            args: Prisma.ProjectionPriceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectionPricePayload>
          }
          deleteMany: {
            args: Prisma.ProjectionPriceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProjectionPriceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ProjectionPriceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectionPricePayload>
          }
          aggregate: {
            args: Prisma.ProjectionPriceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProjectionPrice>
          }
          groupBy: {
            args: Prisma.ProjectionPriceGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProjectionPriceGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProjectionPriceCountArgs<ExtArgs>
            result: $Utils.Optional<ProjectionPriceCountAggregateOutputType> | number
          }
        }
      }
      AdminUser: {
        payload: Prisma.$AdminUserPayload<ExtArgs>
        fields: Prisma.AdminUserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AdminUserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminUserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AdminUserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminUserPayload>
          }
          findFirst: {
            args: Prisma.AdminUserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminUserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AdminUserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminUserPayload>
          }
          findMany: {
            args: Prisma.AdminUserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminUserPayload>[]
          }
          create: {
            args: Prisma.AdminUserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminUserPayload>
          }
          createMany: {
            args: Prisma.AdminUserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AdminUserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminUserPayload>[]
          }
          delete: {
            args: Prisma.AdminUserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminUserPayload>
          }
          update: {
            args: Prisma.AdminUserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminUserPayload>
          }
          deleteMany: {
            args: Prisma.AdminUserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AdminUserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AdminUserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminUserPayload>
          }
          aggregate: {
            args: Prisma.AdminUserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAdminUser>
          }
          groupBy: {
            args: Prisma.AdminUserGroupByArgs<ExtArgs>
            result: $Utils.Optional<AdminUserGroupByOutputType>[]
          }
          count: {
            args: Prisma.AdminUserCountArgs<ExtArgs>
            result: $Utils.Optional<AdminUserCountAggregateOutputType> | number
          }
        }
      }
      Reservation: {
        payload: Prisma.$ReservationPayload<ExtArgs>
        fields: Prisma.ReservationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ReservationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReservationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ReservationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReservationPayload>
          }
          findFirst: {
            args: Prisma.ReservationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReservationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ReservationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReservationPayload>
          }
          findMany: {
            args: Prisma.ReservationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReservationPayload>[]
          }
          create: {
            args: Prisma.ReservationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReservationPayload>
          }
          createMany: {
            args: Prisma.ReservationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ReservationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReservationPayload>[]
          }
          delete: {
            args: Prisma.ReservationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReservationPayload>
          }
          update: {
            args: Prisma.ReservationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReservationPayload>
          }
          deleteMany: {
            args: Prisma.ReservationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ReservationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ReservationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReservationPayload>
          }
          aggregate: {
            args: Prisma.ReservationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateReservation>
          }
          groupBy: {
            args: Prisma.ReservationGroupByArgs<ExtArgs>
            result: $Utils.Optional<ReservationGroupByOutputType>[]
          }
          count: {
            args: Prisma.ReservationCountArgs<ExtArgs>
            result: $Utils.Optional<ReservationCountAggregateOutputType> | number
          }
        }
      }
      ReservationSeats: {
        payload: Prisma.$ReservationSeatsPayload<ExtArgs>
        fields: Prisma.ReservationSeatsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ReservationSeatsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReservationSeatsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ReservationSeatsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReservationSeatsPayload>
          }
          findFirst: {
            args: Prisma.ReservationSeatsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReservationSeatsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ReservationSeatsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReservationSeatsPayload>
          }
          findMany: {
            args: Prisma.ReservationSeatsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReservationSeatsPayload>[]
          }
          create: {
            args: Prisma.ReservationSeatsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReservationSeatsPayload>
          }
          createMany: {
            args: Prisma.ReservationSeatsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ReservationSeatsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReservationSeatsPayload>[]
          }
          delete: {
            args: Prisma.ReservationSeatsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReservationSeatsPayload>
          }
          update: {
            args: Prisma.ReservationSeatsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReservationSeatsPayload>
          }
          deleteMany: {
            args: Prisma.ReservationSeatsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ReservationSeatsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ReservationSeatsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReservationSeatsPayload>
          }
          aggregate: {
            args: Prisma.ReservationSeatsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateReservationSeats>
          }
          groupBy: {
            args: Prisma.ReservationSeatsGroupByArgs<ExtArgs>
            result: $Utils.Optional<ReservationSeatsGroupByOutputType>[]
          }
          count: {
            args: Prisma.ReservationSeatsCountArgs<ExtArgs>
            result: $Utils.Optional<ReservationSeatsCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRawTyped: {
          args: runtime.UnknownTypedSql,
          result: Prisma.JsonObject
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
  }


  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type GenreCountOutputType
   */

  export type GenreCountOutputType = {
    movies: number
  }

  export type GenreCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    movies?: boolean | GenreCountOutputTypeCountMoviesArgs
  }

  // Custom InputTypes
  /**
   * GenreCountOutputType without action
   */
  export type GenreCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GenreCountOutputType
     */
    select?: GenreCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * GenreCountOutputType without action
   */
  export type GenreCountOutputTypeCountMoviesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MovieWhereInput
  }


  /**
   * Count Type LanguageCountOutputType
   */

  export type LanguageCountOutputType = {
    originalLanguageMovies: number
    dubbedLanguageMovieProjections: number
  }

  export type LanguageCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    originalLanguageMovies?: boolean | LanguageCountOutputTypeCountOriginalLanguageMoviesArgs
    dubbedLanguageMovieProjections?: boolean | LanguageCountOutputTypeCountDubbedLanguageMovieProjectionsArgs
  }

  // Custom InputTypes
  /**
   * LanguageCountOutputType without action
   */
  export type LanguageCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LanguageCountOutputType
     */
    select?: LanguageCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * LanguageCountOutputType without action
   */
  export type LanguageCountOutputTypeCountOriginalLanguageMoviesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MovieWhereInput
  }

  /**
   * LanguageCountOutputType without action
   */
  export type LanguageCountOutputTypeCountDubbedLanguageMovieProjectionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MovieProjectionWhereInput
  }


  /**
   * Count Type CountryCountOutputType
   */

  export type CountryCountOutputType = {
    cities: number
    movies: number
  }

  export type CountryCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    cities?: boolean | CountryCountOutputTypeCountCitiesArgs
    movies?: boolean | CountryCountOutputTypeCountMoviesArgs
  }

  // Custom InputTypes
  /**
   * CountryCountOutputType without action
   */
  export type CountryCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CountryCountOutputType
     */
    select?: CountryCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CountryCountOutputType without action
   */
  export type CountryCountOutputTypeCountCitiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CityWhereInput
  }

  /**
   * CountryCountOutputType without action
   */
  export type CountryCountOutputTypeCountMoviesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MovieWhereInput
  }


  /**
   * Count Type CityCountOutputType
   */

  export type CityCountOutputType = {
    cinemas: number
  }

  export type CityCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    cinemas?: boolean | CityCountOutputTypeCountCinemasArgs
  }

  // Custom InputTypes
  /**
   * CityCountOutputType without action
   */
  export type CityCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CityCountOutputType
     */
    select?: CityCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CityCountOutputType without action
   */
  export type CityCountOutputTypeCountCinemasArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CinemaWhereInput
  }


  /**
   * Count Type CinemaCountOutputType
   */

  export type CinemaCountOutputType = {
    cinemaTheaters: number
    movieCinemaOverrides: number
  }

  export type CinemaCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    cinemaTheaters?: boolean | CinemaCountOutputTypeCountCinemaTheatersArgs
    movieCinemaOverrides?: boolean | CinemaCountOutputTypeCountMovieCinemaOverridesArgs
  }

  // Custom InputTypes
  /**
   * CinemaCountOutputType without action
   */
  export type CinemaCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CinemaCountOutputType
     */
    select?: CinemaCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CinemaCountOutputType without action
   */
  export type CinemaCountOutputTypeCountCinemaTheatersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CinemaTheaterWhereInput
  }

  /**
   * CinemaCountOutputType without action
   */
  export type CinemaCountOutputTypeCountMovieCinemaOverridesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MovieCinemaOverrideWhereInput
  }


  /**
   * Count Type CinemaTheaterCountOutputType
   */

  export type CinemaTheaterCountOutputType = {
    cinemaSeatGroups: number
    movieProjections: number
  }

  export type CinemaTheaterCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    cinemaSeatGroups?: boolean | CinemaTheaterCountOutputTypeCountCinemaSeatGroupsArgs
    movieProjections?: boolean | CinemaTheaterCountOutputTypeCountMovieProjectionsArgs
  }

  // Custom InputTypes
  /**
   * CinemaTheaterCountOutputType without action
   */
  export type CinemaTheaterCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CinemaTheaterCountOutputType
     */
    select?: CinemaTheaterCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CinemaTheaterCountOutputType without action
   */
  export type CinemaTheaterCountOutputTypeCountCinemaSeatGroupsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CinemaSeatGroupWhereInput
  }

  /**
   * CinemaTheaterCountOutputType without action
   */
  export type CinemaTheaterCountOutputTypeCountMovieProjectionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MovieProjectionWhereInput
  }


  /**
   * Count Type CinemaSeatGroupCountOutputType
   */

  export type CinemaSeatGroupCountOutputType = {
    cinemaSeats: number
    projectionPrices: number
  }

  export type CinemaSeatGroupCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    cinemaSeats?: boolean | CinemaSeatGroupCountOutputTypeCountCinemaSeatsArgs
    projectionPrices?: boolean | CinemaSeatGroupCountOutputTypeCountProjectionPricesArgs
  }

  // Custom InputTypes
  /**
   * CinemaSeatGroupCountOutputType without action
   */
  export type CinemaSeatGroupCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CinemaSeatGroupCountOutputType
     */
    select?: CinemaSeatGroupCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CinemaSeatGroupCountOutputType without action
   */
  export type CinemaSeatGroupCountOutputTypeCountCinemaSeatsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CinemaSeatWhereInput
  }

  /**
   * CinemaSeatGroupCountOutputType without action
   */
  export type CinemaSeatGroupCountOutputTypeCountProjectionPricesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProjectionPriceWhereInput
  }


  /**
   * Count Type CinemaSeatCountOutputType
   */

  export type CinemaSeatCountOutputType = {
    reservation: number
  }

  export type CinemaSeatCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    reservation?: boolean | CinemaSeatCountOutputTypeCountReservationArgs
  }

  // Custom InputTypes
  /**
   * CinemaSeatCountOutputType without action
   */
  export type CinemaSeatCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CinemaSeatCountOutputType
     */
    select?: CinemaSeatCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CinemaSeatCountOutputType without action
   */
  export type CinemaSeatCountOutputTypeCountReservationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReservationSeatsWhereInput
  }


  /**
   * Count Type MovieCountOutputType
   */

  export type MovieCountOutputType = {
    genres: number
    actors: number
    directors: number
    producers: number
    movieCinemaOverrides: number
    movieProjections: number
  }

  export type MovieCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    genres?: boolean | MovieCountOutputTypeCountGenresArgs
    actors?: boolean | MovieCountOutputTypeCountActorsArgs
    directors?: boolean | MovieCountOutputTypeCountDirectorsArgs
    producers?: boolean | MovieCountOutputTypeCountProducersArgs
    movieCinemaOverrides?: boolean | MovieCountOutputTypeCountMovieCinemaOverridesArgs
    movieProjections?: boolean | MovieCountOutputTypeCountMovieProjectionsArgs
  }

  // Custom InputTypes
  /**
   * MovieCountOutputType without action
   */
  export type MovieCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MovieCountOutputType
     */
    select?: MovieCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * MovieCountOutputType without action
   */
  export type MovieCountOutputTypeCountGenresArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GenreWhereInput
  }

  /**
   * MovieCountOutputType without action
   */
  export type MovieCountOutputTypeCountActorsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MovieActorWhereInput
  }

  /**
   * MovieCountOutputType without action
   */
  export type MovieCountOutputTypeCountDirectorsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MovieDirectorWhereInput
  }

  /**
   * MovieCountOutputType without action
   */
  export type MovieCountOutputTypeCountProducersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MovieProducerWhereInput
  }

  /**
   * MovieCountOutputType without action
   */
  export type MovieCountOutputTypeCountMovieCinemaOverridesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MovieCinemaOverrideWhereInput
  }

  /**
   * MovieCountOutputType without action
   */
  export type MovieCountOutputTypeCountMovieProjectionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MovieProjectionWhereInput
  }


  /**
   * Count Type PersonCountOutputType
   */

  export type PersonCountOutputType = {
    actorInMovies: number
    directorInMovies: number
    producerInMovies: number
  }

  export type PersonCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    actorInMovies?: boolean | PersonCountOutputTypeCountActorInMoviesArgs
    directorInMovies?: boolean | PersonCountOutputTypeCountDirectorInMoviesArgs
    producerInMovies?: boolean | PersonCountOutputTypeCountProducerInMoviesArgs
  }

  // Custom InputTypes
  /**
   * PersonCountOutputType without action
   */
  export type PersonCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PersonCountOutputType
     */
    select?: PersonCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PersonCountOutputType without action
   */
  export type PersonCountOutputTypeCountActorInMoviesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MovieActorWhereInput
  }

  /**
   * PersonCountOutputType without action
   */
  export type PersonCountOutputTypeCountDirectorInMoviesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MovieDirectorWhereInput
  }

  /**
   * PersonCountOutputType without action
   */
  export type PersonCountOutputTypeCountProducerInMoviesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MovieProducerWhereInput
  }


  /**
   * Count Type MovieProjectionCountOutputType
   */

  export type MovieProjectionCountOutputType = {
    projectionPrices: number
    reservations: number
  }

  export type MovieProjectionCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    projectionPrices?: boolean | MovieProjectionCountOutputTypeCountProjectionPricesArgs
    reservations?: boolean | MovieProjectionCountOutputTypeCountReservationsArgs
  }

  // Custom InputTypes
  /**
   * MovieProjectionCountOutputType without action
   */
  export type MovieProjectionCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MovieProjectionCountOutputType
     */
    select?: MovieProjectionCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * MovieProjectionCountOutputType without action
   */
  export type MovieProjectionCountOutputTypeCountProjectionPricesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProjectionPriceWhereInput
  }

  /**
   * MovieProjectionCountOutputType without action
   */
  export type MovieProjectionCountOutputTypeCountReservationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReservationWhereInput
  }


  /**
   * Count Type AdminUserCountOutputType
   */

  export type AdminUserCountOutputType = {
    ValidatedReservationSeats: number
  }

  export type AdminUserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    ValidatedReservationSeats?: boolean | AdminUserCountOutputTypeCountValidatedReservationSeatsArgs
  }

  // Custom InputTypes
  /**
   * AdminUserCountOutputType without action
   */
  export type AdminUserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminUserCountOutputType
     */
    select?: AdminUserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * AdminUserCountOutputType without action
   */
  export type AdminUserCountOutputTypeCountValidatedReservationSeatsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReservationSeatsWhereInput
  }


  /**
   * Count Type ReservationCountOutputType
   */

  export type ReservationCountOutputType = {
    reservationSeats: number
  }

  export type ReservationCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    reservationSeats?: boolean | ReservationCountOutputTypeCountReservationSeatsArgs
  }

  // Custom InputTypes
  /**
   * ReservationCountOutputType without action
   */
  export type ReservationCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReservationCountOutputType
     */
    select?: ReservationCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ReservationCountOutputType without action
   */
  export type ReservationCountOutputTypeCountReservationSeatsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReservationSeatsWhereInput
  }


  /**
   * Models
   */

  /**
   * Model Genre
   */

  export type AggregateGenre = {
    _count: GenreCountAggregateOutputType | null
    _min: GenreMinAggregateOutputType | null
    _max: GenreMaxAggregateOutputType | null
  }

  export type GenreMinAggregateOutputType = {
    systemName: string | null
    localizedName: string | null
  }

  export type GenreMaxAggregateOutputType = {
    systemName: string | null
    localizedName: string | null
  }

  export type GenreCountAggregateOutputType = {
    systemName: number
    localizedName: number
    _all: number
  }


  export type GenreMinAggregateInputType = {
    systemName?: true
    localizedName?: true
  }

  export type GenreMaxAggregateInputType = {
    systemName?: true
    localizedName?: true
  }

  export type GenreCountAggregateInputType = {
    systemName?: true
    localizedName?: true
    _all?: true
  }

  export type GenreAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Genre to aggregate.
     */
    where?: GenreWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Genres to fetch.
     */
    orderBy?: GenreOrderByWithRelationInput | GenreOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: GenreWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Genres from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Genres.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Genres
    **/
    _count?: true | GenreCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: GenreMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: GenreMaxAggregateInputType
  }

  export type GetGenreAggregateType<T extends GenreAggregateArgs> = {
        [P in keyof T & keyof AggregateGenre]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateGenre[P]>
      : GetScalarType<T[P], AggregateGenre[P]>
  }




  export type GenreGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GenreWhereInput
    orderBy?: GenreOrderByWithAggregationInput | GenreOrderByWithAggregationInput[]
    by: GenreScalarFieldEnum[] | GenreScalarFieldEnum
    having?: GenreScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: GenreCountAggregateInputType | true
    _min?: GenreMinAggregateInputType
    _max?: GenreMaxAggregateInputType
  }

  export type GenreGroupByOutputType = {
    systemName: string
    localizedName: string
    _count: GenreCountAggregateOutputType | null
    _min: GenreMinAggregateOutputType | null
    _max: GenreMaxAggregateOutputType | null
  }

  type GetGenreGroupByPayload<T extends GenreGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<GenreGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof GenreGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], GenreGroupByOutputType[P]>
            : GetScalarType<T[P], GenreGroupByOutputType[P]>
        }
      >
    >


  export type GenreSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    systemName?: boolean
    localizedName?: boolean
    movies?: boolean | Genre$moviesArgs<ExtArgs>
    _count?: boolean | GenreCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["genre"]>

  export type GenreSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    systemName?: boolean
    localizedName?: boolean
  }, ExtArgs["result"]["genre"]>

  export type GenreSelectScalar = {
    systemName?: boolean
    localizedName?: boolean
  }

  export type GenreInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    movies?: boolean | Genre$moviesArgs<ExtArgs>
    _count?: boolean | GenreCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type GenreIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $GenrePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Genre"
    objects: {
      movies: Prisma.$MoviePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      systemName: string
      localizedName: string
    }, ExtArgs["result"]["genre"]>
    composites: {}
  }

  type GenreGetPayload<S extends boolean | null | undefined | GenreDefaultArgs> = $Result.GetResult<Prisma.$GenrePayload, S>

  type GenreCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<GenreFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: GenreCountAggregateInputType | true
    }

  export interface GenreDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Genre'], meta: { name: 'Genre' } }
    /**
     * Find zero or one Genre that matches the filter.
     * @param {GenreFindUniqueArgs} args - Arguments to find a Genre
     * @example
     * // Get one Genre
     * const genre = await prisma.genre.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends GenreFindUniqueArgs>(args: SelectSubset<T, GenreFindUniqueArgs<ExtArgs>>): Prisma__GenreClient<$Result.GetResult<Prisma.$GenrePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Genre that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {GenreFindUniqueOrThrowArgs} args - Arguments to find a Genre
     * @example
     * // Get one Genre
     * const genre = await prisma.genre.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends GenreFindUniqueOrThrowArgs>(args: SelectSubset<T, GenreFindUniqueOrThrowArgs<ExtArgs>>): Prisma__GenreClient<$Result.GetResult<Prisma.$GenrePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Genre that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GenreFindFirstArgs} args - Arguments to find a Genre
     * @example
     * // Get one Genre
     * const genre = await prisma.genre.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends GenreFindFirstArgs>(args?: SelectSubset<T, GenreFindFirstArgs<ExtArgs>>): Prisma__GenreClient<$Result.GetResult<Prisma.$GenrePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Genre that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GenreFindFirstOrThrowArgs} args - Arguments to find a Genre
     * @example
     * // Get one Genre
     * const genre = await prisma.genre.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends GenreFindFirstOrThrowArgs>(args?: SelectSubset<T, GenreFindFirstOrThrowArgs<ExtArgs>>): Prisma__GenreClient<$Result.GetResult<Prisma.$GenrePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Genres that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GenreFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Genres
     * const genres = await prisma.genre.findMany()
     * 
     * // Get first 10 Genres
     * const genres = await prisma.genre.findMany({ take: 10 })
     * 
     * // Only select the `systemName`
     * const genreWithSystemNameOnly = await prisma.genre.findMany({ select: { systemName: true } })
     * 
     */
    findMany<T extends GenreFindManyArgs>(args?: SelectSubset<T, GenreFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GenrePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Genre.
     * @param {GenreCreateArgs} args - Arguments to create a Genre.
     * @example
     * // Create one Genre
     * const Genre = await prisma.genre.create({
     *   data: {
     *     // ... data to create a Genre
     *   }
     * })
     * 
     */
    create<T extends GenreCreateArgs>(args: SelectSubset<T, GenreCreateArgs<ExtArgs>>): Prisma__GenreClient<$Result.GetResult<Prisma.$GenrePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Genres.
     * @param {GenreCreateManyArgs} args - Arguments to create many Genres.
     * @example
     * // Create many Genres
     * const genre = await prisma.genre.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends GenreCreateManyArgs>(args?: SelectSubset<T, GenreCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Genres and returns the data saved in the database.
     * @param {GenreCreateManyAndReturnArgs} args - Arguments to create many Genres.
     * @example
     * // Create many Genres
     * const genre = await prisma.genre.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Genres and only return the `systemName`
     * const genreWithSystemNameOnly = await prisma.genre.createManyAndReturn({ 
     *   select: { systemName: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends GenreCreateManyAndReturnArgs>(args?: SelectSubset<T, GenreCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GenrePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Genre.
     * @param {GenreDeleteArgs} args - Arguments to delete one Genre.
     * @example
     * // Delete one Genre
     * const Genre = await prisma.genre.delete({
     *   where: {
     *     // ... filter to delete one Genre
     *   }
     * })
     * 
     */
    delete<T extends GenreDeleteArgs>(args: SelectSubset<T, GenreDeleteArgs<ExtArgs>>): Prisma__GenreClient<$Result.GetResult<Prisma.$GenrePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Genre.
     * @param {GenreUpdateArgs} args - Arguments to update one Genre.
     * @example
     * // Update one Genre
     * const genre = await prisma.genre.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends GenreUpdateArgs>(args: SelectSubset<T, GenreUpdateArgs<ExtArgs>>): Prisma__GenreClient<$Result.GetResult<Prisma.$GenrePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Genres.
     * @param {GenreDeleteManyArgs} args - Arguments to filter Genres to delete.
     * @example
     * // Delete a few Genres
     * const { count } = await prisma.genre.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends GenreDeleteManyArgs>(args?: SelectSubset<T, GenreDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Genres.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GenreUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Genres
     * const genre = await prisma.genre.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends GenreUpdateManyArgs>(args: SelectSubset<T, GenreUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Genre.
     * @param {GenreUpsertArgs} args - Arguments to update or create a Genre.
     * @example
     * // Update or create a Genre
     * const genre = await prisma.genre.upsert({
     *   create: {
     *     // ... data to create a Genre
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Genre we want to update
     *   }
     * })
     */
    upsert<T extends GenreUpsertArgs>(args: SelectSubset<T, GenreUpsertArgs<ExtArgs>>): Prisma__GenreClient<$Result.GetResult<Prisma.$GenrePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Genres.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GenreCountArgs} args - Arguments to filter Genres to count.
     * @example
     * // Count the number of Genres
     * const count = await prisma.genre.count({
     *   where: {
     *     // ... the filter for the Genres we want to count
     *   }
     * })
    **/
    count<T extends GenreCountArgs>(
      args?: Subset<T, GenreCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], GenreCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Genre.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GenreAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends GenreAggregateArgs>(args: Subset<T, GenreAggregateArgs>): Prisma.PrismaPromise<GetGenreAggregateType<T>>

    /**
     * Group by Genre.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GenreGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends GenreGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: GenreGroupByArgs['orderBy'] }
        : { orderBy?: GenreGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, GenreGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetGenreGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Genre model
   */
  readonly fields: GenreFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Genre.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__GenreClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    movies<T extends Genre$moviesArgs<ExtArgs> = {}>(args?: Subset<T, Genre$moviesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MoviePayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Genre model
   */ 
  interface GenreFieldRefs {
    readonly systemName: FieldRef<"Genre", 'String'>
    readonly localizedName: FieldRef<"Genre", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Genre findUnique
   */
  export type GenreFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Genre
     */
    select?: GenreSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GenreInclude<ExtArgs> | null
    /**
     * Filter, which Genre to fetch.
     */
    where: GenreWhereUniqueInput
  }

  /**
   * Genre findUniqueOrThrow
   */
  export type GenreFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Genre
     */
    select?: GenreSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GenreInclude<ExtArgs> | null
    /**
     * Filter, which Genre to fetch.
     */
    where: GenreWhereUniqueInput
  }

  /**
   * Genre findFirst
   */
  export type GenreFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Genre
     */
    select?: GenreSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GenreInclude<ExtArgs> | null
    /**
     * Filter, which Genre to fetch.
     */
    where?: GenreWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Genres to fetch.
     */
    orderBy?: GenreOrderByWithRelationInput | GenreOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Genres.
     */
    cursor?: GenreWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Genres from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Genres.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Genres.
     */
    distinct?: GenreScalarFieldEnum | GenreScalarFieldEnum[]
  }

  /**
   * Genre findFirstOrThrow
   */
  export type GenreFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Genre
     */
    select?: GenreSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GenreInclude<ExtArgs> | null
    /**
     * Filter, which Genre to fetch.
     */
    where?: GenreWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Genres to fetch.
     */
    orderBy?: GenreOrderByWithRelationInput | GenreOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Genres.
     */
    cursor?: GenreWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Genres from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Genres.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Genres.
     */
    distinct?: GenreScalarFieldEnum | GenreScalarFieldEnum[]
  }

  /**
   * Genre findMany
   */
  export type GenreFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Genre
     */
    select?: GenreSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GenreInclude<ExtArgs> | null
    /**
     * Filter, which Genres to fetch.
     */
    where?: GenreWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Genres to fetch.
     */
    orderBy?: GenreOrderByWithRelationInput | GenreOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Genres.
     */
    cursor?: GenreWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Genres from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Genres.
     */
    skip?: number
    distinct?: GenreScalarFieldEnum | GenreScalarFieldEnum[]
  }

  /**
   * Genre create
   */
  export type GenreCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Genre
     */
    select?: GenreSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GenreInclude<ExtArgs> | null
    /**
     * The data needed to create a Genre.
     */
    data: XOR<GenreCreateInput, GenreUncheckedCreateInput>
  }

  /**
   * Genre createMany
   */
  export type GenreCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Genres.
     */
    data: GenreCreateManyInput | GenreCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Genre createManyAndReturn
   */
  export type GenreCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Genre
     */
    select?: GenreSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Genres.
     */
    data: GenreCreateManyInput | GenreCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Genre update
   */
  export type GenreUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Genre
     */
    select?: GenreSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GenreInclude<ExtArgs> | null
    /**
     * The data needed to update a Genre.
     */
    data: XOR<GenreUpdateInput, GenreUncheckedUpdateInput>
    /**
     * Choose, which Genre to update.
     */
    where: GenreWhereUniqueInput
  }

  /**
   * Genre updateMany
   */
  export type GenreUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Genres.
     */
    data: XOR<GenreUpdateManyMutationInput, GenreUncheckedUpdateManyInput>
    /**
     * Filter which Genres to update
     */
    where?: GenreWhereInput
  }

  /**
   * Genre upsert
   */
  export type GenreUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Genre
     */
    select?: GenreSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GenreInclude<ExtArgs> | null
    /**
     * The filter to search for the Genre to update in case it exists.
     */
    where: GenreWhereUniqueInput
    /**
     * In case the Genre found by the `where` argument doesn't exist, create a new Genre with this data.
     */
    create: XOR<GenreCreateInput, GenreUncheckedCreateInput>
    /**
     * In case the Genre was found with the provided `where` argument, update it with this data.
     */
    update: XOR<GenreUpdateInput, GenreUncheckedUpdateInput>
  }

  /**
   * Genre delete
   */
  export type GenreDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Genre
     */
    select?: GenreSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GenreInclude<ExtArgs> | null
    /**
     * Filter which Genre to delete.
     */
    where: GenreWhereUniqueInput
  }

  /**
   * Genre deleteMany
   */
  export type GenreDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Genres to delete
     */
    where?: GenreWhereInput
  }

  /**
   * Genre.movies
   */
  export type Genre$moviesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Movie
     */
    select?: MovieSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MovieInclude<ExtArgs> | null
    where?: MovieWhereInput
    orderBy?: MovieOrderByWithRelationInput | MovieOrderByWithRelationInput[]
    cursor?: MovieWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MovieScalarFieldEnum | MovieScalarFieldEnum[]
  }

  /**
   * Genre without action
   */
  export type GenreDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Genre
     */
    select?: GenreSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GenreInclude<ExtArgs> | null
  }


  /**
   * Model Language
   */

  export type AggregateLanguage = {
    _count: LanguageCountAggregateOutputType | null
    _min: LanguageMinAggregateOutputType | null
    _max: LanguageMaxAggregateOutputType | null
  }

  export type LanguageMinAggregateOutputType = {
    code: string | null
    name: string | null
  }

  export type LanguageMaxAggregateOutputType = {
    code: string | null
    name: string | null
  }

  export type LanguageCountAggregateOutputType = {
    code: number
    name: number
    _all: number
  }


  export type LanguageMinAggregateInputType = {
    code?: true
    name?: true
  }

  export type LanguageMaxAggregateInputType = {
    code?: true
    name?: true
  }

  export type LanguageCountAggregateInputType = {
    code?: true
    name?: true
    _all?: true
  }

  export type LanguageAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Language to aggregate.
     */
    where?: LanguageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Languages to fetch.
     */
    orderBy?: LanguageOrderByWithRelationInput | LanguageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LanguageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Languages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Languages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Languages
    **/
    _count?: true | LanguageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LanguageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LanguageMaxAggregateInputType
  }

  export type GetLanguageAggregateType<T extends LanguageAggregateArgs> = {
        [P in keyof T & keyof AggregateLanguage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLanguage[P]>
      : GetScalarType<T[P], AggregateLanguage[P]>
  }




  export type LanguageGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LanguageWhereInput
    orderBy?: LanguageOrderByWithAggregationInput | LanguageOrderByWithAggregationInput[]
    by: LanguageScalarFieldEnum[] | LanguageScalarFieldEnum
    having?: LanguageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LanguageCountAggregateInputType | true
    _min?: LanguageMinAggregateInputType
    _max?: LanguageMaxAggregateInputType
  }

  export type LanguageGroupByOutputType = {
    code: string
    name: string
    _count: LanguageCountAggregateOutputType | null
    _min: LanguageMinAggregateOutputType | null
    _max: LanguageMaxAggregateOutputType | null
  }

  type GetLanguageGroupByPayload<T extends LanguageGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LanguageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LanguageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LanguageGroupByOutputType[P]>
            : GetScalarType<T[P], LanguageGroupByOutputType[P]>
        }
      >
    >


  export type LanguageSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    code?: boolean
    name?: boolean
    originalLanguageMovies?: boolean | Language$originalLanguageMoviesArgs<ExtArgs>
    dubbedLanguageMovieProjections?: boolean | Language$dubbedLanguageMovieProjectionsArgs<ExtArgs>
    _count?: boolean | LanguageCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["language"]>

  export type LanguageSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    code?: boolean
    name?: boolean
  }, ExtArgs["result"]["language"]>

  export type LanguageSelectScalar = {
    code?: boolean
    name?: boolean
  }

  export type LanguageInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    originalLanguageMovies?: boolean | Language$originalLanguageMoviesArgs<ExtArgs>
    dubbedLanguageMovieProjections?: boolean | Language$dubbedLanguageMovieProjectionsArgs<ExtArgs>
    _count?: boolean | LanguageCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type LanguageIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $LanguagePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Language"
    objects: {
      originalLanguageMovies: Prisma.$MoviePayload<ExtArgs>[]
      dubbedLanguageMovieProjections: Prisma.$MovieProjectionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      code: string
      name: string
    }, ExtArgs["result"]["language"]>
    composites: {}
  }

  type LanguageGetPayload<S extends boolean | null | undefined | LanguageDefaultArgs> = $Result.GetResult<Prisma.$LanguagePayload, S>

  type LanguageCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<LanguageFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: LanguageCountAggregateInputType | true
    }

  export interface LanguageDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Language'], meta: { name: 'Language' } }
    /**
     * Find zero or one Language that matches the filter.
     * @param {LanguageFindUniqueArgs} args - Arguments to find a Language
     * @example
     * // Get one Language
     * const language = await prisma.language.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LanguageFindUniqueArgs>(args: SelectSubset<T, LanguageFindUniqueArgs<ExtArgs>>): Prisma__LanguageClient<$Result.GetResult<Prisma.$LanguagePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Language that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {LanguageFindUniqueOrThrowArgs} args - Arguments to find a Language
     * @example
     * // Get one Language
     * const language = await prisma.language.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LanguageFindUniqueOrThrowArgs>(args: SelectSubset<T, LanguageFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LanguageClient<$Result.GetResult<Prisma.$LanguagePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Language that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LanguageFindFirstArgs} args - Arguments to find a Language
     * @example
     * // Get one Language
     * const language = await prisma.language.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LanguageFindFirstArgs>(args?: SelectSubset<T, LanguageFindFirstArgs<ExtArgs>>): Prisma__LanguageClient<$Result.GetResult<Prisma.$LanguagePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Language that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LanguageFindFirstOrThrowArgs} args - Arguments to find a Language
     * @example
     * // Get one Language
     * const language = await prisma.language.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LanguageFindFirstOrThrowArgs>(args?: SelectSubset<T, LanguageFindFirstOrThrowArgs<ExtArgs>>): Prisma__LanguageClient<$Result.GetResult<Prisma.$LanguagePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Languages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LanguageFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Languages
     * const languages = await prisma.language.findMany()
     * 
     * // Get first 10 Languages
     * const languages = await prisma.language.findMany({ take: 10 })
     * 
     * // Only select the `code`
     * const languageWithCodeOnly = await prisma.language.findMany({ select: { code: true } })
     * 
     */
    findMany<T extends LanguageFindManyArgs>(args?: SelectSubset<T, LanguageFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LanguagePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Language.
     * @param {LanguageCreateArgs} args - Arguments to create a Language.
     * @example
     * // Create one Language
     * const Language = await prisma.language.create({
     *   data: {
     *     // ... data to create a Language
     *   }
     * })
     * 
     */
    create<T extends LanguageCreateArgs>(args: SelectSubset<T, LanguageCreateArgs<ExtArgs>>): Prisma__LanguageClient<$Result.GetResult<Prisma.$LanguagePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Languages.
     * @param {LanguageCreateManyArgs} args - Arguments to create many Languages.
     * @example
     * // Create many Languages
     * const language = await prisma.language.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LanguageCreateManyArgs>(args?: SelectSubset<T, LanguageCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Languages and returns the data saved in the database.
     * @param {LanguageCreateManyAndReturnArgs} args - Arguments to create many Languages.
     * @example
     * // Create many Languages
     * const language = await prisma.language.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Languages and only return the `code`
     * const languageWithCodeOnly = await prisma.language.createManyAndReturn({ 
     *   select: { code: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends LanguageCreateManyAndReturnArgs>(args?: SelectSubset<T, LanguageCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LanguagePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Language.
     * @param {LanguageDeleteArgs} args - Arguments to delete one Language.
     * @example
     * // Delete one Language
     * const Language = await prisma.language.delete({
     *   where: {
     *     // ... filter to delete one Language
     *   }
     * })
     * 
     */
    delete<T extends LanguageDeleteArgs>(args: SelectSubset<T, LanguageDeleteArgs<ExtArgs>>): Prisma__LanguageClient<$Result.GetResult<Prisma.$LanguagePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Language.
     * @param {LanguageUpdateArgs} args - Arguments to update one Language.
     * @example
     * // Update one Language
     * const language = await prisma.language.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LanguageUpdateArgs>(args: SelectSubset<T, LanguageUpdateArgs<ExtArgs>>): Prisma__LanguageClient<$Result.GetResult<Prisma.$LanguagePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Languages.
     * @param {LanguageDeleteManyArgs} args - Arguments to filter Languages to delete.
     * @example
     * // Delete a few Languages
     * const { count } = await prisma.language.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LanguageDeleteManyArgs>(args?: SelectSubset<T, LanguageDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Languages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LanguageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Languages
     * const language = await prisma.language.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LanguageUpdateManyArgs>(args: SelectSubset<T, LanguageUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Language.
     * @param {LanguageUpsertArgs} args - Arguments to update or create a Language.
     * @example
     * // Update or create a Language
     * const language = await prisma.language.upsert({
     *   create: {
     *     // ... data to create a Language
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Language we want to update
     *   }
     * })
     */
    upsert<T extends LanguageUpsertArgs>(args: SelectSubset<T, LanguageUpsertArgs<ExtArgs>>): Prisma__LanguageClient<$Result.GetResult<Prisma.$LanguagePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Languages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LanguageCountArgs} args - Arguments to filter Languages to count.
     * @example
     * // Count the number of Languages
     * const count = await prisma.language.count({
     *   where: {
     *     // ... the filter for the Languages we want to count
     *   }
     * })
    **/
    count<T extends LanguageCountArgs>(
      args?: Subset<T, LanguageCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LanguageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Language.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LanguageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LanguageAggregateArgs>(args: Subset<T, LanguageAggregateArgs>): Prisma.PrismaPromise<GetLanguageAggregateType<T>>

    /**
     * Group by Language.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LanguageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LanguageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LanguageGroupByArgs['orderBy'] }
        : { orderBy?: LanguageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LanguageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLanguageGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Language model
   */
  readonly fields: LanguageFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Language.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LanguageClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    originalLanguageMovies<T extends Language$originalLanguageMoviesArgs<ExtArgs> = {}>(args?: Subset<T, Language$originalLanguageMoviesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MoviePayload<ExtArgs>, T, "findMany"> | Null>
    dubbedLanguageMovieProjections<T extends Language$dubbedLanguageMovieProjectionsArgs<ExtArgs> = {}>(args?: Subset<T, Language$dubbedLanguageMovieProjectionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MovieProjectionPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Language model
   */ 
  interface LanguageFieldRefs {
    readonly code: FieldRef<"Language", 'String'>
    readonly name: FieldRef<"Language", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Language findUnique
   */
  export type LanguageFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Language
     */
    select?: LanguageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LanguageInclude<ExtArgs> | null
    /**
     * Filter, which Language to fetch.
     */
    where: LanguageWhereUniqueInput
  }

  /**
   * Language findUniqueOrThrow
   */
  export type LanguageFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Language
     */
    select?: LanguageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LanguageInclude<ExtArgs> | null
    /**
     * Filter, which Language to fetch.
     */
    where: LanguageWhereUniqueInput
  }

  /**
   * Language findFirst
   */
  export type LanguageFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Language
     */
    select?: LanguageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LanguageInclude<ExtArgs> | null
    /**
     * Filter, which Language to fetch.
     */
    where?: LanguageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Languages to fetch.
     */
    orderBy?: LanguageOrderByWithRelationInput | LanguageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Languages.
     */
    cursor?: LanguageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Languages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Languages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Languages.
     */
    distinct?: LanguageScalarFieldEnum | LanguageScalarFieldEnum[]
  }

  /**
   * Language findFirstOrThrow
   */
  export type LanguageFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Language
     */
    select?: LanguageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LanguageInclude<ExtArgs> | null
    /**
     * Filter, which Language to fetch.
     */
    where?: LanguageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Languages to fetch.
     */
    orderBy?: LanguageOrderByWithRelationInput | LanguageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Languages.
     */
    cursor?: LanguageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Languages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Languages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Languages.
     */
    distinct?: LanguageScalarFieldEnum | LanguageScalarFieldEnum[]
  }

  /**
   * Language findMany
   */
  export type LanguageFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Language
     */
    select?: LanguageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LanguageInclude<ExtArgs> | null
    /**
     * Filter, which Languages to fetch.
     */
    where?: LanguageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Languages to fetch.
     */
    orderBy?: LanguageOrderByWithRelationInput | LanguageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Languages.
     */
    cursor?: LanguageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Languages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Languages.
     */
    skip?: number
    distinct?: LanguageScalarFieldEnum | LanguageScalarFieldEnum[]
  }

  /**
   * Language create
   */
  export type LanguageCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Language
     */
    select?: LanguageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LanguageInclude<ExtArgs> | null
    /**
     * The data needed to create a Language.
     */
    data: XOR<LanguageCreateInput, LanguageUncheckedCreateInput>
  }

  /**
   * Language createMany
   */
  export type LanguageCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Languages.
     */
    data: LanguageCreateManyInput | LanguageCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Language createManyAndReturn
   */
  export type LanguageCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Language
     */
    select?: LanguageSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Languages.
     */
    data: LanguageCreateManyInput | LanguageCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Language update
   */
  export type LanguageUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Language
     */
    select?: LanguageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LanguageInclude<ExtArgs> | null
    /**
     * The data needed to update a Language.
     */
    data: XOR<LanguageUpdateInput, LanguageUncheckedUpdateInput>
    /**
     * Choose, which Language to update.
     */
    where: LanguageWhereUniqueInput
  }

  /**
   * Language updateMany
   */
  export type LanguageUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Languages.
     */
    data: XOR<LanguageUpdateManyMutationInput, LanguageUncheckedUpdateManyInput>
    /**
     * Filter which Languages to update
     */
    where?: LanguageWhereInput
  }

  /**
   * Language upsert
   */
  export type LanguageUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Language
     */
    select?: LanguageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LanguageInclude<ExtArgs> | null
    /**
     * The filter to search for the Language to update in case it exists.
     */
    where: LanguageWhereUniqueInput
    /**
     * In case the Language found by the `where` argument doesn't exist, create a new Language with this data.
     */
    create: XOR<LanguageCreateInput, LanguageUncheckedCreateInput>
    /**
     * In case the Language was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LanguageUpdateInput, LanguageUncheckedUpdateInput>
  }

  /**
   * Language delete
   */
  export type LanguageDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Language
     */
    select?: LanguageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LanguageInclude<ExtArgs> | null
    /**
     * Filter which Language to delete.
     */
    where: LanguageWhereUniqueInput
  }

  /**
   * Language deleteMany
   */
  export type LanguageDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Languages to delete
     */
    where?: LanguageWhereInput
  }

  /**
   * Language.originalLanguageMovies
   */
  export type Language$originalLanguageMoviesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Movie
     */
    select?: MovieSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MovieInclude<ExtArgs> | null
    where?: MovieWhereInput
    orderBy?: MovieOrderByWithRelationInput | MovieOrderByWithRelationInput[]
    cursor?: MovieWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MovieScalarFieldEnum | MovieScalarFieldEnum[]
  }

  /**
   * Language.dubbedLanguageMovieProjections
   */
  export type Language$dubbedLanguageMovieProjectionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MovieProjection
     */
    select?: MovieProjectionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MovieProjectionInclude<ExtArgs> | null
    where?: MovieProjectionWhereInput
    orderBy?: MovieProjectionOrderByWithRelationInput | MovieProjectionOrderByWithRelationInput[]
    cursor?: MovieProjectionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MovieProjectionScalarFieldEnum | MovieProjectionScalarFieldEnum[]
  }

  /**
   * Language without action
   */
  export type LanguageDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Language
     */
    select?: LanguageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LanguageInclude<ExtArgs> | null
  }


  /**
   * Model Country
   */

  export type AggregateCountry = {
    _count: CountryCountAggregateOutputType | null
    _min: CountryMinAggregateOutputType | null
    _max: CountryMaxAggregateOutputType | null
  }

  export type CountryMinAggregateOutputType = {
    code: string | null
    name: string | null
  }

  export type CountryMaxAggregateOutputType = {
    code: string | null
    name: string | null
  }

  export type CountryCountAggregateOutputType = {
    code: number
    name: number
    _all: number
  }


  export type CountryMinAggregateInputType = {
    code?: true
    name?: true
  }

  export type CountryMaxAggregateInputType = {
    code?: true
    name?: true
  }

  export type CountryCountAggregateInputType = {
    code?: true
    name?: true
    _all?: true
  }

  export type CountryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Country to aggregate.
     */
    where?: CountryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Countries to fetch.
     */
    orderBy?: CountryOrderByWithRelationInput | CountryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CountryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Countries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Countries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Countries
    **/
    _count?: true | CountryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CountryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CountryMaxAggregateInputType
  }

  export type GetCountryAggregateType<T extends CountryAggregateArgs> = {
        [P in keyof T & keyof AggregateCountry]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCountry[P]>
      : GetScalarType<T[P], AggregateCountry[P]>
  }




  export type CountryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CountryWhereInput
    orderBy?: CountryOrderByWithAggregationInput | CountryOrderByWithAggregationInput[]
    by: CountryScalarFieldEnum[] | CountryScalarFieldEnum
    having?: CountryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CountryCountAggregateInputType | true
    _min?: CountryMinAggregateInputType
    _max?: CountryMaxAggregateInputType
  }

  export type CountryGroupByOutputType = {
    code: string
    name: string
    _count: CountryCountAggregateOutputType | null
    _min: CountryMinAggregateOutputType | null
    _max: CountryMaxAggregateOutputType | null
  }

  type GetCountryGroupByPayload<T extends CountryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CountryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CountryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CountryGroupByOutputType[P]>
            : GetScalarType<T[P], CountryGroupByOutputType[P]>
        }
      >
    >


  export type CountrySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    code?: boolean
    name?: boolean
    cities?: boolean | Country$citiesArgs<ExtArgs>
    movies?: boolean | Country$moviesArgs<ExtArgs>
    _count?: boolean | CountryCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["country"]>

  export type CountrySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    code?: boolean
    name?: boolean
  }, ExtArgs["result"]["country"]>

  export type CountrySelectScalar = {
    code?: boolean
    name?: boolean
  }

  export type CountryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    cities?: boolean | Country$citiesArgs<ExtArgs>
    movies?: boolean | Country$moviesArgs<ExtArgs>
    _count?: boolean | CountryCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CountryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $CountryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Country"
    objects: {
      cities: Prisma.$CityPayload<ExtArgs>[]
      movies: Prisma.$MoviePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      code: string
      name: string
    }, ExtArgs["result"]["country"]>
    composites: {}
  }

  type CountryGetPayload<S extends boolean | null | undefined | CountryDefaultArgs> = $Result.GetResult<Prisma.$CountryPayload, S>

  type CountryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CountryFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CountryCountAggregateInputType | true
    }

  export interface CountryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Country'], meta: { name: 'Country' } }
    /**
     * Find zero or one Country that matches the filter.
     * @param {CountryFindUniqueArgs} args - Arguments to find a Country
     * @example
     * // Get one Country
     * const country = await prisma.country.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CountryFindUniqueArgs>(args: SelectSubset<T, CountryFindUniqueArgs<ExtArgs>>): Prisma__CountryClient<$Result.GetResult<Prisma.$CountryPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Country that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {CountryFindUniqueOrThrowArgs} args - Arguments to find a Country
     * @example
     * // Get one Country
     * const country = await prisma.country.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CountryFindUniqueOrThrowArgs>(args: SelectSubset<T, CountryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CountryClient<$Result.GetResult<Prisma.$CountryPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Country that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CountryFindFirstArgs} args - Arguments to find a Country
     * @example
     * // Get one Country
     * const country = await prisma.country.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CountryFindFirstArgs>(args?: SelectSubset<T, CountryFindFirstArgs<ExtArgs>>): Prisma__CountryClient<$Result.GetResult<Prisma.$CountryPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Country that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CountryFindFirstOrThrowArgs} args - Arguments to find a Country
     * @example
     * // Get one Country
     * const country = await prisma.country.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CountryFindFirstOrThrowArgs>(args?: SelectSubset<T, CountryFindFirstOrThrowArgs<ExtArgs>>): Prisma__CountryClient<$Result.GetResult<Prisma.$CountryPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Countries that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CountryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Countries
     * const countries = await prisma.country.findMany()
     * 
     * // Get first 10 Countries
     * const countries = await prisma.country.findMany({ take: 10 })
     * 
     * // Only select the `code`
     * const countryWithCodeOnly = await prisma.country.findMany({ select: { code: true } })
     * 
     */
    findMany<T extends CountryFindManyArgs>(args?: SelectSubset<T, CountryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CountryPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Country.
     * @param {CountryCreateArgs} args - Arguments to create a Country.
     * @example
     * // Create one Country
     * const Country = await prisma.country.create({
     *   data: {
     *     // ... data to create a Country
     *   }
     * })
     * 
     */
    create<T extends CountryCreateArgs>(args: SelectSubset<T, CountryCreateArgs<ExtArgs>>): Prisma__CountryClient<$Result.GetResult<Prisma.$CountryPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Countries.
     * @param {CountryCreateManyArgs} args - Arguments to create many Countries.
     * @example
     * // Create many Countries
     * const country = await prisma.country.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CountryCreateManyArgs>(args?: SelectSubset<T, CountryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Countries and returns the data saved in the database.
     * @param {CountryCreateManyAndReturnArgs} args - Arguments to create many Countries.
     * @example
     * // Create many Countries
     * const country = await prisma.country.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Countries and only return the `code`
     * const countryWithCodeOnly = await prisma.country.createManyAndReturn({ 
     *   select: { code: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CountryCreateManyAndReturnArgs>(args?: SelectSubset<T, CountryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CountryPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Country.
     * @param {CountryDeleteArgs} args - Arguments to delete one Country.
     * @example
     * // Delete one Country
     * const Country = await prisma.country.delete({
     *   where: {
     *     // ... filter to delete one Country
     *   }
     * })
     * 
     */
    delete<T extends CountryDeleteArgs>(args: SelectSubset<T, CountryDeleteArgs<ExtArgs>>): Prisma__CountryClient<$Result.GetResult<Prisma.$CountryPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Country.
     * @param {CountryUpdateArgs} args - Arguments to update one Country.
     * @example
     * // Update one Country
     * const country = await prisma.country.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CountryUpdateArgs>(args: SelectSubset<T, CountryUpdateArgs<ExtArgs>>): Prisma__CountryClient<$Result.GetResult<Prisma.$CountryPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Countries.
     * @param {CountryDeleteManyArgs} args - Arguments to filter Countries to delete.
     * @example
     * // Delete a few Countries
     * const { count } = await prisma.country.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CountryDeleteManyArgs>(args?: SelectSubset<T, CountryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Countries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CountryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Countries
     * const country = await prisma.country.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CountryUpdateManyArgs>(args: SelectSubset<T, CountryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Country.
     * @param {CountryUpsertArgs} args - Arguments to update or create a Country.
     * @example
     * // Update or create a Country
     * const country = await prisma.country.upsert({
     *   create: {
     *     // ... data to create a Country
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Country we want to update
     *   }
     * })
     */
    upsert<T extends CountryUpsertArgs>(args: SelectSubset<T, CountryUpsertArgs<ExtArgs>>): Prisma__CountryClient<$Result.GetResult<Prisma.$CountryPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Countries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CountryCountArgs} args - Arguments to filter Countries to count.
     * @example
     * // Count the number of Countries
     * const count = await prisma.country.count({
     *   where: {
     *     // ... the filter for the Countries we want to count
     *   }
     * })
    **/
    count<T extends CountryCountArgs>(
      args?: Subset<T, CountryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CountryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Country.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CountryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CountryAggregateArgs>(args: Subset<T, CountryAggregateArgs>): Prisma.PrismaPromise<GetCountryAggregateType<T>>

    /**
     * Group by Country.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CountryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CountryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CountryGroupByArgs['orderBy'] }
        : { orderBy?: CountryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CountryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCountryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Country model
   */
  readonly fields: CountryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Country.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CountryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    cities<T extends Country$citiesArgs<ExtArgs> = {}>(args?: Subset<T, Country$citiesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CityPayload<ExtArgs>, T, "findMany"> | Null>
    movies<T extends Country$moviesArgs<ExtArgs> = {}>(args?: Subset<T, Country$moviesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MoviePayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Country model
   */ 
  interface CountryFieldRefs {
    readonly code: FieldRef<"Country", 'String'>
    readonly name: FieldRef<"Country", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Country findUnique
   */
  export type CountryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Country
     */
    select?: CountrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CountryInclude<ExtArgs> | null
    /**
     * Filter, which Country to fetch.
     */
    where: CountryWhereUniqueInput
  }

  /**
   * Country findUniqueOrThrow
   */
  export type CountryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Country
     */
    select?: CountrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CountryInclude<ExtArgs> | null
    /**
     * Filter, which Country to fetch.
     */
    where: CountryWhereUniqueInput
  }

  /**
   * Country findFirst
   */
  export type CountryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Country
     */
    select?: CountrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CountryInclude<ExtArgs> | null
    /**
     * Filter, which Country to fetch.
     */
    where?: CountryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Countries to fetch.
     */
    orderBy?: CountryOrderByWithRelationInput | CountryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Countries.
     */
    cursor?: CountryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Countries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Countries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Countries.
     */
    distinct?: CountryScalarFieldEnum | CountryScalarFieldEnum[]
  }

  /**
   * Country findFirstOrThrow
   */
  export type CountryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Country
     */
    select?: CountrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CountryInclude<ExtArgs> | null
    /**
     * Filter, which Country to fetch.
     */
    where?: CountryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Countries to fetch.
     */
    orderBy?: CountryOrderByWithRelationInput | CountryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Countries.
     */
    cursor?: CountryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Countries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Countries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Countries.
     */
    distinct?: CountryScalarFieldEnum | CountryScalarFieldEnum[]
  }

  /**
   * Country findMany
   */
  export type CountryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Country
     */
    select?: CountrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CountryInclude<ExtArgs> | null
    /**
     * Filter, which Countries to fetch.
     */
    where?: CountryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Countries to fetch.
     */
    orderBy?: CountryOrderByWithRelationInput | CountryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Countries.
     */
    cursor?: CountryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Countries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Countries.
     */
    skip?: number
    distinct?: CountryScalarFieldEnum | CountryScalarFieldEnum[]
  }

  /**
   * Country create
   */
  export type CountryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Country
     */
    select?: CountrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CountryInclude<ExtArgs> | null
    /**
     * The data needed to create a Country.
     */
    data: XOR<CountryCreateInput, CountryUncheckedCreateInput>
  }

  /**
   * Country createMany
   */
  export type CountryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Countries.
     */
    data: CountryCreateManyInput | CountryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Country createManyAndReturn
   */
  export type CountryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Country
     */
    select?: CountrySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Countries.
     */
    data: CountryCreateManyInput | CountryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Country update
   */
  export type CountryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Country
     */
    select?: CountrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CountryInclude<ExtArgs> | null
    /**
     * The data needed to update a Country.
     */
    data: XOR<CountryUpdateInput, CountryUncheckedUpdateInput>
    /**
     * Choose, which Country to update.
     */
    where: CountryWhereUniqueInput
  }

  /**
   * Country updateMany
   */
  export type CountryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Countries.
     */
    data: XOR<CountryUpdateManyMutationInput, CountryUncheckedUpdateManyInput>
    /**
     * Filter which Countries to update
     */
    where?: CountryWhereInput
  }

  /**
   * Country upsert
   */
  export type CountryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Country
     */
    select?: CountrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CountryInclude<ExtArgs> | null
    /**
     * The filter to search for the Country to update in case it exists.
     */
    where: CountryWhereUniqueInput
    /**
     * In case the Country found by the `where` argument doesn't exist, create a new Country with this data.
     */
    create: XOR<CountryCreateInput, CountryUncheckedCreateInput>
    /**
     * In case the Country was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CountryUpdateInput, CountryUncheckedUpdateInput>
  }

  /**
   * Country delete
   */
  export type CountryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Country
     */
    select?: CountrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CountryInclude<ExtArgs> | null
    /**
     * Filter which Country to delete.
     */
    where: CountryWhereUniqueInput
  }

  /**
   * Country deleteMany
   */
  export type CountryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Countries to delete
     */
    where?: CountryWhereInput
  }

  /**
   * Country.cities
   */
  export type Country$citiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the City
     */
    select?: CitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CityInclude<ExtArgs> | null
    where?: CityWhereInput
    orderBy?: CityOrderByWithRelationInput | CityOrderByWithRelationInput[]
    cursor?: CityWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CityScalarFieldEnum | CityScalarFieldEnum[]
  }

  /**
   * Country.movies
   */
  export type Country$moviesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Movie
     */
    select?: MovieSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MovieInclude<ExtArgs> | null
    where?: MovieWhereInput
    orderBy?: MovieOrderByWithRelationInput | MovieOrderByWithRelationInput[]
    cursor?: MovieWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MovieScalarFieldEnum | MovieScalarFieldEnum[]
  }

  /**
   * Country without action
   */
  export type CountryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Country
     */
    select?: CountrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CountryInclude<ExtArgs> | null
  }


  /**
   * Model City
   */

  export type AggregateCity = {
    _count: CityCountAggregateOutputType | null
    _min: CityMinAggregateOutputType | null
    _max: CityMaxAggregateOutputType | null
  }

  export type CityMinAggregateOutputType = {
    id: string | null
    cityCode: string | null
    name: string | null
    postalCode: string | null
    countryCode: string | null
  }

  export type CityMaxAggregateOutputType = {
    id: string | null
    cityCode: string | null
    name: string | null
    postalCode: string | null
    countryCode: string | null
  }

  export type CityCountAggregateOutputType = {
    id: number
    cityCode: number
    name: number
    postalCode: number
    countryCode: number
    _all: number
  }


  export type CityMinAggregateInputType = {
    id?: true
    cityCode?: true
    name?: true
    postalCode?: true
    countryCode?: true
  }

  export type CityMaxAggregateInputType = {
    id?: true
    cityCode?: true
    name?: true
    postalCode?: true
    countryCode?: true
  }

  export type CityCountAggregateInputType = {
    id?: true
    cityCode?: true
    name?: true
    postalCode?: true
    countryCode?: true
    _all?: true
  }

  export type CityAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which City to aggregate.
     */
    where?: CityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Cities to fetch.
     */
    orderBy?: CityOrderByWithRelationInput | CityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Cities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Cities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Cities
    **/
    _count?: true | CityCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CityMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CityMaxAggregateInputType
  }

  export type GetCityAggregateType<T extends CityAggregateArgs> = {
        [P in keyof T & keyof AggregateCity]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCity[P]>
      : GetScalarType<T[P], AggregateCity[P]>
  }




  export type CityGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CityWhereInput
    orderBy?: CityOrderByWithAggregationInput | CityOrderByWithAggregationInput[]
    by: CityScalarFieldEnum[] | CityScalarFieldEnum
    having?: CityScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CityCountAggregateInputType | true
    _min?: CityMinAggregateInputType
    _max?: CityMaxAggregateInputType
  }

  export type CityGroupByOutputType = {
    id: string
    cityCode: string
    name: string
    postalCode: string
    countryCode: string
    _count: CityCountAggregateOutputType | null
    _min: CityMinAggregateOutputType | null
    _max: CityMaxAggregateOutputType | null
  }

  type GetCityGroupByPayload<T extends CityGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CityGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CityGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CityGroupByOutputType[P]>
            : GetScalarType<T[P], CityGroupByOutputType[P]>
        }
      >
    >


  export type CitySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    cityCode?: boolean
    name?: boolean
    postalCode?: boolean
    countryCode?: boolean
    country?: boolean | CountryDefaultArgs<ExtArgs>
    cinemas?: boolean | City$cinemasArgs<ExtArgs>
    _count?: boolean | CityCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["city"]>

  export type CitySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    cityCode?: boolean
    name?: boolean
    postalCode?: boolean
    countryCode?: boolean
    country?: boolean | CountryDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["city"]>

  export type CitySelectScalar = {
    id?: boolean
    cityCode?: boolean
    name?: boolean
    postalCode?: boolean
    countryCode?: boolean
  }

  export type CityInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    country?: boolean | CountryDefaultArgs<ExtArgs>
    cinemas?: boolean | City$cinemasArgs<ExtArgs>
    _count?: boolean | CityCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CityIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    country?: boolean | CountryDefaultArgs<ExtArgs>
  }

  export type $CityPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "City"
    objects: {
      country: Prisma.$CountryPayload<ExtArgs>
      cinemas: Prisma.$CinemaPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      cityCode: string
      name: string
      postalCode: string
      countryCode: string
    }, ExtArgs["result"]["city"]>
    composites: {}
  }

  type CityGetPayload<S extends boolean | null | undefined | CityDefaultArgs> = $Result.GetResult<Prisma.$CityPayload, S>

  type CityCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CityFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CityCountAggregateInputType | true
    }

  export interface CityDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['City'], meta: { name: 'City' } }
    /**
     * Find zero or one City that matches the filter.
     * @param {CityFindUniqueArgs} args - Arguments to find a City
     * @example
     * // Get one City
     * const city = await prisma.city.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CityFindUniqueArgs>(args: SelectSubset<T, CityFindUniqueArgs<ExtArgs>>): Prisma__CityClient<$Result.GetResult<Prisma.$CityPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one City that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {CityFindUniqueOrThrowArgs} args - Arguments to find a City
     * @example
     * // Get one City
     * const city = await prisma.city.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CityFindUniqueOrThrowArgs>(args: SelectSubset<T, CityFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CityClient<$Result.GetResult<Prisma.$CityPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first City that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CityFindFirstArgs} args - Arguments to find a City
     * @example
     * // Get one City
     * const city = await prisma.city.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CityFindFirstArgs>(args?: SelectSubset<T, CityFindFirstArgs<ExtArgs>>): Prisma__CityClient<$Result.GetResult<Prisma.$CityPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first City that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CityFindFirstOrThrowArgs} args - Arguments to find a City
     * @example
     * // Get one City
     * const city = await prisma.city.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CityFindFirstOrThrowArgs>(args?: SelectSubset<T, CityFindFirstOrThrowArgs<ExtArgs>>): Prisma__CityClient<$Result.GetResult<Prisma.$CityPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Cities that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CityFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Cities
     * const cities = await prisma.city.findMany()
     * 
     * // Get first 10 Cities
     * const cities = await prisma.city.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const cityWithIdOnly = await prisma.city.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CityFindManyArgs>(args?: SelectSubset<T, CityFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CityPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a City.
     * @param {CityCreateArgs} args - Arguments to create a City.
     * @example
     * // Create one City
     * const City = await prisma.city.create({
     *   data: {
     *     // ... data to create a City
     *   }
     * })
     * 
     */
    create<T extends CityCreateArgs>(args: SelectSubset<T, CityCreateArgs<ExtArgs>>): Prisma__CityClient<$Result.GetResult<Prisma.$CityPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Cities.
     * @param {CityCreateManyArgs} args - Arguments to create many Cities.
     * @example
     * // Create many Cities
     * const city = await prisma.city.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CityCreateManyArgs>(args?: SelectSubset<T, CityCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Cities and returns the data saved in the database.
     * @param {CityCreateManyAndReturnArgs} args - Arguments to create many Cities.
     * @example
     * // Create many Cities
     * const city = await prisma.city.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Cities and only return the `id`
     * const cityWithIdOnly = await prisma.city.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CityCreateManyAndReturnArgs>(args?: SelectSubset<T, CityCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CityPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a City.
     * @param {CityDeleteArgs} args - Arguments to delete one City.
     * @example
     * // Delete one City
     * const City = await prisma.city.delete({
     *   where: {
     *     // ... filter to delete one City
     *   }
     * })
     * 
     */
    delete<T extends CityDeleteArgs>(args: SelectSubset<T, CityDeleteArgs<ExtArgs>>): Prisma__CityClient<$Result.GetResult<Prisma.$CityPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one City.
     * @param {CityUpdateArgs} args - Arguments to update one City.
     * @example
     * // Update one City
     * const city = await prisma.city.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CityUpdateArgs>(args: SelectSubset<T, CityUpdateArgs<ExtArgs>>): Prisma__CityClient<$Result.GetResult<Prisma.$CityPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Cities.
     * @param {CityDeleteManyArgs} args - Arguments to filter Cities to delete.
     * @example
     * // Delete a few Cities
     * const { count } = await prisma.city.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CityDeleteManyArgs>(args?: SelectSubset<T, CityDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Cities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CityUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Cities
     * const city = await prisma.city.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CityUpdateManyArgs>(args: SelectSubset<T, CityUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one City.
     * @param {CityUpsertArgs} args - Arguments to update or create a City.
     * @example
     * // Update or create a City
     * const city = await prisma.city.upsert({
     *   create: {
     *     // ... data to create a City
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the City we want to update
     *   }
     * })
     */
    upsert<T extends CityUpsertArgs>(args: SelectSubset<T, CityUpsertArgs<ExtArgs>>): Prisma__CityClient<$Result.GetResult<Prisma.$CityPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Cities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CityCountArgs} args - Arguments to filter Cities to count.
     * @example
     * // Count the number of Cities
     * const count = await prisma.city.count({
     *   where: {
     *     // ... the filter for the Cities we want to count
     *   }
     * })
    **/
    count<T extends CityCountArgs>(
      args?: Subset<T, CityCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CityCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a City.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CityAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CityAggregateArgs>(args: Subset<T, CityAggregateArgs>): Prisma.PrismaPromise<GetCityAggregateType<T>>

    /**
     * Group by City.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CityGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CityGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CityGroupByArgs['orderBy'] }
        : { orderBy?: CityGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CityGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCityGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the City model
   */
  readonly fields: CityFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for City.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CityClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    country<T extends CountryDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CountryDefaultArgs<ExtArgs>>): Prisma__CountryClient<$Result.GetResult<Prisma.$CountryPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    cinemas<T extends City$cinemasArgs<ExtArgs> = {}>(args?: Subset<T, City$cinemasArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CinemaPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the City model
   */ 
  interface CityFieldRefs {
    readonly id: FieldRef<"City", 'String'>
    readonly cityCode: FieldRef<"City", 'String'>
    readonly name: FieldRef<"City", 'String'>
    readonly postalCode: FieldRef<"City", 'String'>
    readonly countryCode: FieldRef<"City", 'String'>
  }
    

  // Custom InputTypes
  /**
   * City findUnique
   */
  export type CityFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the City
     */
    select?: CitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CityInclude<ExtArgs> | null
    /**
     * Filter, which City to fetch.
     */
    where: CityWhereUniqueInput
  }

  /**
   * City findUniqueOrThrow
   */
  export type CityFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the City
     */
    select?: CitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CityInclude<ExtArgs> | null
    /**
     * Filter, which City to fetch.
     */
    where: CityWhereUniqueInput
  }

  /**
   * City findFirst
   */
  export type CityFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the City
     */
    select?: CitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CityInclude<ExtArgs> | null
    /**
     * Filter, which City to fetch.
     */
    where?: CityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Cities to fetch.
     */
    orderBy?: CityOrderByWithRelationInput | CityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Cities.
     */
    cursor?: CityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Cities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Cities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Cities.
     */
    distinct?: CityScalarFieldEnum | CityScalarFieldEnum[]
  }

  /**
   * City findFirstOrThrow
   */
  export type CityFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the City
     */
    select?: CitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CityInclude<ExtArgs> | null
    /**
     * Filter, which City to fetch.
     */
    where?: CityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Cities to fetch.
     */
    orderBy?: CityOrderByWithRelationInput | CityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Cities.
     */
    cursor?: CityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Cities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Cities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Cities.
     */
    distinct?: CityScalarFieldEnum | CityScalarFieldEnum[]
  }

  /**
   * City findMany
   */
  export type CityFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the City
     */
    select?: CitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CityInclude<ExtArgs> | null
    /**
     * Filter, which Cities to fetch.
     */
    where?: CityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Cities to fetch.
     */
    orderBy?: CityOrderByWithRelationInput | CityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Cities.
     */
    cursor?: CityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Cities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Cities.
     */
    skip?: number
    distinct?: CityScalarFieldEnum | CityScalarFieldEnum[]
  }

  /**
   * City create
   */
  export type CityCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the City
     */
    select?: CitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CityInclude<ExtArgs> | null
    /**
     * The data needed to create a City.
     */
    data: XOR<CityCreateInput, CityUncheckedCreateInput>
  }

  /**
   * City createMany
   */
  export type CityCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Cities.
     */
    data: CityCreateManyInput | CityCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * City createManyAndReturn
   */
  export type CityCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the City
     */
    select?: CitySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Cities.
     */
    data: CityCreateManyInput | CityCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CityIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * City update
   */
  export type CityUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the City
     */
    select?: CitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CityInclude<ExtArgs> | null
    /**
     * The data needed to update a City.
     */
    data: XOR<CityUpdateInput, CityUncheckedUpdateInput>
    /**
     * Choose, which City to update.
     */
    where: CityWhereUniqueInput
  }

  /**
   * City updateMany
   */
  export type CityUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Cities.
     */
    data: XOR<CityUpdateManyMutationInput, CityUncheckedUpdateManyInput>
    /**
     * Filter which Cities to update
     */
    where?: CityWhereInput
  }

  /**
   * City upsert
   */
  export type CityUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the City
     */
    select?: CitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CityInclude<ExtArgs> | null
    /**
     * The filter to search for the City to update in case it exists.
     */
    where: CityWhereUniqueInput
    /**
     * In case the City found by the `where` argument doesn't exist, create a new City with this data.
     */
    create: XOR<CityCreateInput, CityUncheckedCreateInput>
    /**
     * In case the City was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CityUpdateInput, CityUncheckedUpdateInput>
  }

  /**
   * City delete
   */
  export type CityDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the City
     */
    select?: CitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CityInclude<ExtArgs> | null
    /**
     * Filter which City to delete.
     */
    where: CityWhereUniqueInput
  }

  /**
   * City deleteMany
   */
  export type CityDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Cities to delete
     */
    where?: CityWhereInput
  }

  /**
   * City.cinemas
   */
  export type City$cinemasArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cinema
     */
    select?: CinemaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CinemaInclude<ExtArgs> | null
    where?: CinemaWhereInput
    orderBy?: CinemaOrderByWithRelationInput | CinemaOrderByWithRelationInput[]
    cursor?: CinemaWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CinemaScalarFieldEnum | CinemaScalarFieldEnum[]
  }

  /**
   * City without action
   */
  export type CityDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the City
     */
    select?: CitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CityInclude<ExtArgs> | null
  }


  /**
   * Model Cinema
   */

  export type AggregateCinema = {
    _count: CinemaCountAggregateOutputType | null
    _avg: CinemaAvgAggregateOutputType | null
    _sum: CinemaSumAggregateOutputType | null
    _min: CinemaMinAggregateOutputType | null
    _max: CinemaMaxAggregateOutputType | null
  }

  export type CinemaAvgAggregateOutputType = {
    rating: number | null
    geoLatitude: Decimal | null
    geoLongitude: Decimal | null
  }

  export type CinemaSumAggregateOutputType = {
    rating: number | null
    geoLatitude: Decimal | null
    geoLongitude: Decimal | null
  }

  export type CinemaMinAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    cityId: string | null
    address: string | null
    rating: number | null
    geoLatitude: Decimal | null
    geoLongitude: Decimal | null
  }

  export type CinemaMaxAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    cityId: string | null
    address: string | null
    rating: number | null
    geoLatitude: Decimal | null
    geoLongitude: Decimal | null
  }

  export type CinemaCountAggregateOutputType = {
    id: number
    name: number
    description: number
    cityId: number
    address: number
    rating: number
    phone: number
    posterImages: number
    geoLatitude: number
    geoLongitude: number
    _all: number
  }


  export type CinemaAvgAggregateInputType = {
    rating?: true
    geoLatitude?: true
    geoLongitude?: true
  }

  export type CinemaSumAggregateInputType = {
    rating?: true
    geoLatitude?: true
    geoLongitude?: true
  }

  export type CinemaMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    cityId?: true
    address?: true
    rating?: true
    geoLatitude?: true
    geoLongitude?: true
  }

  export type CinemaMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    cityId?: true
    address?: true
    rating?: true
    geoLatitude?: true
    geoLongitude?: true
  }

  export type CinemaCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    cityId?: true
    address?: true
    rating?: true
    phone?: true
    posterImages?: true
    geoLatitude?: true
    geoLongitude?: true
    _all?: true
  }

  export type CinemaAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Cinema to aggregate.
     */
    where?: CinemaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Cinemas to fetch.
     */
    orderBy?: CinemaOrderByWithRelationInput | CinemaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CinemaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Cinemas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Cinemas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Cinemas
    **/
    _count?: true | CinemaCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CinemaAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CinemaSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CinemaMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CinemaMaxAggregateInputType
  }

  export type GetCinemaAggregateType<T extends CinemaAggregateArgs> = {
        [P in keyof T & keyof AggregateCinema]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCinema[P]>
      : GetScalarType<T[P], AggregateCinema[P]>
  }




  export type CinemaGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CinemaWhereInput
    orderBy?: CinemaOrderByWithAggregationInput | CinemaOrderByWithAggregationInput[]
    by: CinemaScalarFieldEnum[] | CinemaScalarFieldEnum
    having?: CinemaScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CinemaCountAggregateInputType | true
    _avg?: CinemaAvgAggregateInputType
    _sum?: CinemaSumAggregateInputType
    _min?: CinemaMinAggregateInputType
    _max?: CinemaMaxAggregateInputType
  }

  export type CinemaGroupByOutputType = {
    id: string
    name: string
    description: string
    cityId: string
    address: string
    rating: number
    phone: JsonValue
    posterImages: JsonValue
    geoLatitude: Decimal | null
    geoLongitude: Decimal | null
    _count: CinemaCountAggregateOutputType | null
    _avg: CinemaAvgAggregateOutputType | null
    _sum: CinemaSumAggregateOutputType | null
    _min: CinemaMinAggregateOutputType | null
    _max: CinemaMaxAggregateOutputType | null
  }

  type GetCinemaGroupByPayload<T extends CinemaGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CinemaGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CinemaGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CinemaGroupByOutputType[P]>
            : GetScalarType<T[P], CinemaGroupByOutputType[P]>
        }
      >
    >


  export type CinemaSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    cityId?: boolean
    address?: boolean
    rating?: boolean
    phone?: boolean
    posterImages?: boolean
    geoLatitude?: boolean
    geoLongitude?: boolean
    city?: boolean | CityDefaultArgs<ExtArgs>
    cinemaTheaters?: boolean | Cinema$cinemaTheatersArgs<ExtArgs>
    movieCinemaOverrides?: boolean | Cinema$movieCinemaOverridesArgs<ExtArgs>
    _count?: boolean | CinemaCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["cinema"]>

  export type CinemaSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    cityId?: boolean
    address?: boolean
    rating?: boolean
    phone?: boolean
    posterImages?: boolean
    geoLatitude?: boolean
    geoLongitude?: boolean
    city?: boolean | CityDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["cinema"]>

  export type CinemaSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    cityId?: boolean
    address?: boolean
    rating?: boolean
    phone?: boolean
    posterImages?: boolean
    geoLatitude?: boolean
    geoLongitude?: boolean
  }

  export type CinemaInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    city?: boolean | CityDefaultArgs<ExtArgs>
    cinemaTheaters?: boolean | Cinema$cinemaTheatersArgs<ExtArgs>
    movieCinemaOverrides?: boolean | Cinema$movieCinemaOverridesArgs<ExtArgs>
    _count?: boolean | CinemaCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CinemaIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    city?: boolean | CityDefaultArgs<ExtArgs>
  }

  export type $CinemaPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Cinema"
    objects: {
      city: Prisma.$CityPayload<ExtArgs>
      cinemaTheaters: Prisma.$CinemaTheaterPayload<ExtArgs>[]
      movieCinemaOverrides: Prisma.$MovieCinemaOverridePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      description: string
      cityId: string
      address: string
      rating: number
      phone: Prisma.JsonValue
      posterImages: Prisma.JsonValue
      geoLatitude: Prisma.Decimal | null
      geoLongitude: Prisma.Decimal | null
    }, ExtArgs["result"]["cinema"]>
    composites: {}
  }

  type CinemaGetPayload<S extends boolean | null | undefined | CinemaDefaultArgs> = $Result.GetResult<Prisma.$CinemaPayload, S>

  type CinemaCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CinemaFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CinemaCountAggregateInputType | true
    }

  export interface CinemaDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Cinema'], meta: { name: 'Cinema' } }
    /**
     * Find zero or one Cinema that matches the filter.
     * @param {CinemaFindUniqueArgs} args - Arguments to find a Cinema
     * @example
     * // Get one Cinema
     * const cinema = await prisma.cinema.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CinemaFindUniqueArgs>(args: SelectSubset<T, CinemaFindUniqueArgs<ExtArgs>>): Prisma__CinemaClient<$Result.GetResult<Prisma.$CinemaPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Cinema that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {CinemaFindUniqueOrThrowArgs} args - Arguments to find a Cinema
     * @example
     * // Get one Cinema
     * const cinema = await prisma.cinema.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CinemaFindUniqueOrThrowArgs>(args: SelectSubset<T, CinemaFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CinemaClient<$Result.GetResult<Prisma.$CinemaPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Cinema that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CinemaFindFirstArgs} args - Arguments to find a Cinema
     * @example
     * // Get one Cinema
     * const cinema = await prisma.cinema.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CinemaFindFirstArgs>(args?: SelectSubset<T, CinemaFindFirstArgs<ExtArgs>>): Prisma__CinemaClient<$Result.GetResult<Prisma.$CinemaPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Cinema that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CinemaFindFirstOrThrowArgs} args - Arguments to find a Cinema
     * @example
     * // Get one Cinema
     * const cinema = await prisma.cinema.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CinemaFindFirstOrThrowArgs>(args?: SelectSubset<T, CinemaFindFirstOrThrowArgs<ExtArgs>>): Prisma__CinemaClient<$Result.GetResult<Prisma.$CinemaPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Cinemas that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CinemaFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Cinemas
     * const cinemas = await prisma.cinema.findMany()
     * 
     * // Get first 10 Cinemas
     * const cinemas = await prisma.cinema.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const cinemaWithIdOnly = await prisma.cinema.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CinemaFindManyArgs>(args?: SelectSubset<T, CinemaFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CinemaPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Cinema.
     * @param {CinemaCreateArgs} args - Arguments to create a Cinema.
     * @example
     * // Create one Cinema
     * const Cinema = await prisma.cinema.create({
     *   data: {
     *     // ... data to create a Cinema
     *   }
     * })
     * 
     */
    create<T extends CinemaCreateArgs>(args: SelectSubset<T, CinemaCreateArgs<ExtArgs>>): Prisma__CinemaClient<$Result.GetResult<Prisma.$CinemaPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Cinemas.
     * @param {CinemaCreateManyArgs} args - Arguments to create many Cinemas.
     * @example
     * // Create many Cinemas
     * const cinema = await prisma.cinema.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CinemaCreateManyArgs>(args?: SelectSubset<T, CinemaCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Cinemas and returns the data saved in the database.
     * @param {CinemaCreateManyAndReturnArgs} args - Arguments to create many Cinemas.
     * @example
     * // Create many Cinemas
     * const cinema = await prisma.cinema.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Cinemas and only return the `id`
     * const cinemaWithIdOnly = await prisma.cinema.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CinemaCreateManyAndReturnArgs>(args?: SelectSubset<T, CinemaCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CinemaPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Cinema.
     * @param {CinemaDeleteArgs} args - Arguments to delete one Cinema.
     * @example
     * // Delete one Cinema
     * const Cinema = await prisma.cinema.delete({
     *   where: {
     *     // ... filter to delete one Cinema
     *   }
     * })
     * 
     */
    delete<T extends CinemaDeleteArgs>(args: SelectSubset<T, CinemaDeleteArgs<ExtArgs>>): Prisma__CinemaClient<$Result.GetResult<Prisma.$CinemaPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Cinema.
     * @param {CinemaUpdateArgs} args - Arguments to update one Cinema.
     * @example
     * // Update one Cinema
     * const cinema = await prisma.cinema.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CinemaUpdateArgs>(args: SelectSubset<T, CinemaUpdateArgs<ExtArgs>>): Prisma__CinemaClient<$Result.GetResult<Prisma.$CinemaPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Cinemas.
     * @param {CinemaDeleteManyArgs} args - Arguments to filter Cinemas to delete.
     * @example
     * // Delete a few Cinemas
     * const { count } = await prisma.cinema.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CinemaDeleteManyArgs>(args?: SelectSubset<T, CinemaDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Cinemas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CinemaUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Cinemas
     * const cinema = await prisma.cinema.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CinemaUpdateManyArgs>(args: SelectSubset<T, CinemaUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Cinema.
     * @param {CinemaUpsertArgs} args - Arguments to update or create a Cinema.
     * @example
     * // Update or create a Cinema
     * const cinema = await prisma.cinema.upsert({
     *   create: {
     *     // ... data to create a Cinema
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Cinema we want to update
     *   }
     * })
     */
    upsert<T extends CinemaUpsertArgs>(args: SelectSubset<T, CinemaUpsertArgs<ExtArgs>>): Prisma__CinemaClient<$Result.GetResult<Prisma.$CinemaPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Cinemas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CinemaCountArgs} args - Arguments to filter Cinemas to count.
     * @example
     * // Count the number of Cinemas
     * const count = await prisma.cinema.count({
     *   where: {
     *     // ... the filter for the Cinemas we want to count
     *   }
     * })
    **/
    count<T extends CinemaCountArgs>(
      args?: Subset<T, CinemaCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CinemaCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Cinema.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CinemaAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CinemaAggregateArgs>(args: Subset<T, CinemaAggregateArgs>): Prisma.PrismaPromise<GetCinemaAggregateType<T>>

    /**
     * Group by Cinema.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CinemaGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CinemaGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CinemaGroupByArgs['orderBy'] }
        : { orderBy?: CinemaGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CinemaGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCinemaGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Cinema model
   */
  readonly fields: CinemaFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Cinema.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CinemaClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    city<T extends CityDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CityDefaultArgs<ExtArgs>>): Prisma__CityClient<$Result.GetResult<Prisma.$CityPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    cinemaTheaters<T extends Cinema$cinemaTheatersArgs<ExtArgs> = {}>(args?: Subset<T, Cinema$cinemaTheatersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CinemaTheaterPayload<ExtArgs>, T, "findMany"> | Null>
    movieCinemaOverrides<T extends Cinema$movieCinemaOverridesArgs<ExtArgs> = {}>(args?: Subset<T, Cinema$movieCinemaOverridesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MovieCinemaOverridePayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Cinema model
   */ 
  interface CinemaFieldRefs {
    readonly id: FieldRef<"Cinema", 'String'>
    readonly name: FieldRef<"Cinema", 'String'>
    readonly description: FieldRef<"Cinema", 'String'>
    readonly cityId: FieldRef<"Cinema", 'String'>
    readonly address: FieldRef<"Cinema", 'String'>
    readonly rating: FieldRef<"Cinema", 'Int'>
    readonly phone: FieldRef<"Cinema", 'Json'>
    readonly posterImages: FieldRef<"Cinema", 'Json'>
    readonly geoLatitude: FieldRef<"Cinema", 'Decimal'>
    readonly geoLongitude: FieldRef<"Cinema", 'Decimal'>
  }
    

  // Custom InputTypes
  /**
   * Cinema findUnique
   */
  export type CinemaFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cinema
     */
    select?: CinemaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CinemaInclude<ExtArgs> | null
    /**
     * Filter, which Cinema to fetch.
     */
    where: CinemaWhereUniqueInput
  }

  /**
   * Cinema findUniqueOrThrow
   */
  export type CinemaFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cinema
     */
    select?: CinemaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CinemaInclude<ExtArgs> | null
    /**
     * Filter, which Cinema to fetch.
     */
    where: CinemaWhereUniqueInput
  }

  /**
   * Cinema findFirst
   */
  export type CinemaFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cinema
     */
    select?: CinemaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CinemaInclude<ExtArgs> | null
    /**
     * Filter, which Cinema to fetch.
     */
    where?: CinemaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Cinemas to fetch.
     */
    orderBy?: CinemaOrderByWithRelationInput | CinemaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Cinemas.
     */
    cursor?: CinemaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Cinemas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Cinemas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Cinemas.
     */
    distinct?: CinemaScalarFieldEnum | CinemaScalarFieldEnum[]
  }

  /**
   * Cinema findFirstOrThrow
   */
  export type CinemaFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cinema
     */
    select?: CinemaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CinemaInclude<ExtArgs> | null
    /**
     * Filter, which Cinema to fetch.
     */
    where?: CinemaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Cinemas to fetch.
     */
    orderBy?: CinemaOrderByWithRelationInput | CinemaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Cinemas.
     */
    cursor?: CinemaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Cinemas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Cinemas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Cinemas.
     */
    distinct?: CinemaScalarFieldEnum | CinemaScalarFieldEnum[]
  }

  /**
   * Cinema findMany
   */
  export type CinemaFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cinema
     */
    select?: CinemaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CinemaInclude<ExtArgs> | null
    /**
     * Filter, which Cinemas to fetch.
     */
    where?: CinemaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Cinemas to fetch.
     */
    orderBy?: CinemaOrderByWithRelationInput | CinemaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Cinemas.
     */
    cursor?: CinemaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Cinemas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Cinemas.
     */
    skip?: number
    distinct?: CinemaScalarFieldEnum | CinemaScalarFieldEnum[]
  }

  /**
   * Cinema create
   */
  export type CinemaCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cinema
     */
    select?: CinemaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CinemaInclude<ExtArgs> | null
    /**
     * The data needed to create a Cinema.
     */
    data: XOR<CinemaCreateInput, CinemaUncheckedCreateInput>
  }

  /**
   * Cinema createMany
   */
  export type CinemaCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Cinemas.
     */
    data: CinemaCreateManyInput | CinemaCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Cinema createManyAndReturn
   */
  export type CinemaCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cinema
     */
    select?: CinemaSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Cinemas.
     */
    data: CinemaCreateManyInput | CinemaCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CinemaIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Cinema update
   */
  export type CinemaUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cinema
     */
    select?: CinemaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CinemaInclude<ExtArgs> | null
    /**
     * The data needed to update a Cinema.
     */
    data: XOR<CinemaUpdateInput, CinemaUncheckedUpdateInput>
    /**
     * Choose, which Cinema to update.
     */
    where: CinemaWhereUniqueInput
  }

  /**
   * Cinema updateMany
   */
  export type CinemaUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Cinemas.
     */
    data: XOR<CinemaUpdateManyMutationInput, CinemaUncheckedUpdateManyInput>
    /**
     * Filter which Cinemas to update
     */
    where?: CinemaWhereInput
  }

  /**
   * Cinema upsert
   */
  export type CinemaUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cinema
     */
    select?: CinemaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CinemaInclude<ExtArgs> | null
    /**
     * The filter to search for the Cinema to update in case it exists.
     */
    where: CinemaWhereUniqueInput
    /**
     * In case the Cinema found by the `where` argument doesn't exist, create a new Cinema with this data.
     */
    create: XOR<CinemaCreateInput, CinemaUncheckedCreateInput>
    /**
     * In case the Cinema was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CinemaUpdateInput, CinemaUncheckedUpdateInput>
  }

  /**
   * Cinema delete
   */
  export type CinemaDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cinema
     */
    select?: CinemaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CinemaInclude<ExtArgs> | null
    /**
     * Filter which Cinema to delete.
     */
    where: CinemaWhereUniqueInput
  }

  /**
   * Cinema deleteMany
   */
  export type CinemaDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Cinemas to delete
     */
    where?: CinemaWhereInput
  }

  /**
   * Cinema.cinemaTheaters
   */
  export type Cinema$cinemaTheatersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CinemaTheater
     */
    select?: CinemaTheaterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CinemaTheaterInclude<ExtArgs> | null
    where?: CinemaTheaterWhereInput
    orderBy?: CinemaTheaterOrderByWithRelationInput | CinemaTheaterOrderByWithRelationInput[]
    cursor?: CinemaTheaterWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CinemaTheaterScalarFieldEnum | CinemaTheaterScalarFieldEnum[]
  }

  /**
   * Cinema.movieCinemaOverrides
   */
  export type Cinema$movieCinemaOverridesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MovieCinemaOverride
     */
    select?: MovieCinemaOverrideSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MovieCinemaOverrideInclude<ExtArgs> | null
    where?: MovieCinemaOverrideWhereInput
    orderBy?: MovieCinemaOverrideOrderByWithRelationInput | MovieCinemaOverrideOrderByWithRelationInput[]
    cursor?: MovieCinemaOverrideWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MovieCinemaOverrideScalarFieldEnum | MovieCinemaOverrideScalarFieldEnum[]
  }

  /**
   * Cinema without action
   */
  export type CinemaDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cinema
     */
    select?: CinemaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CinemaInclude<ExtArgs> | null
  }


  /**
   * Model CinemaTheater
   */

  export type AggregateCinemaTheater = {
    _count: CinemaTheaterCountAggregateOutputType | null
    _min: CinemaTheaterMinAggregateOutputType | null
    _max: CinemaTheaterMaxAggregateOutputType | null
  }

  export type CinemaTheaterMinAggregateOutputType = {
    id: string | null
    name: string | null
    cinemaId: string | null
    supports3D: boolean | null
  }

  export type CinemaTheaterMaxAggregateOutputType = {
    id: string | null
    name: string | null
    cinemaId: string | null
    supports3D: boolean | null
  }

  export type CinemaTheaterCountAggregateOutputType = {
    id: number
    name: number
    cinemaId: number
    supports3D: number
    posterImages: number
    _all: number
  }


  export type CinemaTheaterMinAggregateInputType = {
    id?: true
    name?: true
    cinemaId?: true
    supports3D?: true
  }

  export type CinemaTheaterMaxAggregateInputType = {
    id?: true
    name?: true
    cinemaId?: true
    supports3D?: true
  }

  export type CinemaTheaterCountAggregateInputType = {
    id?: true
    name?: true
    cinemaId?: true
    supports3D?: true
    posterImages?: true
    _all?: true
  }

  export type CinemaTheaterAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CinemaTheater to aggregate.
     */
    where?: CinemaTheaterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CinemaTheaters to fetch.
     */
    orderBy?: CinemaTheaterOrderByWithRelationInput | CinemaTheaterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CinemaTheaterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CinemaTheaters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CinemaTheaters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CinemaTheaters
    **/
    _count?: true | CinemaTheaterCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CinemaTheaterMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CinemaTheaterMaxAggregateInputType
  }

  export type GetCinemaTheaterAggregateType<T extends CinemaTheaterAggregateArgs> = {
        [P in keyof T & keyof AggregateCinemaTheater]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCinemaTheater[P]>
      : GetScalarType<T[P], AggregateCinemaTheater[P]>
  }




  export type CinemaTheaterGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CinemaTheaterWhereInput
    orderBy?: CinemaTheaterOrderByWithAggregationInput | CinemaTheaterOrderByWithAggregationInput[]
    by: CinemaTheaterScalarFieldEnum[] | CinemaTheaterScalarFieldEnum
    having?: CinemaTheaterScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CinemaTheaterCountAggregateInputType | true
    _min?: CinemaTheaterMinAggregateInputType
    _max?: CinemaTheaterMaxAggregateInputType
  }

  export type CinemaTheaterGroupByOutputType = {
    id: string
    name: string
    cinemaId: string
    supports3D: boolean
    posterImages: JsonValue
    _count: CinemaTheaterCountAggregateOutputType | null
    _min: CinemaTheaterMinAggregateOutputType | null
    _max: CinemaTheaterMaxAggregateOutputType | null
  }

  type GetCinemaTheaterGroupByPayload<T extends CinemaTheaterGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CinemaTheaterGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CinemaTheaterGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CinemaTheaterGroupByOutputType[P]>
            : GetScalarType<T[P], CinemaTheaterGroupByOutputType[P]>
        }
      >
    >


  export type CinemaTheaterSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    cinemaId?: boolean
    supports3D?: boolean
    posterImages?: boolean
    cinema?: boolean | CinemaDefaultArgs<ExtArgs>
    cinemaSeatGroups?: boolean | CinemaTheater$cinemaSeatGroupsArgs<ExtArgs>
    movieProjections?: boolean | CinemaTheater$movieProjectionsArgs<ExtArgs>
    _count?: boolean | CinemaTheaterCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["cinemaTheater"]>

  export type CinemaTheaterSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    cinemaId?: boolean
    supports3D?: boolean
    posterImages?: boolean
    cinema?: boolean | CinemaDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["cinemaTheater"]>

  export type CinemaTheaterSelectScalar = {
    id?: boolean
    name?: boolean
    cinemaId?: boolean
    supports3D?: boolean
    posterImages?: boolean
  }

  export type CinemaTheaterInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    cinema?: boolean | CinemaDefaultArgs<ExtArgs>
    cinemaSeatGroups?: boolean | CinemaTheater$cinemaSeatGroupsArgs<ExtArgs>
    movieProjections?: boolean | CinemaTheater$movieProjectionsArgs<ExtArgs>
    _count?: boolean | CinemaTheaterCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CinemaTheaterIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    cinema?: boolean | CinemaDefaultArgs<ExtArgs>
  }

  export type $CinemaTheaterPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CinemaTheater"
    objects: {
      cinema: Prisma.$CinemaPayload<ExtArgs>
      cinemaSeatGroups: Prisma.$CinemaSeatGroupPayload<ExtArgs>[]
      movieProjections: Prisma.$MovieProjectionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      cinemaId: string
      supports3D: boolean
      posterImages: Prisma.JsonValue
    }, ExtArgs["result"]["cinemaTheater"]>
    composites: {}
  }

  type CinemaTheaterGetPayload<S extends boolean | null | undefined | CinemaTheaterDefaultArgs> = $Result.GetResult<Prisma.$CinemaTheaterPayload, S>

  type CinemaTheaterCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CinemaTheaterFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CinemaTheaterCountAggregateInputType | true
    }

  export interface CinemaTheaterDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CinemaTheater'], meta: { name: 'CinemaTheater' } }
    /**
     * Find zero or one CinemaTheater that matches the filter.
     * @param {CinemaTheaterFindUniqueArgs} args - Arguments to find a CinemaTheater
     * @example
     * // Get one CinemaTheater
     * const cinemaTheater = await prisma.cinemaTheater.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CinemaTheaterFindUniqueArgs>(args: SelectSubset<T, CinemaTheaterFindUniqueArgs<ExtArgs>>): Prisma__CinemaTheaterClient<$Result.GetResult<Prisma.$CinemaTheaterPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one CinemaTheater that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {CinemaTheaterFindUniqueOrThrowArgs} args - Arguments to find a CinemaTheater
     * @example
     * // Get one CinemaTheater
     * const cinemaTheater = await prisma.cinemaTheater.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CinemaTheaterFindUniqueOrThrowArgs>(args: SelectSubset<T, CinemaTheaterFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CinemaTheaterClient<$Result.GetResult<Prisma.$CinemaTheaterPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first CinemaTheater that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CinemaTheaterFindFirstArgs} args - Arguments to find a CinemaTheater
     * @example
     * // Get one CinemaTheater
     * const cinemaTheater = await prisma.cinemaTheater.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CinemaTheaterFindFirstArgs>(args?: SelectSubset<T, CinemaTheaterFindFirstArgs<ExtArgs>>): Prisma__CinemaTheaterClient<$Result.GetResult<Prisma.$CinemaTheaterPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first CinemaTheater that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CinemaTheaterFindFirstOrThrowArgs} args - Arguments to find a CinemaTheater
     * @example
     * // Get one CinemaTheater
     * const cinemaTheater = await prisma.cinemaTheater.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CinemaTheaterFindFirstOrThrowArgs>(args?: SelectSubset<T, CinemaTheaterFindFirstOrThrowArgs<ExtArgs>>): Prisma__CinemaTheaterClient<$Result.GetResult<Prisma.$CinemaTheaterPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more CinemaTheaters that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CinemaTheaterFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CinemaTheaters
     * const cinemaTheaters = await prisma.cinemaTheater.findMany()
     * 
     * // Get first 10 CinemaTheaters
     * const cinemaTheaters = await prisma.cinemaTheater.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const cinemaTheaterWithIdOnly = await prisma.cinemaTheater.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CinemaTheaterFindManyArgs>(args?: SelectSubset<T, CinemaTheaterFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CinemaTheaterPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a CinemaTheater.
     * @param {CinemaTheaterCreateArgs} args - Arguments to create a CinemaTheater.
     * @example
     * // Create one CinemaTheater
     * const CinemaTheater = await prisma.cinemaTheater.create({
     *   data: {
     *     // ... data to create a CinemaTheater
     *   }
     * })
     * 
     */
    create<T extends CinemaTheaterCreateArgs>(args: SelectSubset<T, CinemaTheaterCreateArgs<ExtArgs>>): Prisma__CinemaTheaterClient<$Result.GetResult<Prisma.$CinemaTheaterPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many CinemaTheaters.
     * @param {CinemaTheaterCreateManyArgs} args - Arguments to create many CinemaTheaters.
     * @example
     * // Create many CinemaTheaters
     * const cinemaTheater = await prisma.cinemaTheater.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CinemaTheaterCreateManyArgs>(args?: SelectSubset<T, CinemaTheaterCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CinemaTheaters and returns the data saved in the database.
     * @param {CinemaTheaterCreateManyAndReturnArgs} args - Arguments to create many CinemaTheaters.
     * @example
     * // Create many CinemaTheaters
     * const cinemaTheater = await prisma.cinemaTheater.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CinemaTheaters and only return the `id`
     * const cinemaTheaterWithIdOnly = await prisma.cinemaTheater.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CinemaTheaterCreateManyAndReturnArgs>(args?: SelectSubset<T, CinemaTheaterCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CinemaTheaterPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a CinemaTheater.
     * @param {CinemaTheaterDeleteArgs} args - Arguments to delete one CinemaTheater.
     * @example
     * // Delete one CinemaTheater
     * const CinemaTheater = await prisma.cinemaTheater.delete({
     *   where: {
     *     // ... filter to delete one CinemaTheater
     *   }
     * })
     * 
     */
    delete<T extends CinemaTheaterDeleteArgs>(args: SelectSubset<T, CinemaTheaterDeleteArgs<ExtArgs>>): Prisma__CinemaTheaterClient<$Result.GetResult<Prisma.$CinemaTheaterPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one CinemaTheater.
     * @param {CinemaTheaterUpdateArgs} args - Arguments to update one CinemaTheater.
     * @example
     * // Update one CinemaTheater
     * const cinemaTheater = await prisma.cinemaTheater.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CinemaTheaterUpdateArgs>(args: SelectSubset<T, CinemaTheaterUpdateArgs<ExtArgs>>): Prisma__CinemaTheaterClient<$Result.GetResult<Prisma.$CinemaTheaterPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more CinemaTheaters.
     * @param {CinemaTheaterDeleteManyArgs} args - Arguments to filter CinemaTheaters to delete.
     * @example
     * // Delete a few CinemaTheaters
     * const { count } = await prisma.cinemaTheater.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CinemaTheaterDeleteManyArgs>(args?: SelectSubset<T, CinemaTheaterDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CinemaTheaters.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CinemaTheaterUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CinemaTheaters
     * const cinemaTheater = await prisma.cinemaTheater.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CinemaTheaterUpdateManyArgs>(args: SelectSubset<T, CinemaTheaterUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one CinemaTheater.
     * @param {CinemaTheaterUpsertArgs} args - Arguments to update or create a CinemaTheater.
     * @example
     * // Update or create a CinemaTheater
     * const cinemaTheater = await prisma.cinemaTheater.upsert({
     *   create: {
     *     // ... data to create a CinemaTheater
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CinemaTheater we want to update
     *   }
     * })
     */
    upsert<T extends CinemaTheaterUpsertArgs>(args: SelectSubset<T, CinemaTheaterUpsertArgs<ExtArgs>>): Prisma__CinemaTheaterClient<$Result.GetResult<Prisma.$CinemaTheaterPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of CinemaTheaters.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CinemaTheaterCountArgs} args - Arguments to filter CinemaTheaters to count.
     * @example
     * // Count the number of CinemaTheaters
     * const count = await prisma.cinemaTheater.count({
     *   where: {
     *     // ... the filter for the CinemaTheaters we want to count
     *   }
     * })
    **/
    count<T extends CinemaTheaterCountArgs>(
      args?: Subset<T, CinemaTheaterCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CinemaTheaterCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CinemaTheater.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CinemaTheaterAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CinemaTheaterAggregateArgs>(args: Subset<T, CinemaTheaterAggregateArgs>): Prisma.PrismaPromise<GetCinemaTheaterAggregateType<T>>

    /**
     * Group by CinemaTheater.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CinemaTheaterGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CinemaTheaterGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CinemaTheaterGroupByArgs['orderBy'] }
        : { orderBy?: CinemaTheaterGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CinemaTheaterGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCinemaTheaterGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CinemaTheater model
   */
  readonly fields: CinemaTheaterFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CinemaTheater.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CinemaTheaterClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    cinema<T extends CinemaDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CinemaDefaultArgs<ExtArgs>>): Prisma__CinemaClient<$Result.GetResult<Prisma.$CinemaPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    cinemaSeatGroups<T extends CinemaTheater$cinemaSeatGroupsArgs<ExtArgs> = {}>(args?: Subset<T, CinemaTheater$cinemaSeatGroupsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CinemaSeatGroupPayload<ExtArgs>, T, "findMany"> | Null>
    movieProjections<T extends CinemaTheater$movieProjectionsArgs<ExtArgs> = {}>(args?: Subset<T, CinemaTheater$movieProjectionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MovieProjectionPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CinemaTheater model
   */ 
  interface CinemaTheaterFieldRefs {
    readonly id: FieldRef<"CinemaTheater", 'String'>
    readonly name: FieldRef<"CinemaTheater", 'String'>
    readonly cinemaId: FieldRef<"CinemaTheater", 'String'>
    readonly supports3D: FieldRef<"CinemaTheater", 'Boolean'>
    readonly posterImages: FieldRef<"CinemaTheater", 'Json'>
  }
    

  // Custom InputTypes
  /**
   * CinemaTheater findUnique
   */
  export type CinemaTheaterFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CinemaTheater
     */
    select?: CinemaTheaterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CinemaTheaterInclude<ExtArgs> | null
    /**
     * Filter, which CinemaTheater to fetch.
     */
    where: CinemaTheaterWhereUniqueInput
  }

  /**
   * CinemaTheater findUniqueOrThrow
   */
  export type CinemaTheaterFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CinemaTheater
     */
    select?: CinemaTheaterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CinemaTheaterInclude<ExtArgs> | null
    /**
     * Filter, which CinemaTheater to fetch.
     */
    where: CinemaTheaterWhereUniqueInput
  }

  /**
   * CinemaTheater findFirst
   */
  export type CinemaTheaterFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CinemaTheater
     */
    select?: CinemaTheaterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CinemaTheaterInclude<ExtArgs> | null
    /**
     * Filter, which CinemaTheater to fetch.
     */
    where?: CinemaTheaterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CinemaTheaters to fetch.
     */
    orderBy?: CinemaTheaterOrderByWithRelationInput | CinemaTheaterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CinemaTheaters.
     */
    cursor?: CinemaTheaterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CinemaTheaters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CinemaTheaters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CinemaTheaters.
     */
    distinct?: CinemaTheaterScalarFieldEnum | CinemaTheaterScalarFieldEnum[]
  }

  /**
   * CinemaTheater findFirstOrThrow
   */
  export type CinemaTheaterFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CinemaTheater
     */
    select?: CinemaTheaterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CinemaTheaterInclude<ExtArgs> | null
    /**
     * Filter, which CinemaTheater to fetch.
     */
    where?: CinemaTheaterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CinemaTheaters to fetch.
     */
    orderBy?: CinemaTheaterOrderByWithRelationInput | CinemaTheaterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CinemaTheaters.
     */
    cursor?: CinemaTheaterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CinemaTheaters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CinemaTheaters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CinemaTheaters.
     */
    distinct?: CinemaTheaterScalarFieldEnum | CinemaTheaterScalarFieldEnum[]
  }

  /**
   * CinemaTheater findMany
   */
  export type CinemaTheaterFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CinemaTheater
     */
    select?: CinemaTheaterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CinemaTheaterInclude<ExtArgs> | null
    /**
     * Filter, which CinemaTheaters to fetch.
     */
    where?: CinemaTheaterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CinemaTheaters to fetch.
     */
    orderBy?: CinemaTheaterOrderByWithRelationInput | CinemaTheaterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CinemaTheaters.
     */
    cursor?: CinemaTheaterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CinemaTheaters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CinemaTheaters.
     */
    skip?: number
    distinct?: CinemaTheaterScalarFieldEnum | CinemaTheaterScalarFieldEnum[]
  }

  /**
   * CinemaTheater create
   */
  export type CinemaTheaterCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CinemaTheater
     */
    select?: CinemaTheaterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CinemaTheaterInclude<ExtArgs> | null
    /**
     * The data needed to create a CinemaTheater.
     */
    data: XOR<CinemaTheaterCreateInput, CinemaTheaterUncheckedCreateInput>
  }

  /**
   * CinemaTheater createMany
   */
  export type CinemaTheaterCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CinemaTheaters.
     */
    data: CinemaTheaterCreateManyInput | CinemaTheaterCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CinemaTheater createManyAndReturn
   */
  export type CinemaTheaterCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CinemaTheater
     */
    select?: CinemaTheaterSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many CinemaTheaters.
     */
    data: CinemaTheaterCreateManyInput | CinemaTheaterCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CinemaTheaterIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CinemaTheater update
   */
  export type CinemaTheaterUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CinemaTheater
     */
    select?: CinemaTheaterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CinemaTheaterInclude<ExtArgs> | null
    /**
     * The data needed to update a CinemaTheater.
     */
    data: XOR<CinemaTheaterUpdateInput, CinemaTheaterUncheckedUpdateInput>
    /**
     * Choose, which CinemaTheater to update.
     */
    where: CinemaTheaterWhereUniqueInput
  }

  /**
   * CinemaTheater updateMany
   */
  export type CinemaTheaterUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CinemaTheaters.
     */
    data: XOR<CinemaTheaterUpdateManyMutationInput, CinemaTheaterUncheckedUpdateManyInput>
    /**
     * Filter which CinemaTheaters to update
     */
    where?: CinemaTheaterWhereInput
  }

  /**
   * CinemaTheater upsert
   */
  export type CinemaTheaterUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CinemaTheater
     */
    select?: CinemaTheaterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CinemaTheaterInclude<ExtArgs> | null
    /**
     * The filter to search for the CinemaTheater to update in case it exists.
     */
    where: CinemaTheaterWhereUniqueInput
    /**
     * In case the CinemaTheater found by the `where` argument doesn't exist, create a new CinemaTheater with this data.
     */
    create: XOR<CinemaTheaterCreateInput, CinemaTheaterUncheckedCreateInput>
    /**
     * In case the CinemaTheater was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CinemaTheaterUpdateInput, CinemaTheaterUncheckedUpdateInput>
  }

  /**
   * CinemaTheater delete
   */
  export type CinemaTheaterDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CinemaTheater
     */
    select?: CinemaTheaterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CinemaTheaterInclude<ExtArgs> | null
    /**
     * Filter which CinemaTheater to delete.
     */
    where: CinemaTheaterWhereUniqueInput
  }

  /**
   * CinemaTheater deleteMany
   */
  export type CinemaTheaterDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CinemaTheaters to delete
     */
    where?: CinemaTheaterWhereInput
  }

  /**
   * CinemaTheater.cinemaSeatGroups
   */
  export type CinemaTheater$cinemaSeatGroupsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CinemaSeatGroup
     */
    select?: CinemaSeatGroupSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CinemaSeatGroupInclude<ExtArgs> | null
    where?: CinemaSeatGroupWhereInput
    orderBy?: CinemaSeatGroupOrderByWithRelationInput | CinemaSeatGroupOrderByWithRelationInput[]
    cursor?: CinemaSeatGroupWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CinemaSeatGroupScalarFieldEnum | CinemaSeatGroupScalarFieldEnum[]
  }

  /**
   * CinemaTheater.movieProjections
   */
  export type CinemaTheater$movieProjectionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MovieProjection
     */
    select?: MovieProjectionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MovieProjectionInclude<ExtArgs> | null
    where?: MovieProjectionWhereInput
    orderBy?: MovieProjectionOrderByWithRelationInput | MovieProjectionOrderByWithRelationInput[]
    cursor?: MovieProjectionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MovieProjectionScalarFieldEnum | MovieProjectionScalarFieldEnum[]
  }

  /**
   * CinemaTheater without action
   */
  export type CinemaTheaterDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CinemaTheater
     */
    select?: CinemaTheaterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CinemaTheaterInclude<ExtArgs> | null
  }


  /**
   * Model CinemaSeatGroup
   */

  export type AggregateCinemaSeatGroup = {
    _count: CinemaSeatGroupCountAggregateOutputType | null
    _avg: CinemaSeatGroupAvgAggregateOutputType | null
    _sum: CinemaSeatGroupSumAggregateOutputType | null
    _min: CinemaSeatGroupMinAggregateOutputType | null
    _max: CinemaSeatGroupMaxAggregateOutputType | null
  }

  export type CinemaSeatGroupAvgAggregateOutputType = {
    rowCount: number | null
    columnCount: number | null
  }

  export type CinemaSeatGroupSumAggregateOutputType = {
    rowCount: number | null
    columnCount: number | null
  }

  export type CinemaSeatGroupMinAggregateOutputType = {
    id: string | null
    cinemaTheaterId: string | null
    name: string | null
    rowCount: number | null
    columnCount: number | null
    position: $Enums.CinemaSeatGroupPositionEnum | null
  }

  export type CinemaSeatGroupMaxAggregateOutputType = {
    id: string | null
    cinemaTheaterId: string | null
    name: string | null
    rowCount: number | null
    columnCount: number | null
    position: $Enums.CinemaSeatGroupPositionEnum | null
  }

  export type CinemaSeatGroupCountAggregateOutputType = {
    id: number
    cinemaTheaterId: number
    name: number
    rowCount: number
    columnCount: number
    position: number
    options: number
    _all: number
  }


  export type CinemaSeatGroupAvgAggregateInputType = {
    rowCount?: true
    columnCount?: true
  }

  export type CinemaSeatGroupSumAggregateInputType = {
    rowCount?: true
    columnCount?: true
  }

  export type CinemaSeatGroupMinAggregateInputType = {
    id?: true
    cinemaTheaterId?: true
    name?: true
    rowCount?: true
    columnCount?: true
    position?: true
  }

  export type CinemaSeatGroupMaxAggregateInputType = {
    id?: true
    cinemaTheaterId?: true
    name?: true
    rowCount?: true
    columnCount?: true
    position?: true
  }

  export type CinemaSeatGroupCountAggregateInputType = {
    id?: true
    cinemaTheaterId?: true
    name?: true
    rowCount?: true
    columnCount?: true
    position?: true
    options?: true
    _all?: true
  }

  export type CinemaSeatGroupAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CinemaSeatGroup to aggregate.
     */
    where?: CinemaSeatGroupWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CinemaSeatGroups to fetch.
     */
    orderBy?: CinemaSeatGroupOrderByWithRelationInput | CinemaSeatGroupOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CinemaSeatGroupWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CinemaSeatGroups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CinemaSeatGroups.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CinemaSeatGroups
    **/
    _count?: true | CinemaSeatGroupCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CinemaSeatGroupAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CinemaSeatGroupSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CinemaSeatGroupMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CinemaSeatGroupMaxAggregateInputType
  }

  export type GetCinemaSeatGroupAggregateType<T extends CinemaSeatGroupAggregateArgs> = {
        [P in keyof T & keyof AggregateCinemaSeatGroup]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCinemaSeatGroup[P]>
      : GetScalarType<T[P], AggregateCinemaSeatGroup[P]>
  }




  export type CinemaSeatGroupGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CinemaSeatGroupWhereInput
    orderBy?: CinemaSeatGroupOrderByWithAggregationInput | CinemaSeatGroupOrderByWithAggregationInput[]
    by: CinemaSeatGroupScalarFieldEnum[] | CinemaSeatGroupScalarFieldEnum
    having?: CinemaSeatGroupScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CinemaSeatGroupCountAggregateInputType | true
    _avg?: CinemaSeatGroupAvgAggregateInputType
    _sum?: CinemaSeatGroupSumAggregateInputType
    _min?: CinemaSeatGroupMinAggregateInputType
    _max?: CinemaSeatGroupMaxAggregateInputType
  }

  export type CinemaSeatGroupGroupByOutputType = {
    id: string
    cinemaTheaterId: string
    name: string
    rowCount: number
    columnCount: number
    position: $Enums.CinemaSeatGroupPositionEnum
    options: JsonValue
    _count: CinemaSeatGroupCountAggregateOutputType | null
    _avg: CinemaSeatGroupAvgAggregateOutputType | null
    _sum: CinemaSeatGroupSumAggregateOutputType | null
    _min: CinemaSeatGroupMinAggregateOutputType | null
    _max: CinemaSeatGroupMaxAggregateOutputType | null
  }

  type GetCinemaSeatGroupGroupByPayload<T extends CinemaSeatGroupGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CinemaSeatGroupGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CinemaSeatGroupGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CinemaSeatGroupGroupByOutputType[P]>
            : GetScalarType<T[P], CinemaSeatGroupGroupByOutputType[P]>
        }
      >
    >


  export type CinemaSeatGroupSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    cinemaTheaterId?: boolean
    name?: boolean
    rowCount?: boolean
    columnCount?: boolean
    position?: boolean
    options?: boolean
    cinemaTheater?: boolean | CinemaTheaterDefaultArgs<ExtArgs>
    cinemaSeats?: boolean | CinemaSeatGroup$cinemaSeatsArgs<ExtArgs>
    projectionPrices?: boolean | CinemaSeatGroup$projectionPricesArgs<ExtArgs>
    _count?: boolean | CinemaSeatGroupCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["cinemaSeatGroup"]>

  export type CinemaSeatGroupSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    cinemaTheaterId?: boolean
    name?: boolean
    rowCount?: boolean
    columnCount?: boolean
    position?: boolean
    options?: boolean
    cinemaTheater?: boolean | CinemaTheaterDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["cinemaSeatGroup"]>

  export type CinemaSeatGroupSelectScalar = {
    id?: boolean
    cinemaTheaterId?: boolean
    name?: boolean
    rowCount?: boolean
    columnCount?: boolean
    position?: boolean
    options?: boolean
  }

  export type CinemaSeatGroupInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    cinemaTheater?: boolean | CinemaTheaterDefaultArgs<ExtArgs>
    cinemaSeats?: boolean | CinemaSeatGroup$cinemaSeatsArgs<ExtArgs>
    projectionPrices?: boolean | CinemaSeatGroup$projectionPricesArgs<ExtArgs>
    _count?: boolean | CinemaSeatGroupCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CinemaSeatGroupIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    cinemaTheater?: boolean | CinemaTheaterDefaultArgs<ExtArgs>
  }

  export type $CinemaSeatGroupPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CinemaSeatGroup"
    objects: {
      cinemaTheater: Prisma.$CinemaTheaterPayload<ExtArgs>
      cinemaSeats: Prisma.$CinemaSeatPayload<ExtArgs>[]
      projectionPrices: Prisma.$ProjectionPricePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      cinemaTheaterId: string
      name: string
      rowCount: number
      columnCount: number
      position: $Enums.CinemaSeatGroupPositionEnum
      options: Prisma.JsonValue
    }, ExtArgs["result"]["cinemaSeatGroup"]>
    composites: {}
  }

  type CinemaSeatGroupGetPayload<S extends boolean | null | undefined | CinemaSeatGroupDefaultArgs> = $Result.GetResult<Prisma.$CinemaSeatGroupPayload, S>

  type CinemaSeatGroupCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CinemaSeatGroupFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CinemaSeatGroupCountAggregateInputType | true
    }

  export interface CinemaSeatGroupDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CinemaSeatGroup'], meta: { name: 'CinemaSeatGroup' } }
    /**
     * Find zero or one CinemaSeatGroup that matches the filter.
     * @param {CinemaSeatGroupFindUniqueArgs} args - Arguments to find a CinemaSeatGroup
     * @example
     * // Get one CinemaSeatGroup
     * const cinemaSeatGroup = await prisma.cinemaSeatGroup.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CinemaSeatGroupFindUniqueArgs>(args: SelectSubset<T, CinemaSeatGroupFindUniqueArgs<ExtArgs>>): Prisma__CinemaSeatGroupClient<$Result.GetResult<Prisma.$CinemaSeatGroupPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one CinemaSeatGroup that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {CinemaSeatGroupFindUniqueOrThrowArgs} args - Arguments to find a CinemaSeatGroup
     * @example
     * // Get one CinemaSeatGroup
     * const cinemaSeatGroup = await prisma.cinemaSeatGroup.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CinemaSeatGroupFindUniqueOrThrowArgs>(args: SelectSubset<T, CinemaSeatGroupFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CinemaSeatGroupClient<$Result.GetResult<Prisma.$CinemaSeatGroupPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first CinemaSeatGroup that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CinemaSeatGroupFindFirstArgs} args - Arguments to find a CinemaSeatGroup
     * @example
     * // Get one CinemaSeatGroup
     * const cinemaSeatGroup = await prisma.cinemaSeatGroup.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CinemaSeatGroupFindFirstArgs>(args?: SelectSubset<T, CinemaSeatGroupFindFirstArgs<ExtArgs>>): Prisma__CinemaSeatGroupClient<$Result.GetResult<Prisma.$CinemaSeatGroupPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first CinemaSeatGroup that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CinemaSeatGroupFindFirstOrThrowArgs} args - Arguments to find a CinemaSeatGroup
     * @example
     * // Get one CinemaSeatGroup
     * const cinemaSeatGroup = await prisma.cinemaSeatGroup.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CinemaSeatGroupFindFirstOrThrowArgs>(args?: SelectSubset<T, CinemaSeatGroupFindFirstOrThrowArgs<ExtArgs>>): Prisma__CinemaSeatGroupClient<$Result.GetResult<Prisma.$CinemaSeatGroupPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more CinemaSeatGroups that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CinemaSeatGroupFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CinemaSeatGroups
     * const cinemaSeatGroups = await prisma.cinemaSeatGroup.findMany()
     * 
     * // Get first 10 CinemaSeatGroups
     * const cinemaSeatGroups = await prisma.cinemaSeatGroup.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const cinemaSeatGroupWithIdOnly = await prisma.cinemaSeatGroup.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CinemaSeatGroupFindManyArgs>(args?: SelectSubset<T, CinemaSeatGroupFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CinemaSeatGroupPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a CinemaSeatGroup.
     * @param {CinemaSeatGroupCreateArgs} args - Arguments to create a CinemaSeatGroup.
     * @example
     * // Create one CinemaSeatGroup
     * const CinemaSeatGroup = await prisma.cinemaSeatGroup.create({
     *   data: {
     *     // ... data to create a CinemaSeatGroup
     *   }
     * })
     * 
     */
    create<T extends CinemaSeatGroupCreateArgs>(args: SelectSubset<T, CinemaSeatGroupCreateArgs<ExtArgs>>): Prisma__CinemaSeatGroupClient<$Result.GetResult<Prisma.$CinemaSeatGroupPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many CinemaSeatGroups.
     * @param {CinemaSeatGroupCreateManyArgs} args - Arguments to create many CinemaSeatGroups.
     * @example
     * // Create many CinemaSeatGroups
     * const cinemaSeatGroup = await prisma.cinemaSeatGroup.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CinemaSeatGroupCreateManyArgs>(args?: SelectSubset<T, CinemaSeatGroupCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CinemaSeatGroups and returns the data saved in the database.
     * @param {CinemaSeatGroupCreateManyAndReturnArgs} args - Arguments to create many CinemaSeatGroups.
     * @example
     * // Create many CinemaSeatGroups
     * const cinemaSeatGroup = await prisma.cinemaSeatGroup.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CinemaSeatGroups and only return the `id`
     * const cinemaSeatGroupWithIdOnly = await prisma.cinemaSeatGroup.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CinemaSeatGroupCreateManyAndReturnArgs>(args?: SelectSubset<T, CinemaSeatGroupCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CinemaSeatGroupPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a CinemaSeatGroup.
     * @param {CinemaSeatGroupDeleteArgs} args - Arguments to delete one CinemaSeatGroup.
     * @example
     * // Delete one CinemaSeatGroup
     * const CinemaSeatGroup = await prisma.cinemaSeatGroup.delete({
     *   where: {
     *     // ... filter to delete one CinemaSeatGroup
     *   }
     * })
     * 
     */
    delete<T extends CinemaSeatGroupDeleteArgs>(args: SelectSubset<T, CinemaSeatGroupDeleteArgs<ExtArgs>>): Prisma__CinemaSeatGroupClient<$Result.GetResult<Prisma.$CinemaSeatGroupPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one CinemaSeatGroup.
     * @param {CinemaSeatGroupUpdateArgs} args - Arguments to update one CinemaSeatGroup.
     * @example
     * // Update one CinemaSeatGroup
     * const cinemaSeatGroup = await prisma.cinemaSeatGroup.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CinemaSeatGroupUpdateArgs>(args: SelectSubset<T, CinemaSeatGroupUpdateArgs<ExtArgs>>): Prisma__CinemaSeatGroupClient<$Result.GetResult<Prisma.$CinemaSeatGroupPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more CinemaSeatGroups.
     * @param {CinemaSeatGroupDeleteManyArgs} args - Arguments to filter CinemaSeatGroups to delete.
     * @example
     * // Delete a few CinemaSeatGroups
     * const { count } = await prisma.cinemaSeatGroup.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CinemaSeatGroupDeleteManyArgs>(args?: SelectSubset<T, CinemaSeatGroupDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CinemaSeatGroups.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CinemaSeatGroupUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CinemaSeatGroups
     * const cinemaSeatGroup = await prisma.cinemaSeatGroup.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CinemaSeatGroupUpdateManyArgs>(args: SelectSubset<T, CinemaSeatGroupUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one CinemaSeatGroup.
     * @param {CinemaSeatGroupUpsertArgs} args - Arguments to update or create a CinemaSeatGroup.
     * @example
     * // Update or create a CinemaSeatGroup
     * const cinemaSeatGroup = await prisma.cinemaSeatGroup.upsert({
     *   create: {
     *     // ... data to create a CinemaSeatGroup
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CinemaSeatGroup we want to update
     *   }
     * })
     */
    upsert<T extends CinemaSeatGroupUpsertArgs>(args: SelectSubset<T, CinemaSeatGroupUpsertArgs<ExtArgs>>): Prisma__CinemaSeatGroupClient<$Result.GetResult<Prisma.$CinemaSeatGroupPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of CinemaSeatGroups.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CinemaSeatGroupCountArgs} args - Arguments to filter CinemaSeatGroups to count.
     * @example
     * // Count the number of CinemaSeatGroups
     * const count = await prisma.cinemaSeatGroup.count({
     *   where: {
     *     // ... the filter for the CinemaSeatGroups we want to count
     *   }
     * })
    **/
    count<T extends CinemaSeatGroupCountArgs>(
      args?: Subset<T, CinemaSeatGroupCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CinemaSeatGroupCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CinemaSeatGroup.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CinemaSeatGroupAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CinemaSeatGroupAggregateArgs>(args: Subset<T, CinemaSeatGroupAggregateArgs>): Prisma.PrismaPromise<GetCinemaSeatGroupAggregateType<T>>

    /**
     * Group by CinemaSeatGroup.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CinemaSeatGroupGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CinemaSeatGroupGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CinemaSeatGroupGroupByArgs['orderBy'] }
        : { orderBy?: CinemaSeatGroupGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CinemaSeatGroupGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCinemaSeatGroupGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CinemaSeatGroup model
   */
  readonly fields: CinemaSeatGroupFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CinemaSeatGroup.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CinemaSeatGroupClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    cinemaTheater<T extends CinemaTheaterDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CinemaTheaterDefaultArgs<ExtArgs>>): Prisma__CinemaTheaterClient<$Result.GetResult<Prisma.$CinemaTheaterPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    cinemaSeats<T extends CinemaSeatGroup$cinemaSeatsArgs<ExtArgs> = {}>(args?: Subset<T, CinemaSeatGroup$cinemaSeatsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CinemaSeatPayload<ExtArgs>, T, "findMany"> | Null>
    projectionPrices<T extends CinemaSeatGroup$projectionPricesArgs<ExtArgs> = {}>(args?: Subset<T, CinemaSeatGroup$projectionPricesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectionPricePayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CinemaSeatGroup model
   */ 
  interface CinemaSeatGroupFieldRefs {
    readonly id: FieldRef<"CinemaSeatGroup", 'String'>
    readonly cinemaTheaterId: FieldRef<"CinemaSeatGroup", 'String'>
    readonly name: FieldRef<"CinemaSeatGroup", 'String'>
    readonly rowCount: FieldRef<"CinemaSeatGroup", 'Int'>
    readonly columnCount: FieldRef<"CinemaSeatGroup", 'Int'>
    readonly position: FieldRef<"CinemaSeatGroup", 'CinemaSeatGroupPositionEnum'>
    readonly options: FieldRef<"CinemaSeatGroup", 'Json'>
  }
    

  // Custom InputTypes
  /**
   * CinemaSeatGroup findUnique
   */
  export type CinemaSeatGroupFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CinemaSeatGroup
     */
    select?: CinemaSeatGroupSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CinemaSeatGroupInclude<ExtArgs> | null
    /**
     * Filter, which CinemaSeatGroup to fetch.
     */
    where: CinemaSeatGroupWhereUniqueInput
  }

  /**
   * CinemaSeatGroup findUniqueOrThrow
   */
  export type CinemaSeatGroupFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CinemaSeatGroup
     */
    select?: CinemaSeatGroupSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CinemaSeatGroupInclude<ExtArgs> | null
    /**
     * Filter, which CinemaSeatGroup to fetch.
     */
    where: CinemaSeatGroupWhereUniqueInput
  }

  /**
   * CinemaSeatGroup findFirst
   */
  export type CinemaSeatGroupFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CinemaSeatGroup
     */
    select?: CinemaSeatGroupSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CinemaSeatGroupInclude<ExtArgs> | null
    /**
     * Filter, which CinemaSeatGroup to fetch.
     */
    where?: CinemaSeatGroupWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CinemaSeatGroups to fetch.
     */
    orderBy?: CinemaSeatGroupOrderByWithRelationInput | CinemaSeatGroupOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CinemaSeatGroups.
     */
    cursor?: CinemaSeatGroupWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CinemaSeatGroups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CinemaSeatGroups.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CinemaSeatGroups.
     */
    distinct?: CinemaSeatGroupScalarFieldEnum | CinemaSeatGroupScalarFieldEnum[]
  }

  /**
   * CinemaSeatGroup findFirstOrThrow
   */
  export type CinemaSeatGroupFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CinemaSeatGroup
     */
    select?: CinemaSeatGroupSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CinemaSeatGroupInclude<ExtArgs> | null
    /**
     * Filter, which CinemaSeatGroup to fetch.
     */
    where?: CinemaSeatGroupWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CinemaSeatGroups to fetch.
     */
    orderBy?: CinemaSeatGroupOrderByWithRelationInput | CinemaSeatGroupOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CinemaSeatGroups.
     */
    cursor?: CinemaSeatGroupWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CinemaSeatGroups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CinemaSeatGroups.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CinemaSeatGroups.
     */
    distinct?: CinemaSeatGroupScalarFieldEnum | CinemaSeatGroupScalarFieldEnum[]
  }

  /**
   * CinemaSeatGroup findMany
   */
  export type CinemaSeatGroupFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CinemaSeatGroup
     */
    select?: CinemaSeatGroupSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CinemaSeatGroupInclude<ExtArgs> | null
    /**
     * Filter, which CinemaSeatGroups to fetch.
     */
    where?: CinemaSeatGroupWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CinemaSeatGroups to fetch.
     */
    orderBy?: CinemaSeatGroupOrderByWithRelationInput | CinemaSeatGroupOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CinemaSeatGroups.
     */
    cursor?: CinemaSeatGroupWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CinemaSeatGroups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CinemaSeatGroups.
     */
    skip?: number
    distinct?: CinemaSeatGroupScalarFieldEnum | CinemaSeatGroupScalarFieldEnum[]
  }

  /**
   * CinemaSeatGroup create
   */
  export type CinemaSeatGroupCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CinemaSeatGroup
     */
    select?: CinemaSeatGroupSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CinemaSeatGroupInclude<ExtArgs> | null
    /**
     * The data needed to create a CinemaSeatGroup.
     */
    data: XOR<CinemaSeatGroupCreateInput, CinemaSeatGroupUncheckedCreateInput>
  }

  /**
   * CinemaSeatGroup createMany
   */
  export type CinemaSeatGroupCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CinemaSeatGroups.
     */
    data: CinemaSeatGroupCreateManyInput | CinemaSeatGroupCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CinemaSeatGroup createManyAndReturn
   */
  export type CinemaSeatGroupCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CinemaSeatGroup
     */
    select?: CinemaSeatGroupSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many CinemaSeatGroups.
     */
    data: CinemaSeatGroupCreateManyInput | CinemaSeatGroupCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CinemaSeatGroupIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CinemaSeatGroup update
   */
  export type CinemaSeatGroupUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CinemaSeatGroup
     */
    select?: CinemaSeatGroupSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CinemaSeatGroupInclude<ExtArgs> | null
    /**
     * The data needed to update a CinemaSeatGroup.
     */
    data: XOR<CinemaSeatGroupUpdateInput, CinemaSeatGroupUncheckedUpdateInput>
    /**
     * Choose, which CinemaSeatGroup to update.
     */
    where: CinemaSeatGroupWhereUniqueInput
  }

  /**
   * CinemaSeatGroup updateMany
   */
  export type CinemaSeatGroupUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CinemaSeatGroups.
     */
    data: XOR<CinemaSeatGroupUpdateManyMutationInput, CinemaSeatGroupUncheckedUpdateManyInput>
    /**
     * Filter which CinemaSeatGroups to update
     */
    where?: CinemaSeatGroupWhereInput
  }

  /**
   * CinemaSeatGroup upsert
   */
  export type CinemaSeatGroupUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CinemaSeatGroup
     */
    select?: CinemaSeatGroupSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CinemaSeatGroupInclude<ExtArgs> | null
    /**
     * The filter to search for the CinemaSeatGroup to update in case it exists.
     */
    where: CinemaSeatGroupWhereUniqueInput
    /**
     * In case the CinemaSeatGroup found by the `where` argument doesn't exist, create a new CinemaSeatGroup with this data.
     */
    create: XOR<CinemaSeatGroupCreateInput, CinemaSeatGroupUncheckedCreateInput>
    /**
     * In case the CinemaSeatGroup was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CinemaSeatGroupUpdateInput, CinemaSeatGroupUncheckedUpdateInput>
  }

  /**
   * CinemaSeatGroup delete
   */
  export type CinemaSeatGroupDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CinemaSeatGroup
     */
    select?: CinemaSeatGroupSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CinemaSeatGroupInclude<ExtArgs> | null
    /**
     * Filter which CinemaSeatGroup to delete.
     */
    where: CinemaSeatGroupWhereUniqueInput
  }

  /**
   * CinemaSeatGroup deleteMany
   */
  export type CinemaSeatGroupDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CinemaSeatGroups to delete
     */
    where?: CinemaSeatGroupWhereInput
  }

  /**
   * CinemaSeatGroup.cinemaSeats
   */
  export type CinemaSeatGroup$cinemaSeatsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CinemaSeat
     */
    select?: CinemaSeatSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CinemaSeatInclude<ExtArgs> | null
    where?: CinemaSeatWhereInput
    orderBy?: CinemaSeatOrderByWithRelationInput | CinemaSeatOrderByWithRelationInput[]
    cursor?: CinemaSeatWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CinemaSeatScalarFieldEnum | CinemaSeatScalarFieldEnum[]
  }

  /**
   * CinemaSeatGroup.projectionPrices
   */
  export type CinemaSeatGroup$projectionPricesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectionPrice
     */
    select?: ProjectionPriceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectionPriceInclude<ExtArgs> | null
    where?: ProjectionPriceWhereInput
    orderBy?: ProjectionPriceOrderByWithRelationInput | ProjectionPriceOrderByWithRelationInput[]
    cursor?: ProjectionPriceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProjectionPriceScalarFieldEnum | ProjectionPriceScalarFieldEnum[]
  }

  /**
   * CinemaSeatGroup without action
   */
  export type CinemaSeatGroupDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CinemaSeatGroup
     */
    select?: CinemaSeatGroupSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CinemaSeatGroupInclude<ExtArgs> | null
  }


  /**
   * Model CinemaSeat
   */

  export type AggregateCinemaSeat = {
    _count: CinemaSeatCountAggregateOutputType | null
    _min: CinemaSeatMinAggregateOutputType | null
    _max: CinemaSeatMaxAggregateOutputType | null
  }

  export type CinemaSeatMinAggregateOutputType = {
    id: string | null
    cinemaSeatGroupId: string | null
    seatRow: string | null
    seatColumn: string | null
  }

  export type CinemaSeatMaxAggregateOutputType = {
    id: string | null
    cinemaSeatGroupId: string | null
    seatRow: string | null
    seatColumn: string | null
  }

  export type CinemaSeatCountAggregateOutputType = {
    id: number
    cinemaSeatGroupId: number
    seatRow: number
    seatColumn: number
    options: number
    _all: number
  }


  export type CinemaSeatMinAggregateInputType = {
    id?: true
    cinemaSeatGroupId?: true
    seatRow?: true
    seatColumn?: true
  }

  export type CinemaSeatMaxAggregateInputType = {
    id?: true
    cinemaSeatGroupId?: true
    seatRow?: true
    seatColumn?: true
  }

  export type CinemaSeatCountAggregateInputType = {
    id?: true
    cinemaSeatGroupId?: true
    seatRow?: true
    seatColumn?: true
    options?: true
    _all?: true
  }

  export type CinemaSeatAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CinemaSeat to aggregate.
     */
    where?: CinemaSeatWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CinemaSeats to fetch.
     */
    orderBy?: CinemaSeatOrderByWithRelationInput | CinemaSeatOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CinemaSeatWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CinemaSeats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CinemaSeats.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CinemaSeats
    **/
    _count?: true | CinemaSeatCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CinemaSeatMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CinemaSeatMaxAggregateInputType
  }

  export type GetCinemaSeatAggregateType<T extends CinemaSeatAggregateArgs> = {
        [P in keyof T & keyof AggregateCinemaSeat]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCinemaSeat[P]>
      : GetScalarType<T[P], AggregateCinemaSeat[P]>
  }




  export type CinemaSeatGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CinemaSeatWhereInput
    orderBy?: CinemaSeatOrderByWithAggregationInput | CinemaSeatOrderByWithAggregationInput[]
    by: CinemaSeatScalarFieldEnum[] | CinemaSeatScalarFieldEnum
    having?: CinemaSeatScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CinemaSeatCountAggregateInputType | true
    _min?: CinemaSeatMinAggregateInputType
    _max?: CinemaSeatMaxAggregateInputType
  }

  export type CinemaSeatGroupByOutputType = {
    id: string
    cinemaSeatGroupId: string
    seatRow: string
    seatColumn: string
    options: JsonValue
    _count: CinemaSeatCountAggregateOutputType | null
    _min: CinemaSeatMinAggregateOutputType | null
    _max: CinemaSeatMaxAggregateOutputType | null
  }

  type GetCinemaSeatGroupByPayload<T extends CinemaSeatGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CinemaSeatGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CinemaSeatGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CinemaSeatGroupByOutputType[P]>
            : GetScalarType<T[P], CinemaSeatGroupByOutputType[P]>
        }
      >
    >


  export type CinemaSeatSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    cinemaSeatGroupId?: boolean
    seatRow?: boolean
    seatColumn?: boolean
    options?: boolean
    cinemaSeatGroup?: boolean | CinemaSeatGroupDefaultArgs<ExtArgs>
    reservation?: boolean | CinemaSeat$reservationArgs<ExtArgs>
    _count?: boolean | CinemaSeatCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["cinemaSeat"]>

  export type CinemaSeatSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    cinemaSeatGroupId?: boolean
    seatRow?: boolean
    seatColumn?: boolean
    options?: boolean
    cinemaSeatGroup?: boolean | CinemaSeatGroupDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["cinemaSeat"]>

  export type CinemaSeatSelectScalar = {
    id?: boolean
    cinemaSeatGroupId?: boolean
    seatRow?: boolean
    seatColumn?: boolean
    options?: boolean
  }

  export type CinemaSeatInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    cinemaSeatGroup?: boolean | CinemaSeatGroupDefaultArgs<ExtArgs>
    reservation?: boolean | CinemaSeat$reservationArgs<ExtArgs>
    _count?: boolean | CinemaSeatCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CinemaSeatIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    cinemaSeatGroup?: boolean | CinemaSeatGroupDefaultArgs<ExtArgs>
  }

  export type $CinemaSeatPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CinemaSeat"
    objects: {
      cinemaSeatGroup: Prisma.$CinemaSeatGroupPayload<ExtArgs>
      reservation: Prisma.$ReservationSeatsPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      cinemaSeatGroupId: string
      seatRow: string
      seatColumn: string
      options: Prisma.JsonValue
    }, ExtArgs["result"]["cinemaSeat"]>
    composites: {}
  }

  type CinemaSeatGetPayload<S extends boolean | null | undefined | CinemaSeatDefaultArgs> = $Result.GetResult<Prisma.$CinemaSeatPayload, S>

  type CinemaSeatCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CinemaSeatFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CinemaSeatCountAggregateInputType | true
    }

  export interface CinemaSeatDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CinemaSeat'], meta: { name: 'CinemaSeat' } }
    /**
     * Find zero or one CinemaSeat that matches the filter.
     * @param {CinemaSeatFindUniqueArgs} args - Arguments to find a CinemaSeat
     * @example
     * // Get one CinemaSeat
     * const cinemaSeat = await prisma.cinemaSeat.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CinemaSeatFindUniqueArgs>(args: SelectSubset<T, CinemaSeatFindUniqueArgs<ExtArgs>>): Prisma__CinemaSeatClient<$Result.GetResult<Prisma.$CinemaSeatPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one CinemaSeat that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {CinemaSeatFindUniqueOrThrowArgs} args - Arguments to find a CinemaSeat
     * @example
     * // Get one CinemaSeat
     * const cinemaSeat = await prisma.cinemaSeat.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CinemaSeatFindUniqueOrThrowArgs>(args: SelectSubset<T, CinemaSeatFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CinemaSeatClient<$Result.GetResult<Prisma.$CinemaSeatPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first CinemaSeat that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CinemaSeatFindFirstArgs} args - Arguments to find a CinemaSeat
     * @example
     * // Get one CinemaSeat
     * const cinemaSeat = await prisma.cinemaSeat.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CinemaSeatFindFirstArgs>(args?: SelectSubset<T, CinemaSeatFindFirstArgs<ExtArgs>>): Prisma__CinemaSeatClient<$Result.GetResult<Prisma.$CinemaSeatPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first CinemaSeat that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CinemaSeatFindFirstOrThrowArgs} args - Arguments to find a CinemaSeat
     * @example
     * // Get one CinemaSeat
     * const cinemaSeat = await prisma.cinemaSeat.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CinemaSeatFindFirstOrThrowArgs>(args?: SelectSubset<T, CinemaSeatFindFirstOrThrowArgs<ExtArgs>>): Prisma__CinemaSeatClient<$Result.GetResult<Prisma.$CinemaSeatPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more CinemaSeats that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CinemaSeatFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CinemaSeats
     * const cinemaSeats = await prisma.cinemaSeat.findMany()
     * 
     * // Get first 10 CinemaSeats
     * const cinemaSeats = await prisma.cinemaSeat.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const cinemaSeatWithIdOnly = await prisma.cinemaSeat.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CinemaSeatFindManyArgs>(args?: SelectSubset<T, CinemaSeatFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CinemaSeatPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a CinemaSeat.
     * @param {CinemaSeatCreateArgs} args - Arguments to create a CinemaSeat.
     * @example
     * // Create one CinemaSeat
     * const CinemaSeat = await prisma.cinemaSeat.create({
     *   data: {
     *     // ... data to create a CinemaSeat
     *   }
     * })
     * 
     */
    create<T extends CinemaSeatCreateArgs>(args: SelectSubset<T, CinemaSeatCreateArgs<ExtArgs>>): Prisma__CinemaSeatClient<$Result.GetResult<Prisma.$CinemaSeatPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many CinemaSeats.
     * @param {CinemaSeatCreateManyArgs} args - Arguments to create many CinemaSeats.
     * @example
     * // Create many CinemaSeats
     * const cinemaSeat = await prisma.cinemaSeat.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CinemaSeatCreateManyArgs>(args?: SelectSubset<T, CinemaSeatCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CinemaSeats and returns the data saved in the database.
     * @param {CinemaSeatCreateManyAndReturnArgs} args - Arguments to create many CinemaSeats.
     * @example
     * // Create many CinemaSeats
     * const cinemaSeat = await prisma.cinemaSeat.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CinemaSeats and only return the `id`
     * const cinemaSeatWithIdOnly = await prisma.cinemaSeat.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CinemaSeatCreateManyAndReturnArgs>(args?: SelectSubset<T, CinemaSeatCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CinemaSeatPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a CinemaSeat.
     * @param {CinemaSeatDeleteArgs} args - Arguments to delete one CinemaSeat.
     * @example
     * // Delete one CinemaSeat
     * const CinemaSeat = await prisma.cinemaSeat.delete({
     *   where: {
     *     // ... filter to delete one CinemaSeat
     *   }
     * })
     * 
     */
    delete<T extends CinemaSeatDeleteArgs>(args: SelectSubset<T, CinemaSeatDeleteArgs<ExtArgs>>): Prisma__CinemaSeatClient<$Result.GetResult<Prisma.$CinemaSeatPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one CinemaSeat.
     * @param {CinemaSeatUpdateArgs} args - Arguments to update one CinemaSeat.
     * @example
     * // Update one CinemaSeat
     * const cinemaSeat = await prisma.cinemaSeat.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CinemaSeatUpdateArgs>(args: SelectSubset<T, CinemaSeatUpdateArgs<ExtArgs>>): Prisma__CinemaSeatClient<$Result.GetResult<Prisma.$CinemaSeatPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more CinemaSeats.
     * @param {CinemaSeatDeleteManyArgs} args - Arguments to filter CinemaSeats to delete.
     * @example
     * // Delete a few CinemaSeats
     * const { count } = await prisma.cinemaSeat.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CinemaSeatDeleteManyArgs>(args?: SelectSubset<T, CinemaSeatDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CinemaSeats.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CinemaSeatUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CinemaSeats
     * const cinemaSeat = await prisma.cinemaSeat.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CinemaSeatUpdateManyArgs>(args: SelectSubset<T, CinemaSeatUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one CinemaSeat.
     * @param {CinemaSeatUpsertArgs} args - Arguments to update or create a CinemaSeat.
     * @example
     * // Update or create a CinemaSeat
     * const cinemaSeat = await prisma.cinemaSeat.upsert({
     *   create: {
     *     // ... data to create a CinemaSeat
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CinemaSeat we want to update
     *   }
     * })
     */
    upsert<T extends CinemaSeatUpsertArgs>(args: SelectSubset<T, CinemaSeatUpsertArgs<ExtArgs>>): Prisma__CinemaSeatClient<$Result.GetResult<Prisma.$CinemaSeatPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of CinemaSeats.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CinemaSeatCountArgs} args - Arguments to filter CinemaSeats to count.
     * @example
     * // Count the number of CinemaSeats
     * const count = await prisma.cinemaSeat.count({
     *   where: {
     *     // ... the filter for the CinemaSeats we want to count
     *   }
     * })
    **/
    count<T extends CinemaSeatCountArgs>(
      args?: Subset<T, CinemaSeatCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CinemaSeatCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CinemaSeat.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CinemaSeatAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CinemaSeatAggregateArgs>(args: Subset<T, CinemaSeatAggregateArgs>): Prisma.PrismaPromise<GetCinemaSeatAggregateType<T>>

    /**
     * Group by CinemaSeat.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CinemaSeatGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CinemaSeatGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CinemaSeatGroupByArgs['orderBy'] }
        : { orderBy?: CinemaSeatGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CinemaSeatGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCinemaSeatGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CinemaSeat model
   */
  readonly fields: CinemaSeatFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CinemaSeat.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CinemaSeatClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    cinemaSeatGroup<T extends CinemaSeatGroupDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CinemaSeatGroupDefaultArgs<ExtArgs>>): Prisma__CinemaSeatGroupClient<$Result.GetResult<Prisma.$CinemaSeatGroupPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    reservation<T extends CinemaSeat$reservationArgs<ExtArgs> = {}>(args?: Subset<T, CinemaSeat$reservationArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReservationSeatsPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CinemaSeat model
   */ 
  interface CinemaSeatFieldRefs {
    readonly id: FieldRef<"CinemaSeat", 'String'>
    readonly cinemaSeatGroupId: FieldRef<"CinemaSeat", 'String'>
    readonly seatRow: FieldRef<"CinemaSeat", 'String'>
    readonly seatColumn: FieldRef<"CinemaSeat", 'String'>
    readonly options: FieldRef<"CinemaSeat", 'Json'>
  }
    

  // Custom InputTypes
  /**
   * CinemaSeat findUnique
   */
  export type CinemaSeatFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CinemaSeat
     */
    select?: CinemaSeatSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CinemaSeatInclude<ExtArgs> | null
    /**
     * Filter, which CinemaSeat to fetch.
     */
    where: CinemaSeatWhereUniqueInput
  }

  /**
   * CinemaSeat findUniqueOrThrow
   */
  export type CinemaSeatFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CinemaSeat
     */
    select?: CinemaSeatSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CinemaSeatInclude<ExtArgs> | null
    /**
     * Filter, which CinemaSeat to fetch.
     */
    where: CinemaSeatWhereUniqueInput
  }

  /**
   * CinemaSeat findFirst
   */
  export type CinemaSeatFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CinemaSeat
     */
    select?: CinemaSeatSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CinemaSeatInclude<ExtArgs> | null
    /**
     * Filter, which CinemaSeat to fetch.
     */
    where?: CinemaSeatWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CinemaSeats to fetch.
     */
    orderBy?: CinemaSeatOrderByWithRelationInput | CinemaSeatOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CinemaSeats.
     */
    cursor?: CinemaSeatWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CinemaSeats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CinemaSeats.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CinemaSeats.
     */
    distinct?: CinemaSeatScalarFieldEnum | CinemaSeatScalarFieldEnum[]
  }

  /**
   * CinemaSeat findFirstOrThrow
   */
  export type CinemaSeatFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CinemaSeat
     */
    select?: CinemaSeatSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CinemaSeatInclude<ExtArgs> | null
    /**
     * Filter, which CinemaSeat to fetch.
     */
    where?: CinemaSeatWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CinemaSeats to fetch.
     */
    orderBy?: CinemaSeatOrderByWithRelationInput | CinemaSeatOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CinemaSeats.
     */
    cursor?: CinemaSeatWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CinemaSeats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CinemaSeats.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CinemaSeats.
     */
    distinct?: CinemaSeatScalarFieldEnum | CinemaSeatScalarFieldEnum[]
  }

  /**
   * CinemaSeat findMany
   */
  export type CinemaSeatFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CinemaSeat
     */
    select?: CinemaSeatSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CinemaSeatInclude<ExtArgs> | null
    /**
     * Filter, which CinemaSeats to fetch.
     */
    where?: CinemaSeatWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CinemaSeats to fetch.
     */
    orderBy?: CinemaSeatOrderByWithRelationInput | CinemaSeatOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CinemaSeats.
     */
    cursor?: CinemaSeatWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CinemaSeats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CinemaSeats.
     */
    skip?: number
    distinct?: CinemaSeatScalarFieldEnum | CinemaSeatScalarFieldEnum[]
  }

  /**
   * CinemaSeat create
   */
  export type CinemaSeatCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CinemaSeat
     */
    select?: CinemaSeatSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CinemaSeatInclude<ExtArgs> | null
    /**
     * The data needed to create a CinemaSeat.
     */
    data: XOR<CinemaSeatCreateInput, CinemaSeatUncheckedCreateInput>
  }

  /**
   * CinemaSeat createMany
   */
  export type CinemaSeatCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CinemaSeats.
     */
    data: CinemaSeatCreateManyInput | CinemaSeatCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CinemaSeat createManyAndReturn
   */
  export type CinemaSeatCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CinemaSeat
     */
    select?: CinemaSeatSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many CinemaSeats.
     */
    data: CinemaSeatCreateManyInput | CinemaSeatCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CinemaSeatIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CinemaSeat update
   */
  export type CinemaSeatUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CinemaSeat
     */
    select?: CinemaSeatSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CinemaSeatInclude<ExtArgs> | null
    /**
     * The data needed to update a CinemaSeat.
     */
    data: XOR<CinemaSeatUpdateInput, CinemaSeatUncheckedUpdateInput>
    /**
     * Choose, which CinemaSeat to update.
     */
    where: CinemaSeatWhereUniqueInput
  }

  /**
   * CinemaSeat updateMany
   */
  export type CinemaSeatUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CinemaSeats.
     */
    data: XOR<CinemaSeatUpdateManyMutationInput, CinemaSeatUncheckedUpdateManyInput>
    /**
     * Filter which CinemaSeats to update
     */
    where?: CinemaSeatWhereInput
  }

  /**
   * CinemaSeat upsert
   */
  export type CinemaSeatUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CinemaSeat
     */
    select?: CinemaSeatSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CinemaSeatInclude<ExtArgs> | null
    /**
     * The filter to search for the CinemaSeat to update in case it exists.
     */
    where: CinemaSeatWhereUniqueInput
    /**
     * In case the CinemaSeat found by the `where` argument doesn't exist, create a new CinemaSeat with this data.
     */
    create: XOR<CinemaSeatCreateInput, CinemaSeatUncheckedCreateInput>
    /**
     * In case the CinemaSeat was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CinemaSeatUpdateInput, CinemaSeatUncheckedUpdateInput>
  }

  /**
   * CinemaSeat delete
   */
  export type CinemaSeatDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CinemaSeat
     */
    select?: CinemaSeatSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CinemaSeatInclude<ExtArgs> | null
    /**
     * Filter which CinemaSeat to delete.
     */
    where: CinemaSeatWhereUniqueInput
  }

  /**
   * CinemaSeat deleteMany
   */
  export type CinemaSeatDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CinemaSeats to delete
     */
    where?: CinemaSeatWhereInput
  }

  /**
   * CinemaSeat.reservation
   */
  export type CinemaSeat$reservationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReservationSeats
     */
    select?: ReservationSeatsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReservationSeatsInclude<ExtArgs> | null
    where?: ReservationSeatsWhereInput
    orderBy?: ReservationSeatsOrderByWithRelationInput | ReservationSeatsOrderByWithRelationInput[]
    cursor?: ReservationSeatsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ReservationSeatsScalarFieldEnum | ReservationSeatsScalarFieldEnum[]
  }

  /**
   * CinemaSeat without action
   */
  export type CinemaSeatDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CinemaSeat
     */
    select?: CinemaSeatSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CinemaSeatInclude<ExtArgs> | null
  }


  /**
   * Model Movie
   */

  export type AggregateMovie = {
    _count: MovieCountAggregateOutputType | null
    _avg: MovieAvgAggregateOutputType | null
    _sum: MovieSumAggregateOutputType | null
    _min: MovieMinAggregateOutputType | null
    _max: MovieMaxAggregateOutputType | null
  }

  export type MovieAvgAggregateOutputType = {
    runtimeMinutes: number | null
    rating: number | null
  }

  export type MovieSumAggregateOutputType = {
    runtimeMinutes: number | null
    rating: number | null
  }

  export type MovieMinAggregateOutputType = {
    id: string | null
    title: string | null
    originalTitle: string | null
    localizedTitle: string | null
    plot: string | null
    localizedPlot: string | null
    runtimeMinutes: number | null
    originalLanguageId: string | null
    countryOfOriginId: string | null
    rating: number | null
    releaseDate: Date | null
    createdAt: Date | null
    updatedAt: Date | null
    externalId: string | null
    externalType: $Enums.InputProvider | null
  }

  export type MovieMaxAggregateOutputType = {
    id: string | null
    title: string | null
    originalTitle: string | null
    localizedTitle: string | null
    plot: string | null
    localizedPlot: string | null
    runtimeMinutes: number | null
    originalLanguageId: string | null
    countryOfOriginId: string | null
    rating: number | null
    releaseDate: Date | null
    createdAt: Date | null
    updatedAt: Date | null
    externalId: string | null
    externalType: $Enums.InputProvider | null
  }

  export type MovieCountAggregateOutputType = {
    id: number
    title: number
    originalTitle: number
    localizedTitle: number
    plot: number
    localizedPlot: number
    runtimeMinutes: number
    originalLanguageId: number
    countryOfOriginId: number
    posterImages: number
    videos: number
    rating: number
    releaseDate: number
    createdAt: number
    updatedAt: number
    externalId: number
    externalType: number
    additionalData: number
    _all: number
  }


  export type MovieAvgAggregateInputType = {
    runtimeMinutes?: true
    rating?: true
  }

  export type MovieSumAggregateInputType = {
    runtimeMinutes?: true
    rating?: true
  }

  export type MovieMinAggregateInputType = {
    id?: true
    title?: true
    originalTitle?: true
    localizedTitle?: true
    plot?: true
    localizedPlot?: true
    runtimeMinutes?: true
    originalLanguageId?: true
    countryOfOriginId?: true
    rating?: true
    releaseDate?: true
    createdAt?: true
    updatedAt?: true
    externalId?: true
    externalType?: true
  }

  export type MovieMaxAggregateInputType = {
    id?: true
    title?: true
    originalTitle?: true
    localizedTitle?: true
    plot?: true
    localizedPlot?: true
    runtimeMinutes?: true
    originalLanguageId?: true
    countryOfOriginId?: true
    rating?: true
    releaseDate?: true
    createdAt?: true
    updatedAt?: true
    externalId?: true
    externalType?: true
  }

  export type MovieCountAggregateInputType = {
    id?: true
    title?: true
    originalTitle?: true
    localizedTitle?: true
    plot?: true
    localizedPlot?: true
    runtimeMinutes?: true
    originalLanguageId?: true
    countryOfOriginId?: true
    posterImages?: true
    videos?: true
    rating?: true
    releaseDate?: true
    createdAt?: true
    updatedAt?: true
    externalId?: true
    externalType?: true
    additionalData?: true
    _all?: true
  }

  export type MovieAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Movie to aggregate.
     */
    where?: MovieWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Movies to fetch.
     */
    orderBy?: MovieOrderByWithRelationInput | MovieOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MovieWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Movies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Movies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Movies
    **/
    _count?: true | MovieCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MovieAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MovieSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MovieMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MovieMaxAggregateInputType
  }

  export type GetMovieAggregateType<T extends MovieAggregateArgs> = {
        [P in keyof T & keyof AggregateMovie]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMovie[P]>
      : GetScalarType<T[P], AggregateMovie[P]>
  }




  export type MovieGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MovieWhereInput
    orderBy?: MovieOrderByWithAggregationInput | MovieOrderByWithAggregationInput[]
    by: MovieScalarFieldEnum[] | MovieScalarFieldEnum
    having?: MovieScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MovieCountAggregateInputType | true
    _avg?: MovieAvgAggregateInputType
    _sum?: MovieSumAggregateInputType
    _min?: MovieMinAggregateInputType
    _max?: MovieMaxAggregateInputType
  }

  export type MovieGroupByOutputType = {
    id: string
    title: string | null
    originalTitle: string
    localizedTitle: string | null
    plot: string
    localizedPlot: string | null
    runtimeMinutes: number
    originalLanguageId: string
    countryOfOriginId: string
    posterImages: JsonValue
    videos: JsonValue
    rating: number
    releaseDate: Date
    createdAt: Date
    updatedAt: Date
    externalId: string
    externalType: $Enums.InputProvider
    additionalData: JsonValue
    _count: MovieCountAggregateOutputType | null
    _avg: MovieAvgAggregateOutputType | null
    _sum: MovieSumAggregateOutputType | null
    _min: MovieMinAggregateOutputType | null
    _max: MovieMaxAggregateOutputType | null
  }

  type GetMovieGroupByPayload<T extends MovieGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MovieGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MovieGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MovieGroupByOutputType[P]>
            : GetScalarType<T[P], MovieGroupByOutputType[P]>
        }
      >
    >


  export type MovieSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    originalTitle?: boolean
    localizedTitle?: boolean
    plot?: boolean
    localizedPlot?: boolean
    runtimeMinutes?: boolean
    originalLanguageId?: boolean
    countryOfOriginId?: boolean
    posterImages?: boolean
    videos?: boolean
    rating?: boolean
    releaseDate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    externalId?: boolean
    externalType?: boolean
    additionalData?: boolean
    genres?: boolean | Movie$genresArgs<ExtArgs>
    originalLanguage?: boolean | LanguageDefaultArgs<ExtArgs>
    countryOfOrigin?: boolean | CountryDefaultArgs<ExtArgs>
    actors?: boolean | Movie$actorsArgs<ExtArgs>
    directors?: boolean | Movie$directorsArgs<ExtArgs>
    producers?: boolean | Movie$producersArgs<ExtArgs>
    movieCinemaOverrides?: boolean | Movie$movieCinemaOverridesArgs<ExtArgs>
    movieProjections?: boolean | Movie$movieProjectionsArgs<ExtArgs>
    _count?: boolean | MovieCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["movie"]>

  export type MovieSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    originalTitle?: boolean
    localizedTitle?: boolean
    plot?: boolean
    localizedPlot?: boolean
    runtimeMinutes?: boolean
    originalLanguageId?: boolean
    countryOfOriginId?: boolean
    posterImages?: boolean
    videos?: boolean
    rating?: boolean
    releaseDate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    externalId?: boolean
    externalType?: boolean
    additionalData?: boolean
    originalLanguage?: boolean | LanguageDefaultArgs<ExtArgs>
    countryOfOrigin?: boolean | CountryDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["movie"]>

  export type MovieSelectScalar = {
    id?: boolean
    title?: boolean
    originalTitle?: boolean
    localizedTitle?: boolean
    plot?: boolean
    localizedPlot?: boolean
    runtimeMinutes?: boolean
    originalLanguageId?: boolean
    countryOfOriginId?: boolean
    posterImages?: boolean
    videos?: boolean
    rating?: boolean
    releaseDate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    externalId?: boolean
    externalType?: boolean
    additionalData?: boolean
  }

  export type MovieInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    genres?: boolean | Movie$genresArgs<ExtArgs>
    originalLanguage?: boolean | LanguageDefaultArgs<ExtArgs>
    countryOfOrigin?: boolean | CountryDefaultArgs<ExtArgs>
    actors?: boolean | Movie$actorsArgs<ExtArgs>
    directors?: boolean | Movie$directorsArgs<ExtArgs>
    producers?: boolean | Movie$producersArgs<ExtArgs>
    movieCinemaOverrides?: boolean | Movie$movieCinemaOverridesArgs<ExtArgs>
    movieProjections?: boolean | Movie$movieProjectionsArgs<ExtArgs>
    _count?: boolean | MovieCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type MovieIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    originalLanguage?: boolean | LanguageDefaultArgs<ExtArgs>
    countryOfOrigin?: boolean | CountryDefaultArgs<ExtArgs>
  }

  export type $MoviePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Movie"
    objects: {
      genres: Prisma.$GenrePayload<ExtArgs>[]
      originalLanguage: Prisma.$LanguagePayload<ExtArgs>
      countryOfOrigin: Prisma.$CountryPayload<ExtArgs>
      actors: Prisma.$MovieActorPayload<ExtArgs>[]
      directors: Prisma.$MovieDirectorPayload<ExtArgs>[]
      producers: Prisma.$MovieProducerPayload<ExtArgs>[]
      movieCinemaOverrides: Prisma.$MovieCinemaOverridePayload<ExtArgs>[]
      movieProjections: Prisma.$MovieProjectionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      title: string | null
      originalTitle: string
      localizedTitle: string | null
      plot: string
      localizedPlot: string | null
      runtimeMinutes: number
      originalLanguageId: string
      countryOfOriginId: string
      posterImages: Prisma.JsonValue
      videos: Prisma.JsonValue
      rating: number
      releaseDate: Date
      createdAt: Date
      updatedAt: Date
      externalId: string
      externalType: $Enums.InputProvider
      additionalData: Prisma.JsonValue
    }, ExtArgs["result"]["movie"]>
    composites: {}
  }

  type MovieGetPayload<S extends boolean | null | undefined | MovieDefaultArgs> = $Result.GetResult<Prisma.$MoviePayload, S>

  type MovieCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<MovieFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: MovieCountAggregateInputType | true
    }

  export interface MovieDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Movie'], meta: { name: 'Movie' } }
    /**
     * Find zero or one Movie that matches the filter.
     * @param {MovieFindUniqueArgs} args - Arguments to find a Movie
     * @example
     * // Get one Movie
     * const movie = await prisma.movie.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MovieFindUniqueArgs>(args: SelectSubset<T, MovieFindUniqueArgs<ExtArgs>>): Prisma__MovieClient<$Result.GetResult<Prisma.$MoviePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Movie that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {MovieFindUniqueOrThrowArgs} args - Arguments to find a Movie
     * @example
     * // Get one Movie
     * const movie = await prisma.movie.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MovieFindUniqueOrThrowArgs>(args: SelectSubset<T, MovieFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MovieClient<$Result.GetResult<Prisma.$MoviePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Movie that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MovieFindFirstArgs} args - Arguments to find a Movie
     * @example
     * // Get one Movie
     * const movie = await prisma.movie.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MovieFindFirstArgs>(args?: SelectSubset<T, MovieFindFirstArgs<ExtArgs>>): Prisma__MovieClient<$Result.GetResult<Prisma.$MoviePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Movie that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MovieFindFirstOrThrowArgs} args - Arguments to find a Movie
     * @example
     * // Get one Movie
     * const movie = await prisma.movie.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MovieFindFirstOrThrowArgs>(args?: SelectSubset<T, MovieFindFirstOrThrowArgs<ExtArgs>>): Prisma__MovieClient<$Result.GetResult<Prisma.$MoviePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Movies that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MovieFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Movies
     * const movies = await prisma.movie.findMany()
     * 
     * // Get first 10 Movies
     * const movies = await prisma.movie.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const movieWithIdOnly = await prisma.movie.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MovieFindManyArgs>(args?: SelectSubset<T, MovieFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MoviePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Movie.
     * @param {MovieCreateArgs} args - Arguments to create a Movie.
     * @example
     * // Create one Movie
     * const Movie = await prisma.movie.create({
     *   data: {
     *     // ... data to create a Movie
     *   }
     * })
     * 
     */
    create<T extends MovieCreateArgs>(args: SelectSubset<T, MovieCreateArgs<ExtArgs>>): Prisma__MovieClient<$Result.GetResult<Prisma.$MoviePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Movies.
     * @param {MovieCreateManyArgs} args - Arguments to create many Movies.
     * @example
     * // Create many Movies
     * const movie = await prisma.movie.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MovieCreateManyArgs>(args?: SelectSubset<T, MovieCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Movies and returns the data saved in the database.
     * @param {MovieCreateManyAndReturnArgs} args - Arguments to create many Movies.
     * @example
     * // Create many Movies
     * const movie = await prisma.movie.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Movies and only return the `id`
     * const movieWithIdOnly = await prisma.movie.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MovieCreateManyAndReturnArgs>(args?: SelectSubset<T, MovieCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MoviePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Movie.
     * @param {MovieDeleteArgs} args - Arguments to delete one Movie.
     * @example
     * // Delete one Movie
     * const Movie = await prisma.movie.delete({
     *   where: {
     *     // ... filter to delete one Movie
     *   }
     * })
     * 
     */
    delete<T extends MovieDeleteArgs>(args: SelectSubset<T, MovieDeleteArgs<ExtArgs>>): Prisma__MovieClient<$Result.GetResult<Prisma.$MoviePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Movie.
     * @param {MovieUpdateArgs} args - Arguments to update one Movie.
     * @example
     * // Update one Movie
     * const movie = await prisma.movie.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MovieUpdateArgs>(args: SelectSubset<T, MovieUpdateArgs<ExtArgs>>): Prisma__MovieClient<$Result.GetResult<Prisma.$MoviePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Movies.
     * @param {MovieDeleteManyArgs} args - Arguments to filter Movies to delete.
     * @example
     * // Delete a few Movies
     * const { count } = await prisma.movie.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MovieDeleteManyArgs>(args?: SelectSubset<T, MovieDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Movies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MovieUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Movies
     * const movie = await prisma.movie.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MovieUpdateManyArgs>(args: SelectSubset<T, MovieUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Movie.
     * @param {MovieUpsertArgs} args - Arguments to update or create a Movie.
     * @example
     * // Update or create a Movie
     * const movie = await prisma.movie.upsert({
     *   create: {
     *     // ... data to create a Movie
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Movie we want to update
     *   }
     * })
     */
    upsert<T extends MovieUpsertArgs>(args: SelectSubset<T, MovieUpsertArgs<ExtArgs>>): Prisma__MovieClient<$Result.GetResult<Prisma.$MoviePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Movies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MovieCountArgs} args - Arguments to filter Movies to count.
     * @example
     * // Count the number of Movies
     * const count = await prisma.movie.count({
     *   where: {
     *     // ... the filter for the Movies we want to count
     *   }
     * })
    **/
    count<T extends MovieCountArgs>(
      args?: Subset<T, MovieCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MovieCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Movie.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MovieAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MovieAggregateArgs>(args: Subset<T, MovieAggregateArgs>): Prisma.PrismaPromise<GetMovieAggregateType<T>>

    /**
     * Group by Movie.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MovieGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MovieGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MovieGroupByArgs['orderBy'] }
        : { orderBy?: MovieGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MovieGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMovieGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Movie model
   */
  readonly fields: MovieFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Movie.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MovieClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    genres<T extends Movie$genresArgs<ExtArgs> = {}>(args?: Subset<T, Movie$genresArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GenrePayload<ExtArgs>, T, "findMany"> | Null>
    originalLanguage<T extends LanguageDefaultArgs<ExtArgs> = {}>(args?: Subset<T, LanguageDefaultArgs<ExtArgs>>): Prisma__LanguageClient<$Result.GetResult<Prisma.$LanguagePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    countryOfOrigin<T extends CountryDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CountryDefaultArgs<ExtArgs>>): Prisma__CountryClient<$Result.GetResult<Prisma.$CountryPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    actors<T extends Movie$actorsArgs<ExtArgs> = {}>(args?: Subset<T, Movie$actorsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MovieActorPayload<ExtArgs>, T, "findMany"> | Null>
    directors<T extends Movie$directorsArgs<ExtArgs> = {}>(args?: Subset<T, Movie$directorsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MovieDirectorPayload<ExtArgs>, T, "findMany"> | Null>
    producers<T extends Movie$producersArgs<ExtArgs> = {}>(args?: Subset<T, Movie$producersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MovieProducerPayload<ExtArgs>, T, "findMany"> | Null>
    movieCinemaOverrides<T extends Movie$movieCinemaOverridesArgs<ExtArgs> = {}>(args?: Subset<T, Movie$movieCinemaOverridesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MovieCinemaOverridePayload<ExtArgs>, T, "findMany"> | Null>
    movieProjections<T extends Movie$movieProjectionsArgs<ExtArgs> = {}>(args?: Subset<T, Movie$movieProjectionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MovieProjectionPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Movie model
   */ 
  interface MovieFieldRefs {
    readonly id: FieldRef<"Movie", 'String'>
    readonly title: FieldRef<"Movie", 'String'>
    readonly originalTitle: FieldRef<"Movie", 'String'>
    readonly localizedTitle: FieldRef<"Movie", 'String'>
    readonly plot: FieldRef<"Movie", 'String'>
    readonly localizedPlot: FieldRef<"Movie", 'String'>
    readonly runtimeMinutes: FieldRef<"Movie", 'Int'>
    readonly originalLanguageId: FieldRef<"Movie", 'String'>
    readonly countryOfOriginId: FieldRef<"Movie", 'String'>
    readonly posterImages: FieldRef<"Movie", 'Json'>
    readonly videos: FieldRef<"Movie", 'Json'>
    readonly rating: FieldRef<"Movie", 'Int'>
    readonly releaseDate: FieldRef<"Movie", 'DateTime'>
    readonly createdAt: FieldRef<"Movie", 'DateTime'>
    readonly updatedAt: FieldRef<"Movie", 'DateTime'>
    readonly externalId: FieldRef<"Movie", 'String'>
    readonly externalType: FieldRef<"Movie", 'InputProvider'>
    readonly additionalData: FieldRef<"Movie", 'Json'>
  }
    

  // Custom InputTypes
  /**
   * Movie findUnique
   */
  export type MovieFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Movie
     */
    select?: MovieSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MovieInclude<ExtArgs> | null
    /**
     * Filter, which Movie to fetch.
     */
    where: MovieWhereUniqueInput
  }

  /**
   * Movie findUniqueOrThrow
   */
  export type MovieFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Movie
     */
    select?: MovieSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MovieInclude<ExtArgs> | null
    /**
     * Filter, which Movie to fetch.
     */
    where: MovieWhereUniqueInput
  }

  /**
   * Movie findFirst
   */
  export type MovieFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Movie
     */
    select?: MovieSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MovieInclude<ExtArgs> | null
    /**
     * Filter, which Movie to fetch.
     */
    where?: MovieWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Movies to fetch.
     */
    orderBy?: MovieOrderByWithRelationInput | MovieOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Movies.
     */
    cursor?: MovieWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Movies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Movies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Movies.
     */
    distinct?: MovieScalarFieldEnum | MovieScalarFieldEnum[]
  }

  /**
   * Movie findFirstOrThrow
   */
  export type MovieFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Movie
     */
    select?: MovieSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MovieInclude<ExtArgs> | null
    /**
     * Filter, which Movie to fetch.
     */
    where?: MovieWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Movies to fetch.
     */
    orderBy?: MovieOrderByWithRelationInput | MovieOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Movies.
     */
    cursor?: MovieWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Movies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Movies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Movies.
     */
    distinct?: MovieScalarFieldEnum | MovieScalarFieldEnum[]
  }

  /**
   * Movie findMany
   */
  export type MovieFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Movie
     */
    select?: MovieSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MovieInclude<ExtArgs> | null
    /**
     * Filter, which Movies to fetch.
     */
    where?: MovieWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Movies to fetch.
     */
    orderBy?: MovieOrderByWithRelationInput | MovieOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Movies.
     */
    cursor?: MovieWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Movies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Movies.
     */
    skip?: number
    distinct?: MovieScalarFieldEnum | MovieScalarFieldEnum[]
  }

  /**
   * Movie create
   */
  export type MovieCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Movie
     */
    select?: MovieSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MovieInclude<ExtArgs> | null
    /**
     * The data needed to create a Movie.
     */
    data: XOR<MovieCreateInput, MovieUncheckedCreateInput>
  }

  /**
   * Movie createMany
   */
  export type MovieCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Movies.
     */
    data: MovieCreateManyInput | MovieCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Movie createManyAndReturn
   */
  export type MovieCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Movie
     */
    select?: MovieSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Movies.
     */
    data: MovieCreateManyInput | MovieCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MovieIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Movie update
   */
  export type MovieUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Movie
     */
    select?: MovieSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MovieInclude<ExtArgs> | null
    /**
     * The data needed to update a Movie.
     */
    data: XOR<MovieUpdateInput, MovieUncheckedUpdateInput>
    /**
     * Choose, which Movie to update.
     */
    where: MovieWhereUniqueInput
  }

  /**
   * Movie updateMany
   */
  export type MovieUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Movies.
     */
    data: XOR<MovieUpdateManyMutationInput, MovieUncheckedUpdateManyInput>
    /**
     * Filter which Movies to update
     */
    where?: MovieWhereInput
  }

  /**
   * Movie upsert
   */
  export type MovieUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Movie
     */
    select?: MovieSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MovieInclude<ExtArgs> | null
    /**
     * The filter to search for the Movie to update in case it exists.
     */
    where: MovieWhereUniqueInput
    /**
     * In case the Movie found by the `where` argument doesn't exist, create a new Movie with this data.
     */
    create: XOR<MovieCreateInput, MovieUncheckedCreateInput>
    /**
     * In case the Movie was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MovieUpdateInput, MovieUncheckedUpdateInput>
  }

  /**
   * Movie delete
   */
  export type MovieDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Movie
     */
    select?: MovieSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MovieInclude<ExtArgs> | null
    /**
     * Filter which Movie to delete.
     */
    where: MovieWhereUniqueInput
  }

  /**
   * Movie deleteMany
   */
  export type MovieDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Movies to delete
     */
    where?: MovieWhereInput
  }

  /**
   * Movie.genres
   */
  export type Movie$genresArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Genre
     */
    select?: GenreSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GenreInclude<ExtArgs> | null
    where?: GenreWhereInput
    orderBy?: GenreOrderByWithRelationInput | GenreOrderByWithRelationInput[]
    cursor?: GenreWhereUniqueInput
    take?: number
    skip?: number
    distinct?: GenreScalarFieldEnum | GenreScalarFieldEnum[]
  }

  /**
   * Movie.actors
   */
  export type Movie$actorsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MovieActor
     */
    select?: MovieActorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MovieActorInclude<ExtArgs> | null
    where?: MovieActorWhereInput
    orderBy?: MovieActorOrderByWithRelationInput | MovieActorOrderByWithRelationInput[]
    cursor?: MovieActorWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MovieActorScalarFieldEnum | MovieActorScalarFieldEnum[]
  }

  /**
   * Movie.directors
   */
  export type Movie$directorsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MovieDirector
     */
    select?: MovieDirectorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MovieDirectorInclude<ExtArgs> | null
    where?: MovieDirectorWhereInput
    orderBy?: MovieDirectorOrderByWithRelationInput | MovieDirectorOrderByWithRelationInput[]
    cursor?: MovieDirectorWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MovieDirectorScalarFieldEnum | MovieDirectorScalarFieldEnum[]
  }

  /**
   * Movie.producers
   */
  export type Movie$producersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MovieProducer
     */
    select?: MovieProducerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MovieProducerInclude<ExtArgs> | null
    where?: MovieProducerWhereInput
    orderBy?: MovieProducerOrderByWithRelationInput | MovieProducerOrderByWithRelationInput[]
    cursor?: MovieProducerWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MovieProducerScalarFieldEnum | MovieProducerScalarFieldEnum[]
  }

  /**
   * Movie.movieCinemaOverrides
   */
  export type Movie$movieCinemaOverridesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MovieCinemaOverride
     */
    select?: MovieCinemaOverrideSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MovieCinemaOverrideInclude<ExtArgs> | null
    where?: MovieCinemaOverrideWhereInput
    orderBy?: MovieCinemaOverrideOrderByWithRelationInput | MovieCinemaOverrideOrderByWithRelationInput[]
    cursor?: MovieCinemaOverrideWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MovieCinemaOverrideScalarFieldEnum | MovieCinemaOverrideScalarFieldEnum[]
  }

  /**
   * Movie.movieProjections
   */
  export type Movie$movieProjectionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MovieProjection
     */
    select?: MovieProjectionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MovieProjectionInclude<ExtArgs> | null
    where?: MovieProjectionWhereInput
    orderBy?: MovieProjectionOrderByWithRelationInput | MovieProjectionOrderByWithRelationInput[]
    cursor?: MovieProjectionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MovieProjectionScalarFieldEnum | MovieProjectionScalarFieldEnum[]
  }

  /**
   * Movie without action
   */
  export type MovieDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Movie
     */
    select?: MovieSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MovieInclude<ExtArgs> | null
  }


  /**
   * Model Person
   */

  export type AggregatePerson = {
    _count: PersonCountAggregateOutputType | null
    _min: PersonMinAggregateOutputType | null
    _max: PersonMaxAggregateOutputType | null
  }

  export type PersonMinAggregateOutputType = {
    id: string | null
    name: string | null
    biography: string | null
    dateOfBirth: Date | null
    dateOfDeath: Date | null
    gender: $Enums.Gender | null
    createdAt: Date | null
    updatedAt: Date | null
    externalId: string | null
    externalType: $Enums.InputProvider | null
  }

  export type PersonMaxAggregateOutputType = {
    id: string | null
    name: string | null
    biography: string | null
    dateOfBirth: Date | null
    dateOfDeath: Date | null
    gender: $Enums.Gender | null
    createdAt: Date | null
    updatedAt: Date | null
    externalId: string | null
    externalType: $Enums.InputProvider | null
  }

  export type PersonCountAggregateOutputType = {
    id: number
    name: number
    biography: number
    dateOfBirth: number
    dateOfDeath: number
    gender: number
    createdAt: number
    updatedAt: number
    externalId: number
    externalType: number
    additionalData: number
    _all: number
  }


  export type PersonMinAggregateInputType = {
    id?: true
    name?: true
    biography?: true
    dateOfBirth?: true
    dateOfDeath?: true
    gender?: true
    createdAt?: true
    updatedAt?: true
    externalId?: true
    externalType?: true
  }

  export type PersonMaxAggregateInputType = {
    id?: true
    name?: true
    biography?: true
    dateOfBirth?: true
    dateOfDeath?: true
    gender?: true
    createdAt?: true
    updatedAt?: true
    externalId?: true
    externalType?: true
  }

  export type PersonCountAggregateInputType = {
    id?: true
    name?: true
    biography?: true
    dateOfBirth?: true
    dateOfDeath?: true
    gender?: true
    createdAt?: true
    updatedAt?: true
    externalId?: true
    externalType?: true
    additionalData?: true
    _all?: true
  }

  export type PersonAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Person to aggregate.
     */
    where?: PersonWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of People to fetch.
     */
    orderBy?: PersonOrderByWithRelationInput | PersonOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PersonWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` People from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` People.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned People
    **/
    _count?: true | PersonCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PersonMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PersonMaxAggregateInputType
  }

  export type GetPersonAggregateType<T extends PersonAggregateArgs> = {
        [P in keyof T & keyof AggregatePerson]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePerson[P]>
      : GetScalarType<T[P], AggregatePerson[P]>
  }




  export type PersonGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PersonWhereInput
    orderBy?: PersonOrderByWithAggregationInput | PersonOrderByWithAggregationInput[]
    by: PersonScalarFieldEnum[] | PersonScalarFieldEnum
    having?: PersonScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PersonCountAggregateInputType | true
    _min?: PersonMinAggregateInputType
    _max?: PersonMaxAggregateInputType
  }

  export type PersonGroupByOutputType = {
    id: string
    name: string
    biography: string
    dateOfBirth: Date | null
    dateOfDeath: Date | null
    gender: $Enums.Gender
    createdAt: Date
    updatedAt: Date
    externalId: string
    externalType: $Enums.InputProvider
    additionalData: JsonValue
    _count: PersonCountAggregateOutputType | null
    _min: PersonMinAggregateOutputType | null
    _max: PersonMaxAggregateOutputType | null
  }

  type GetPersonGroupByPayload<T extends PersonGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PersonGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PersonGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PersonGroupByOutputType[P]>
            : GetScalarType<T[P], PersonGroupByOutputType[P]>
        }
      >
    >


  export type PersonSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    biography?: boolean
    dateOfBirth?: boolean
    dateOfDeath?: boolean
    gender?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    externalId?: boolean
    externalType?: boolean
    additionalData?: boolean
    actorInMovies?: boolean | Person$actorInMoviesArgs<ExtArgs>
    directorInMovies?: boolean | Person$directorInMoviesArgs<ExtArgs>
    producerInMovies?: boolean | Person$producerInMoviesArgs<ExtArgs>
    _count?: boolean | PersonCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["person"]>

  export type PersonSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    biography?: boolean
    dateOfBirth?: boolean
    dateOfDeath?: boolean
    gender?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    externalId?: boolean
    externalType?: boolean
    additionalData?: boolean
  }, ExtArgs["result"]["person"]>

  export type PersonSelectScalar = {
    id?: boolean
    name?: boolean
    biography?: boolean
    dateOfBirth?: boolean
    dateOfDeath?: boolean
    gender?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    externalId?: boolean
    externalType?: boolean
    additionalData?: boolean
  }

  export type PersonInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    actorInMovies?: boolean | Person$actorInMoviesArgs<ExtArgs>
    directorInMovies?: boolean | Person$directorInMoviesArgs<ExtArgs>
    producerInMovies?: boolean | Person$producerInMoviesArgs<ExtArgs>
    _count?: boolean | PersonCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type PersonIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $PersonPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Person"
    objects: {
      actorInMovies: Prisma.$MovieActorPayload<ExtArgs>[]
      directorInMovies: Prisma.$MovieDirectorPayload<ExtArgs>[]
      producerInMovies: Prisma.$MovieProducerPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      biography: string
      dateOfBirth: Date | null
      dateOfDeath: Date | null
      gender: $Enums.Gender
      createdAt: Date
      updatedAt: Date
      externalId: string
      externalType: $Enums.InputProvider
      additionalData: Prisma.JsonValue
    }, ExtArgs["result"]["person"]>
    composites: {}
  }

  type PersonGetPayload<S extends boolean | null | undefined | PersonDefaultArgs> = $Result.GetResult<Prisma.$PersonPayload, S>

  type PersonCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<PersonFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: PersonCountAggregateInputType | true
    }

  export interface PersonDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Person'], meta: { name: 'Person' } }
    /**
     * Find zero or one Person that matches the filter.
     * @param {PersonFindUniqueArgs} args - Arguments to find a Person
     * @example
     * // Get one Person
     * const person = await prisma.person.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PersonFindUniqueArgs>(args: SelectSubset<T, PersonFindUniqueArgs<ExtArgs>>): Prisma__PersonClient<$Result.GetResult<Prisma.$PersonPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Person that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {PersonFindUniqueOrThrowArgs} args - Arguments to find a Person
     * @example
     * // Get one Person
     * const person = await prisma.person.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PersonFindUniqueOrThrowArgs>(args: SelectSubset<T, PersonFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PersonClient<$Result.GetResult<Prisma.$PersonPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Person that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PersonFindFirstArgs} args - Arguments to find a Person
     * @example
     * // Get one Person
     * const person = await prisma.person.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PersonFindFirstArgs>(args?: SelectSubset<T, PersonFindFirstArgs<ExtArgs>>): Prisma__PersonClient<$Result.GetResult<Prisma.$PersonPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Person that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PersonFindFirstOrThrowArgs} args - Arguments to find a Person
     * @example
     * // Get one Person
     * const person = await prisma.person.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PersonFindFirstOrThrowArgs>(args?: SelectSubset<T, PersonFindFirstOrThrowArgs<ExtArgs>>): Prisma__PersonClient<$Result.GetResult<Prisma.$PersonPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more People that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PersonFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all People
     * const people = await prisma.person.findMany()
     * 
     * // Get first 10 People
     * const people = await prisma.person.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const personWithIdOnly = await prisma.person.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PersonFindManyArgs>(args?: SelectSubset<T, PersonFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PersonPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Person.
     * @param {PersonCreateArgs} args - Arguments to create a Person.
     * @example
     * // Create one Person
     * const Person = await prisma.person.create({
     *   data: {
     *     // ... data to create a Person
     *   }
     * })
     * 
     */
    create<T extends PersonCreateArgs>(args: SelectSubset<T, PersonCreateArgs<ExtArgs>>): Prisma__PersonClient<$Result.GetResult<Prisma.$PersonPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many People.
     * @param {PersonCreateManyArgs} args - Arguments to create many People.
     * @example
     * // Create many People
     * const person = await prisma.person.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PersonCreateManyArgs>(args?: SelectSubset<T, PersonCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many People and returns the data saved in the database.
     * @param {PersonCreateManyAndReturnArgs} args - Arguments to create many People.
     * @example
     * // Create many People
     * const person = await prisma.person.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many People and only return the `id`
     * const personWithIdOnly = await prisma.person.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PersonCreateManyAndReturnArgs>(args?: SelectSubset<T, PersonCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PersonPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Person.
     * @param {PersonDeleteArgs} args - Arguments to delete one Person.
     * @example
     * // Delete one Person
     * const Person = await prisma.person.delete({
     *   where: {
     *     // ... filter to delete one Person
     *   }
     * })
     * 
     */
    delete<T extends PersonDeleteArgs>(args: SelectSubset<T, PersonDeleteArgs<ExtArgs>>): Prisma__PersonClient<$Result.GetResult<Prisma.$PersonPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Person.
     * @param {PersonUpdateArgs} args - Arguments to update one Person.
     * @example
     * // Update one Person
     * const person = await prisma.person.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PersonUpdateArgs>(args: SelectSubset<T, PersonUpdateArgs<ExtArgs>>): Prisma__PersonClient<$Result.GetResult<Prisma.$PersonPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more People.
     * @param {PersonDeleteManyArgs} args - Arguments to filter People to delete.
     * @example
     * // Delete a few People
     * const { count } = await prisma.person.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PersonDeleteManyArgs>(args?: SelectSubset<T, PersonDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more People.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PersonUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many People
     * const person = await prisma.person.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PersonUpdateManyArgs>(args: SelectSubset<T, PersonUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Person.
     * @param {PersonUpsertArgs} args - Arguments to update or create a Person.
     * @example
     * // Update or create a Person
     * const person = await prisma.person.upsert({
     *   create: {
     *     // ... data to create a Person
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Person we want to update
     *   }
     * })
     */
    upsert<T extends PersonUpsertArgs>(args: SelectSubset<T, PersonUpsertArgs<ExtArgs>>): Prisma__PersonClient<$Result.GetResult<Prisma.$PersonPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of People.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PersonCountArgs} args - Arguments to filter People to count.
     * @example
     * // Count the number of People
     * const count = await prisma.person.count({
     *   where: {
     *     // ... the filter for the People we want to count
     *   }
     * })
    **/
    count<T extends PersonCountArgs>(
      args?: Subset<T, PersonCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PersonCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Person.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PersonAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PersonAggregateArgs>(args: Subset<T, PersonAggregateArgs>): Prisma.PrismaPromise<GetPersonAggregateType<T>>

    /**
     * Group by Person.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PersonGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PersonGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PersonGroupByArgs['orderBy'] }
        : { orderBy?: PersonGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PersonGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPersonGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Person model
   */
  readonly fields: PersonFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Person.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PersonClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    actorInMovies<T extends Person$actorInMoviesArgs<ExtArgs> = {}>(args?: Subset<T, Person$actorInMoviesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MovieActorPayload<ExtArgs>, T, "findMany"> | Null>
    directorInMovies<T extends Person$directorInMoviesArgs<ExtArgs> = {}>(args?: Subset<T, Person$directorInMoviesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MovieDirectorPayload<ExtArgs>, T, "findMany"> | Null>
    producerInMovies<T extends Person$producerInMoviesArgs<ExtArgs> = {}>(args?: Subset<T, Person$producerInMoviesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MovieProducerPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Person model
   */ 
  interface PersonFieldRefs {
    readonly id: FieldRef<"Person", 'String'>
    readonly name: FieldRef<"Person", 'String'>
    readonly biography: FieldRef<"Person", 'String'>
    readonly dateOfBirth: FieldRef<"Person", 'DateTime'>
    readonly dateOfDeath: FieldRef<"Person", 'DateTime'>
    readonly gender: FieldRef<"Person", 'Gender'>
    readonly createdAt: FieldRef<"Person", 'DateTime'>
    readonly updatedAt: FieldRef<"Person", 'DateTime'>
    readonly externalId: FieldRef<"Person", 'String'>
    readonly externalType: FieldRef<"Person", 'InputProvider'>
    readonly additionalData: FieldRef<"Person", 'Json'>
  }
    

  // Custom InputTypes
  /**
   * Person findUnique
   */
  export type PersonFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Person
     */
    select?: PersonSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersonInclude<ExtArgs> | null
    /**
     * Filter, which Person to fetch.
     */
    where: PersonWhereUniqueInput
  }

  /**
   * Person findUniqueOrThrow
   */
  export type PersonFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Person
     */
    select?: PersonSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersonInclude<ExtArgs> | null
    /**
     * Filter, which Person to fetch.
     */
    where: PersonWhereUniqueInput
  }

  /**
   * Person findFirst
   */
  export type PersonFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Person
     */
    select?: PersonSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersonInclude<ExtArgs> | null
    /**
     * Filter, which Person to fetch.
     */
    where?: PersonWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of People to fetch.
     */
    orderBy?: PersonOrderByWithRelationInput | PersonOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for People.
     */
    cursor?: PersonWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` People from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` People.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of People.
     */
    distinct?: PersonScalarFieldEnum | PersonScalarFieldEnum[]
  }

  /**
   * Person findFirstOrThrow
   */
  export type PersonFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Person
     */
    select?: PersonSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersonInclude<ExtArgs> | null
    /**
     * Filter, which Person to fetch.
     */
    where?: PersonWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of People to fetch.
     */
    orderBy?: PersonOrderByWithRelationInput | PersonOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for People.
     */
    cursor?: PersonWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` People from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` People.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of People.
     */
    distinct?: PersonScalarFieldEnum | PersonScalarFieldEnum[]
  }

  /**
   * Person findMany
   */
  export type PersonFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Person
     */
    select?: PersonSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersonInclude<ExtArgs> | null
    /**
     * Filter, which People to fetch.
     */
    where?: PersonWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of People to fetch.
     */
    orderBy?: PersonOrderByWithRelationInput | PersonOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing People.
     */
    cursor?: PersonWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` People from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` People.
     */
    skip?: number
    distinct?: PersonScalarFieldEnum | PersonScalarFieldEnum[]
  }

  /**
   * Person create
   */
  export type PersonCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Person
     */
    select?: PersonSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersonInclude<ExtArgs> | null
    /**
     * The data needed to create a Person.
     */
    data: XOR<PersonCreateInput, PersonUncheckedCreateInput>
  }

  /**
   * Person createMany
   */
  export type PersonCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many People.
     */
    data: PersonCreateManyInput | PersonCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Person createManyAndReturn
   */
  export type PersonCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Person
     */
    select?: PersonSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many People.
     */
    data: PersonCreateManyInput | PersonCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Person update
   */
  export type PersonUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Person
     */
    select?: PersonSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersonInclude<ExtArgs> | null
    /**
     * The data needed to update a Person.
     */
    data: XOR<PersonUpdateInput, PersonUncheckedUpdateInput>
    /**
     * Choose, which Person to update.
     */
    where: PersonWhereUniqueInput
  }

  /**
   * Person updateMany
   */
  export type PersonUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update People.
     */
    data: XOR<PersonUpdateManyMutationInput, PersonUncheckedUpdateManyInput>
    /**
     * Filter which People to update
     */
    where?: PersonWhereInput
  }

  /**
   * Person upsert
   */
  export type PersonUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Person
     */
    select?: PersonSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersonInclude<ExtArgs> | null
    /**
     * The filter to search for the Person to update in case it exists.
     */
    where: PersonWhereUniqueInput
    /**
     * In case the Person found by the `where` argument doesn't exist, create a new Person with this data.
     */
    create: XOR<PersonCreateInput, PersonUncheckedCreateInput>
    /**
     * In case the Person was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PersonUpdateInput, PersonUncheckedUpdateInput>
  }

  /**
   * Person delete
   */
  export type PersonDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Person
     */
    select?: PersonSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersonInclude<ExtArgs> | null
    /**
     * Filter which Person to delete.
     */
    where: PersonWhereUniqueInput
  }

  /**
   * Person deleteMany
   */
  export type PersonDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which People to delete
     */
    where?: PersonWhereInput
  }

  /**
   * Person.actorInMovies
   */
  export type Person$actorInMoviesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MovieActor
     */
    select?: MovieActorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MovieActorInclude<ExtArgs> | null
    where?: MovieActorWhereInput
    orderBy?: MovieActorOrderByWithRelationInput | MovieActorOrderByWithRelationInput[]
    cursor?: MovieActorWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MovieActorScalarFieldEnum | MovieActorScalarFieldEnum[]
  }

  /**
   * Person.directorInMovies
   */
  export type Person$directorInMoviesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MovieDirector
     */
    select?: MovieDirectorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MovieDirectorInclude<ExtArgs> | null
    where?: MovieDirectorWhereInput
    orderBy?: MovieDirectorOrderByWithRelationInput | MovieDirectorOrderByWithRelationInput[]
    cursor?: MovieDirectorWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MovieDirectorScalarFieldEnum | MovieDirectorScalarFieldEnum[]
  }

  /**
   * Person.producerInMovies
   */
  export type Person$producerInMoviesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MovieProducer
     */
    select?: MovieProducerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MovieProducerInclude<ExtArgs> | null
    where?: MovieProducerWhereInput
    orderBy?: MovieProducerOrderByWithRelationInput | MovieProducerOrderByWithRelationInput[]
    cursor?: MovieProducerWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MovieProducerScalarFieldEnum | MovieProducerScalarFieldEnum[]
  }

  /**
   * Person without action
   */
  export type PersonDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Person
     */
    select?: PersonSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersonInclude<ExtArgs> | null
  }


  /**
   * Model MovieActor
   */

  export type AggregateMovieActor = {
    _count: MovieActorCountAggregateOutputType | null
    _avg: MovieActorAvgAggregateOutputType | null
    _sum: MovieActorSumAggregateOutputType | null
    _min: MovieActorMinAggregateOutputType | null
    _max: MovieActorMaxAggregateOutputType | null
  }

  export type MovieActorAvgAggregateOutputType = {
    castOrder: number | null
  }

  export type MovieActorSumAggregateOutputType = {
    castOrder: number | null
  }

  export type MovieActorMinAggregateOutputType = {
    personId: string | null
    movieId: string | null
    characterName: string | null
    castOrder: number | null
  }

  export type MovieActorMaxAggregateOutputType = {
    personId: string | null
    movieId: string | null
    characterName: string | null
    castOrder: number | null
  }

  export type MovieActorCountAggregateOutputType = {
    personId: number
    movieId: number
    characterName: number
    castOrder: number
    _all: number
  }


  export type MovieActorAvgAggregateInputType = {
    castOrder?: true
  }

  export type MovieActorSumAggregateInputType = {
    castOrder?: true
  }

  export type MovieActorMinAggregateInputType = {
    personId?: true
    movieId?: true
    characterName?: true
    castOrder?: true
  }

  export type MovieActorMaxAggregateInputType = {
    personId?: true
    movieId?: true
    characterName?: true
    castOrder?: true
  }

  export type MovieActorCountAggregateInputType = {
    personId?: true
    movieId?: true
    characterName?: true
    castOrder?: true
    _all?: true
  }

  export type MovieActorAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MovieActor to aggregate.
     */
    where?: MovieActorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MovieActors to fetch.
     */
    orderBy?: MovieActorOrderByWithRelationInput | MovieActorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MovieActorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MovieActors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MovieActors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MovieActors
    **/
    _count?: true | MovieActorCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MovieActorAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MovieActorSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MovieActorMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MovieActorMaxAggregateInputType
  }

  export type GetMovieActorAggregateType<T extends MovieActorAggregateArgs> = {
        [P in keyof T & keyof AggregateMovieActor]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMovieActor[P]>
      : GetScalarType<T[P], AggregateMovieActor[P]>
  }




  export type MovieActorGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MovieActorWhereInput
    orderBy?: MovieActorOrderByWithAggregationInput | MovieActorOrderByWithAggregationInput[]
    by: MovieActorScalarFieldEnum[] | MovieActorScalarFieldEnum
    having?: MovieActorScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MovieActorCountAggregateInputType | true
    _avg?: MovieActorAvgAggregateInputType
    _sum?: MovieActorSumAggregateInputType
    _min?: MovieActorMinAggregateInputType
    _max?: MovieActorMaxAggregateInputType
  }

  export type MovieActorGroupByOutputType = {
    personId: string
    movieId: string
    characterName: string
    castOrder: number
    _count: MovieActorCountAggregateOutputType | null
    _avg: MovieActorAvgAggregateOutputType | null
    _sum: MovieActorSumAggregateOutputType | null
    _min: MovieActorMinAggregateOutputType | null
    _max: MovieActorMaxAggregateOutputType | null
  }

  type GetMovieActorGroupByPayload<T extends MovieActorGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MovieActorGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MovieActorGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MovieActorGroupByOutputType[P]>
            : GetScalarType<T[P], MovieActorGroupByOutputType[P]>
        }
      >
    >


  export type MovieActorSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    personId?: boolean
    movieId?: boolean
    characterName?: boolean
    castOrder?: boolean
    person?: boolean | PersonDefaultArgs<ExtArgs>
    movie?: boolean | MovieDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["movieActor"]>

  export type MovieActorSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    personId?: boolean
    movieId?: boolean
    characterName?: boolean
    castOrder?: boolean
    person?: boolean | PersonDefaultArgs<ExtArgs>
    movie?: boolean | MovieDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["movieActor"]>

  export type MovieActorSelectScalar = {
    personId?: boolean
    movieId?: boolean
    characterName?: boolean
    castOrder?: boolean
  }

  export type MovieActorInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    person?: boolean | PersonDefaultArgs<ExtArgs>
    movie?: boolean | MovieDefaultArgs<ExtArgs>
  }
  export type MovieActorIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    person?: boolean | PersonDefaultArgs<ExtArgs>
    movie?: boolean | MovieDefaultArgs<ExtArgs>
  }

  export type $MovieActorPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "MovieActor"
    objects: {
      person: Prisma.$PersonPayload<ExtArgs>
      movie: Prisma.$MoviePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      personId: string
      movieId: string
      characterName: string
      castOrder: number
    }, ExtArgs["result"]["movieActor"]>
    composites: {}
  }

  type MovieActorGetPayload<S extends boolean | null | undefined | MovieActorDefaultArgs> = $Result.GetResult<Prisma.$MovieActorPayload, S>

  type MovieActorCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<MovieActorFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: MovieActorCountAggregateInputType | true
    }

  export interface MovieActorDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['MovieActor'], meta: { name: 'MovieActor' } }
    /**
     * Find zero or one MovieActor that matches the filter.
     * @param {MovieActorFindUniqueArgs} args - Arguments to find a MovieActor
     * @example
     * // Get one MovieActor
     * const movieActor = await prisma.movieActor.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MovieActorFindUniqueArgs>(args: SelectSubset<T, MovieActorFindUniqueArgs<ExtArgs>>): Prisma__MovieActorClient<$Result.GetResult<Prisma.$MovieActorPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one MovieActor that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {MovieActorFindUniqueOrThrowArgs} args - Arguments to find a MovieActor
     * @example
     * // Get one MovieActor
     * const movieActor = await prisma.movieActor.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MovieActorFindUniqueOrThrowArgs>(args: SelectSubset<T, MovieActorFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MovieActorClient<$Result.GetResult<Prisma.$MovieActorPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first MovieActor that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MovieActorFindFirstArgs} args - Arguments to find a MovieActor
     * @example
     * // Get one MovieActor
     * const movieActor = await prisma.movieActor.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MovieActorFindFirstArgs>(args?: SelectSubset<T, MovieActorFindFirstArgs<ExtArgs>>): Prisma__MovieActorClient<$Result.GetResult<Prisma.$MovieActorPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first MovieActor that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MovieActorFindFirstOrThrowArgs} args - Arguments to find a MovieActor
     * @example
     * // Get one MovieActor
     * const movieActor = await prisma.movieActor.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MovieActorFindFirstOrThrowArgs>(args?: SelectSubset<T, MovieActorFindFirstOrThrowArgs<ExtArgs>>): Prisma__MovieActorClient<$Result.GetResult<Prisma.$MovieActorPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more MovieActors that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MovieActorFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MovieActors
     * const movieActors = await prisma.movieActor.findMany()
     * 
     * // Get first 10 MovieActors
     * const movieActors = await prisma.movieActor.findMany({ take: 10 })
     * 
     * // Only select the `personId`
     * const movieActorWithPersonIdOnly = await prisma.movieActor.findMany({ select: { personId: true } })
     * 
     */
    findMany<T extends MovieActorFindManyArgs>(args?: SelectSubset<T, MovieActorFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MovieActorPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a MovieActor.
     * @param {MovieActorCreateArgs} args - Arguments to create a MovieActor.
     * @example
     * // Create one MovieActor
     * const MovieActor = await prisma.movieActor.create({
     *   data: {
     *     // ... data to create a MovieActor
     *   }
     * })
     * 
     */
    create<T extends MovieActorCreateArgs>(args: SelectSubset<T, MovieActorCreateArgs<ExtArgs>>): Prisma__MovieActorClient<$Result.GetResult<Prisma.$MovieActorPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many MovieActors.
     * @param {MovieActorCreateManyArgs} args - Arguments to create many MovieActors.
     * @example
     * // Create many MovieActors
     * const movieActor = await prisma.movieActor.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MovieActorCreateManyArgs>(args?: SelectSubset<T, MovieActorCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many MovieActors and returns the data saved in the database.
     * @param {MovieActorCreateManyAndReturnArgs} args - Arguments to create many MovieActors.
     * @example
     * // Create many MovieActors
     * const movieActor = await prisma.movieActor.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many MovieActors and only return the `personId`
     * const movieActorWithPersonIdOnly = await prisma.movieActor.createManyAndReturn({ 
     *   select: { personId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MovieActorCreateManyAndReturnArgs>(args?: SelectSubset<T, MovieActorCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MovieActorPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a MovieActor.
     * @param {MovieActorDeleteArgs} args - Arguments to delete one MovieActor.
     * @example
     * // Delete one MovieActor
     * const MovieActor = await prisma.movieActor.delete({
     *   where: {
     *     // ... filter to delete one MovieActor
     *   }
     * })
     * 
     */
    delete<T extends MovieActorDeleteArgs>(args: SelectSubset<T, MovieActorDeleteArgs<ExtArgs>>): Prisma__MovieActorClient<$Result.GetResult<Prisma.$MovieActorPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one MovieActor.
     * @param {MovieActorUpdateArgs} args - Arguments to update one MovieActor.
     * @example
     * // Update one MovieActor
     * const movieActor = await prisma.movieActor.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MovieActorUpdateArgs>(args: SelectSubset<T, MovieActorUpdateArgs<ExtArgs>>): Prisma__MovieActorClient<$Result.GetResult<Prisma.$MovieActorPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more MovieActors.
     * @param {MovieActorDeleteManyArgs} args - Arguments to filter MovieActors to delete.
     * @example
     * // Delete a few MovieActors
     * const { count } = await prisma.movieActor.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MovieActorDeleteManyArgs>(args?: SelectSubset<T, MovieActorDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MovieActors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MovieActorUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MovieActors
     * const movieActor = await prisma.movieActor.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MovieActorUpdateManyArgs>(args: SelectSubset<T, MovieActorUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one MovieActor.
     * @param {MovieActorUpsertArgs} args - Arguments to update or create a MovieActor.
     * @example
     * // Update or create a MovieActor
     * const movieActor = await prisma.movieActor.upsert({
     *   create: {
     *     // ... data to create a MovieActor
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MovieActor we want to update
     *   }
     * })
     */
    upsert<T extends MovieActorUpsertArgs>(args: SelectSubset<T, MovieActorUpsertArgs<ExtArgs>>): Prisma__MovieActorClient<$Result.GetResult<Prisma.$MovieActorPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of MovieActors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MovieActorCountArgs} args - Arguments to filter MovieActors to count.
     * @example
     * // Count the number of MovieActors
     * const count = await prisma.movieActor.count({
     *   where: {
     *     // ... the filter for the MovieActors we want to count
     *   }
     * })
    **/
    count<T extends MovieActorCountArgs>(
      args?: Subset<T, MovieActorCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MovieActorCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MovieActor.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MovieActorAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MovieActorAggregateArgs>(args: Subset<T, MovieActorAggregateArgs>): Prisma.PrismaPromise<GetMovieActorAggregateType<T>>

    /**
     * Group by MovieActor.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MovieActorGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MovieActorGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MovieActorGroupByArgs['orderBy'] }
        : { orderBy?: MovieActorGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MovieActorGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMovieActorGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the MovieActor model
   */
  readonly fields: MovieActorFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for MovieActor.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MovieActorClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    person<T extends PersonDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PersonDefaultArgs<ExtArgs>>): Prisma__PersonClient<$Result.GetResult<Prisma.$PersonPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    movie<T extends MovieDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MovieDefaultArgs<ExtArgs>>): Prisma__MovieClient<$Result.GetResult<Prisma.$MoviePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the MovieActor model
   */ 
  interface MovieActorFieldRefs {
    readonly personId: FieldRef<"MovieActor", 'String'>
    readonly movieId: FieldRef<"MovieActor", 'String'>
    readonly characterName: FieldRef<"MovieActor", 'String'>
    readonly castOrder: FieldRef<"MovieActor", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * MovieActor findUnique
   */
  export type MovieActorFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MovieActor
     */
    select?: MovieActorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MovieActorInclude<ExtArgs> | null
    /**
     * Filter, which MovieActor to fetch.
     */
    where: MovieActorWhereUniqueInput
  }

  /**
   * MovieActor findUniqueOrThrow
   */
  export type MovieActorFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MovieActor
     */
    select?: MovieActorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MovieActorInclude<ExtArgs> | null
    /**
     * Filter, which MovieActor to fetch.
     */
    where: MovieActorWhereUniqueInput
  }

  /**
   * MovieActor findFirst
   */
  export type MovieActorFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MovieActor
     */
    select?: MovieActorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MovieActorInclude<ExtArgs> | null
    /**
     * Filter, which MovieActor to fetch.
     */
    where?: MovieActorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MovieActors to fetch.
     */
    orderBy?: MovieActorOrderByWithRelationInput | MovieActorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MovieActors.
     */
    cursor?: MovieActorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MovieActors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MovieActors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MovieActors.
     */
    distinct?: MovieActorScalarFieldEnum | MovieActorScalarFieldEnum[]
  }

  /**
   * MovieActor findFirstOrThrow
   */
  export type MovieActorFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MovieActor
     */
    select?: MovieActorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MovieActorInclude<ExtArgs> | null
    /**
     * Filter, which MovieActor to fetch.
     */
    where?: MovieActorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MovieActors to fetch.
     */
    orderBy?: MovieActorOrderByWithRelationInput | MovieActorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MovieActors.
     */
    cursor?: MovieActorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MovieActors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MovieActors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MovieActors.
     */
    distinct?: MovieActorScalarFieldEnum | MovieActorScalarFieldEnum[]
  }

  /**
   * MovieActor findMany
   */
  export type MovieActorFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MovieActor
     */
    select?: MovieActorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MovieActorInclude<ExtArgs> | null
    /**
     * Filter, which MovieActors to fetch.
     */
    where?: MovieActorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MovieActors to fetch.
     */
    orderBy?: MovieActorOrderByWithRelationInput | MovieActorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MovieActors.
     */
    cursor?: MovieActorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MovieActors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MovieActors.
     */
    skip?: number
    distinct?: MovieActorScalarFieldEnum | MovieActorScalarFieldEnum[]
  }

  /**
   * MovieActor create
   */
  export type MovieActorCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MovieActor
     */
    select?: MovieActorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MovieActorInclude<ExtArgs> | null
    /**
     * The data needed to create a MovieActor.
     */
    data: XOR<MovieActorCreateInput, MovieActorUncheckedCreateInput>
  }

  /**
   * MovieActor createMany
   */
  export type MovieActorCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many MovieActors.
     */
    data: MovieActorCreateManyInput | MovieActorCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * MovieActor createManyAndReturn
   */
  export type MovieActorCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MovieActor
     */
    select?: MovieActorSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many MovieActors.
     */
    data: MovieActorCreateManyInput | MovieActorCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MovieActorIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * MovieActor update
   */
  export type MovieActorUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MovieActor
     */
    select?: MovieActorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MovieActorInclude<ExtArgs> | null
    /**
     * The data needed to update a MovieActor.
     */
    data: XOR<MovieActorUpdateInput, MovieActorUncheckedUpdateInput>
    /**
     * Choose, which MovieActor to update.
     */
    where: MovieActorWhereUniqueInput
  }

  /**
   * MovieActor updateMany
   */
  export type MovieActorUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update MovieActors.
     */
    data: XOR<MovieActorUpdateManyMutationInput, MovieActorUncheckedUpdateManyInput>
    /**
     * Filter which MovieActors to update
     */
    where?: MovieActorWhereInput
  }

  /**
   * MovieActor upsert
   */
  export type MovieActorUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MovieActor
     */
    select?: MovieActorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MovieActorInclude<ExtArgs> | null
    /**
     * The filter to search for the MovieActor to update in case it exists.
     */
    where: MovieActorWhereUniqueInput
    /**
     * In case the MovieActor found by the `where` argument doesn't exist, create a new MovieActor with this data.
     */
    create: XOR<MovieActorCreateInput, MovieActorUncheckedCreateInput>
    /**
     * In case the MovieActor was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MovieActorUpdateInput, MovieActorUncheckedUpdateInput>
  }

  /**
   * MovieActor delete
   */
  export type MovieActorDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MovieActor
     */
    select?: MovieActorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MovieActorInclude<ExtArgs> | null
    /**
     * Filter which MovieActor to delete.
     */
    where: MovieActorWhereUniqueInput
  }

  /**
   * MovieActor deleteMany
   */
  export type MovieActorDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MovieActors to delete
     */
    where?: MovieActorWhereInput
  }

  /**
   * MovieActor without action
   */
  export type MovieActorDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MovieActor
     */
    select?: MovieActorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MovieActorInclude<ExtArgs> | null
  }


  /**
   * Model MovieDirector
   */

  export type AggregateMovieDirector = {
    _count: MovieDirectorCountAggregateOutputType | null
    _min: MovieDirectorMinAggregateOutputType | null
    _max: MovieDirectorMaxAggregateOutputType | null
  }

  export type MovieDirectorMinAggregateOutputType = {
    personId: string | null
    movieId: string | null
    type: $Enums.DirectorType | null
  }

  export type MovieDirectorMaxAggregateOutputType = {
    personId: string | null
    movieId: string | null
    type: $Enums.DirectorType | null
  }

  export type MovieDirectorCountAggregateOutputType = {
    personId: number
    movieId: number
    type: number
    _all: number
  }


  export type MovieDirectorMinAggregateInputType = {
    personId?: true
    movieId?: true
    type?: true
  }

  export type MovieDirectorMaxAggregateInputType = {
    personId?: true
    movieId?: true
    type?: true
  }

  export type MovieDirectorCountAggregateInputType = {
    personId?: true
    movieId?: true
    type?: true
    _all?: true
  }

  export type MovieDirectorAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MovieDirector to aggregate.
     */
    where?: MovieDirectorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MovieDirectors to fetch.
     */
    orderBy?: MovieDirectorOrderByWithRelationInput | MovieDirectorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MovieDirectorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MovieDirectors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MovieDirectors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MovieDirectors
    **/
    _count?: true | MovieDirectorCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MovieDirectorMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MovieDirectorMaxAggregateInputType
  }

  export type GetMovieDirectorAggregateType<T extends MovieDirectorAggregateArgs> = {
        [P in keyof T & keyof AggregateMovieDirector]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMovieDirector[P]>
      : GetScalarType<T[P], AggregateMovieDirector[P]>
  }




  export type MovieDirectorGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MovieDirectorWhereInput
    orderBy?: MovieDirectorOrderByWithAggregationInput | MovieDirectorOrderByWithAggregationInput[]
    by: MovieDirectorScalarFieldEnum[] | MovieDirectorScalarFieldEnum
    having?: MovieDirectorScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MovieDirectorCountAggregateInputType | true
    _min?: MovieDirectorMinAggregateInputType
    _max?: MovieDirectorMaxAggregateInputType
  }

  export type MovieDirectorGroupByOutputType = {
    personId: string
    movieId: string
    type: $Enums.DirectorType
    _count: MovieDirectorCountAggregateOutputType | null
    _min: MovieDirectorMinAggregateOutputType | null
    _max: MovieDirectorMaxAggregateOutputType | null
  }

  type GetMovieDirectorGroupByPayload<T extends MovieDirectorGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MovieDirectorGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MovieDirectorGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MovieDirectorGroupByOutputType[P]>
            : GetScalarType<T[P], MovieDirectorGroupByOutputType[P]>
        }
      >
    >


  export type MovieDirectorSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    personId?: boolean
    movieId?: boolean
    type?: boolean
    person?: boolean | PersonDefaultArgs<ExtArgs>
    movie?: boolean | MovieDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["movieDirector"]>

  export type MovieDirectorSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    personId?: boolean
    movieId?: boolean
    type?: boolean
    person?: boolean | PersonDefaultArgs<ExtArgs>
    movie?: boolean | MovieDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["movieDirector"]>

  export type MovieDirectorSelectScalar = {
    personId?: boolean
    movieId?: boolean
    type?: boolean
  }

  export type MovieDirectorInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    person?: boolean | PersonDefaultArgs<ExtArgs>
    movie?: boolean | MovieDefaultArgs<ExtArgs>
  }
  export type MovieDirectorIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    person?: boolean | PersonDefaultArgs<ExtArgs>
    movie?: boolean | MovieDefaultArgs<ExtArgs>
  }

  export type $MovieDirectorPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "MovieDirector"
    objects: {
      person: Prisma.$PersonPayload<ExtArgs>
      movie: Prisma.$MoviePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      personId: string
      movieId: string
      type: $Enums.DirectorType
    }, ExtArgs["result"]["movieDirector"]>
    composites: {}
  }

  type MovieDirectorGetPayload<S extends boolean | null | undefined | MovieDirectorDefaultArgs> = $Result.GetResult<Prisma.$MovieDirectorPayload, S>

  type MovieDirectorCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<MovieDirectorFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: MovieDirectorCountAggregateInputType | true
    }

  export interface MovieDirectorDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['MovieDirector'], meta: { name: 'MovieDirector' } }
    /**
     * Find zero or one MovieDirector that matches the filter.
     * @param {MovieDirectorFindUniqueArgs} args - Arguments to find a MovieDirector
     * @example
     * // Get one MovieDirector
     * const movieDirector = await prisma.movieDirector.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MovieDirectorFindUniqueArgs>(args: SelectSubset<T, MovieDirectorFindUniqueArgs<ExtArgs>>): Prisma__MovieDirectorClient<$Result.GetResult<Prisma.$MovieDirectorPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one MovieDirector that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {MovieDirectorFindUniqueOrThrowArgs} args - Arguments to find a MovieDirector
     * @example
     * // Get one MovieDirector
     * const movieDirector = await prisma.movieDirector.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MovieDirectorFindUniqueOrThrowArgs>(args: SelectSubset<T, MovieDirectorFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MovieDirectorClient<$Result.GetResult<Prisma.$MovieDirectorPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first MovieDirector that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MovieDirectorFindFirstArgs} args - Arguments to find a MovieDirector
     * @example
     * // Get one MovieDirector
     * const movieDirector = await prisma.movieDirector.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MovieDirectorFindFirstArgs>(args?: SelectSubset<T, MovieDirectorFindFirstArgs<ExtArgs>>): Prisma__MovieDirectorClient<$Result.GetResult<Prisma.$MovieDirectorPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first MovieDirector that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MovieDirectorFindFirstOrThrowArgs} args - Arguments to find a MovieDirector
     * @example
     * // Get one MovieDirector
     * const movieDirector = await prisma.movieDirector.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MovieDirectorFindFirstOrThrowArgs>(args?: SelectSubset<T, MovieDirectorFindFirstOrThrowArgs<ExtArgs>>): Prisma__MovieDirectorClient<$Result.GetResult<Prisma.$MovieDirectorPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more MovieDirectors that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MovieDirectorFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MovieDirectors
     * const movieDirectors = await prisma.movieDirector.findMany()
     * 
     * // Get first 10 MovieDirectors
     * const movieDirectors = await prisma.movieDirector.findMany({ take: 10 })
     * 
     * // Only select the `personId`
     * const movieDirectorWithPersonIdOnly = await prisma.movieDirector.findMany({ select: { personId: true } })
     * 
     */
    findMany<T extends MovieDirectorFindManyArgs>(args?: SelectSubset<T, MovieDirectorFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MovieDirectorPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a MovieDirector.
     * @param {MovieDirectorCreateArgs} args - Arguments to create a MovieDirector.
     * @example
     * // Create one MovieDirector
     * const MovieDirector = await prisma.movieDirector.create({
     *   data: {
     *     // ... data to create a MovieDirector
     *   }
     * })
     * 
     */
    create<T extends MovieDirectorCreateArgs>(args: SelectSubset<T, MovieDirectorCreateArgs<ExtArgs>>): Prisma__MovieDirectorClient<$Result.GetResult<Prisma.$MovieDirectorPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many MovieDirectors.
     * @param {MovieDirectorCreateManyArgs} args - Arguments to create many MovieDirectors.
     * @example
     * // Create many MovieDirectors
     * const movieDirector = await prisma.movieDirector.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MovieDirectorCreateManyArgs>(args?: SelectSubset<T, MovieDirectorCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many MovieDirectors and returns the data saved in the database.
     * @param {MovieDirectorCreateManyAndReturnArgs} args - Arguments to create many MovieDirectors.
     * @example
     * // Create many MovieDirectors
     * const movieDirector = await prisma.movieDirector.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many MovieDirectors and only return the `personId`
     * const movieDirectorWithPersonIdOnly = await prisma.movieDirector.createManyAndReturn({ 
     *   select: { personId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MovieDirectorCreateManyAndReturnArgs>(args?: SelectSubset<T, MovieDirectorCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MovieDirectorPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a MovieDirector.
     * @param {MovieDirectorDeleteArgs} args - Arguments to delete one MovieDirector.
     * @example
     * // Delete one MovieDirector
     * const MovieDirector = await prisma.movieDirector.delete({
     *   where: {
     *     // ... filter to delete one MovieDirector
     *   }
     * })
     * 
     */
    delete<T extends MovieDirectorDeleteArgs>(args: SelectSubset<T, MovieDirectorDeleteArgs<ExtArgs>>): Prisma__MovieDirectorClient<$Result.GetResult<Prisma.$MovieDirectorPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one MovieDirector.
     * @param {MovieDirectorUpdateArgs} args - Arguments to update one MovieDirector.
     * @example
     * // Update one MovieDirector
     * const movieDirector = await prisma.movieDirector.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MovieDirectorUpdateArgs>(args: SelectSubset<T, MovieDirectorUpdateArgs<ExtArgs>>): Prisma__MovieDirectorClient<$Result.GetResult<Prisma.$MovieDirectorPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more MovieDirectors.
     * @param {MovieDirectorDeleteManyArgs} args - Arguments to filter MovieDirectors to delete.
     * @example
     * // Delete a few MovieDirectors
     * const { count } = await prisma.movieDirector.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MovieDirectorDeleteManyArgs>(args?: SelectSubset<T, MovieDirectorDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MovieDirectors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MovieDirectorUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MovieDirectors
     * const movieDirector = await prisma.movieDirector.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MovieDirectorUpdateManyArgs>(args: SelectSubset<T, MovieDirectorUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one MovieDirector.
     * @param {MovieDirectorUpsertArgs} args - Arguments to update or create a MovieDirector.
     * @example
     * // Update or create a MovieDirector
     * const movieDirector = await prisma.movieDirector.upsert({
     *   create: {
     *     // ... data to create a MovieDirector
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MovieDirector we want to update
     *   }
     * })
     */
    upsert<T extends MovieDirectorUpsertArgs>(args: SelectSubset<T, MovieDirectorUpsertArgs<ExtArgs>>): Prisma__MovieDirectorClient<$Result.GetResult<Prisma.$MovieDirectorPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of MovieDirectors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MovieDirectorCountArgs} args - Arguments to filter MovieDirectors to count.
     * @example
     * // Count the number of MovieDirectors
     * const count = await prisma.movieDirector.count({
     *   where: {
     *     // ... the filter for the MovieDirectors we want to count
     *   }
     * })
    **/
    count<T extends MovieDirectorCountArgs>(
      args?: Subset<T, MovieDirectorCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MovieDirectorCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MovieDirector.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MovieDirectorAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MovieDirectorAggregateArgs>(args: Subset<T, MovieDirectorAggregateArgs>): Prisma.PrismaPromise<GetMovieDirectorAggregateType<T>>

    /**
     * Group by MovieDirector.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MovieDirectorGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MovieDirectorGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MovieDirectorGroupByArgs['orderBy'] }
        : { orderBy?: MovieDirectorGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MovieDirectorGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMovieDirectorGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the MovieDirector model
   */
  readonly fields: MovieDirectorFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for MovieDirector.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MovieDirectorClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    person<T extends PersonDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PersonDefaultArgs<ExtArgs>>): Prisma__PersonClient<$Result.GetResult<Prisma.$PersonPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    movie<T extends MovieDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MovieDefaultArgs<ExtArgs>>): Prisma__MovieClient<$Result.GetResult<Prisma.$MoviePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the MovieDirector model
   */ 
  interface MovieDirectorFieldRefs {
    readonly personId: FieldRef<"MovieDirector", 'String'>
    readonly movieId: FieldRef<"MovieDirector", 'String'>
    readonly type: FieldRef<"MovieDirector", 'DirectorType'>
  }
    

  // Custom InputTypes
  /**
   * MovieDirector findUnique
   */
  export type MovieDirectorFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MovieDirector
     */
    select?: MovieDirectorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MovieDirectorInclude<ExtArgs> | null
    /**
     * Filter, which MovieDirector to fetch.
     */
    where: MovieDirectorWhereUniqueInput
  }

  /**
   * MovieDirector findUniqueOrThrow
   */
  export type MovieDirectorFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MovieDirector
     */
    select?: MovieDirectorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MovieDirectorInclude<ExtArgs> | null
    /**
     * Filter, which MovieDirector to fetch.
     */
    where: MovieDirectorWhereUniqueInput
  }

  /**
   * MovieDirector findFirst
   */
  export type MovieDirectorFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MovieDirector
     */
    select?: MovieDirectorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MovieDirectorInclude<ExtArgs> | null
    /**
     * Filter, which MovieDirector to fetch.
     */
    where?: MovieDirectorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MovieDirectors to fetch.
     */
    orderBy?: MovieDirectorOrderByWithRelationInput | MovieDirectorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MovieDirectors.
     */
    cursor?: MovieDirectorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MovieDirectors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MovieDirectors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MovieDirectors.
     */
    distinct?: MovieDirectorScalarFieldEnum | MovieDirectorScalarFieldEnum[]
  }

  /**
   * MovieDirector findFirstOrThrow
   */
  export type MovieDirectorFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MovieDirector
     */
    select?: MovieDirectorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MovieDirectorInclude<ExtArgs> | null
    /**
     * Filter, which MovieDirector to fetch.
     */
    where?: MovieDirectorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MovieDirectors to fetch.
     */
    orderBy?: MovieDirectorOrderByWithRelationInput | MovieDirectorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MovieDirectors.
     */
    cursor?: MovieDirectorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MovieDirectors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MovieDirectors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MovieDirectors.
     */
    distinct?: MovieDirectorScalarFieldEnum | MovieDirectorScalarFieldEnum[]
  }

  /**
   * MovieDirector findMany
   */
  export type MovieDirectorFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MovieDirector
     */
    select?: MovieDirectorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MovieDirectorInclude<ExtArgs> | null
    /**
     * Filter, which MovieDirectors to fetch.
     */
    where?: MovieDirectorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MovieDirectors to fetch.
     */
    orderBy?: MovieDirectorOrderByWithRelationInput | MovieDirectorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MovieDirectors.
     */
    cursor?: MovieDirectorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MovieDirectors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MovieDirectors.
     */
    skip?: number
    distinct?: MovieDirectorScalarFieldEnum | MovieDirectorScalarFieldEnum[]
  }

  /**
   * MovieDirector create
   */
  export type MovieDirectorCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MovieDirector
     */
    select?: MovieDirectorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MovieDirectorInclude<ExtArgs> | null
    /**
     * The data needed to create a MovieDirector.
     */
    data: XOR<MovieDirectorCreateInput, MovieDirectorUncheckedCreateInput>
  }

  /**
   * MovieDirector createMany
   */
  export type MovieDirectorCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many MovieDirectors.
     */
    data: MovieDirectorCreateManyInput | MovieDirectorCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * MovieDirector createManyAndReturn
   */
  export type MovieDirectorCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MovieDirector
     */
    select?: MovieDirectorSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many MovieDirectors.
     */
    data: MovieDirectorCreateManyInput | MovieDirectorCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MovieDirectorIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * MovieDirector update
   */
  export type MovieDirectorUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MovieDirector
     */
    select?: MovieDirectorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MovieDirectorInclude<ExtArgs> | null
    /**
     * The data needed to update a MovieDirector.
     */
    data: XOR<MovieDirectorUpdateInput, MovieDirectorUncheckedUpdateInput>
    /**
     * Choose, which MovieDirector to update.
     */
    where: MovieDirectorWhereUniqueInput
  }

  /**
   * MovieDirector updateMany
   */
  export type MovieDirectorUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update MovieDirectors.
     */
    data: XOR<MovieDirectorUpdateManyMutationInput, MovieDirectorUncheckedUpdateManyInput>
    /**
     * Filter which MovieDirectors to update
     */
    where?: MovieDirectorWhereInput
  }

  /**
   * MovieDirector upsert
   */
  export type MovieDirectorUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MovieDirector
     */
    select?: MovieDirectorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MovieDirectorInclude<ExtArgs> | null
    /**
     * The filter to search for the MovieDirector to update in case it exists.
     */
    where: MovieDirectorWhereUniqueInput
    /**
     * In case the MovieDirector found by the `where` argument doesn't exist, create a new MovieDirector with this data.
     */
    create: XOR<MovieDirectorCreateInput, MovieDirectorUncheckedCreateInput>
    /**
     * In case the MovieDirector was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MovieDirectorUpdateInput, MovieDirectorUncheckedUpdateInput>
  }

  /**
   * MovieDirector delete
   */
  export type MovieDirectorDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MovieDirector
     */
    select?: MovieDirectorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MovieDirectorInclude<ExtArgs> | null
    /**
     * Filter which MovieDirector to delete.
     */
    where: MovieDirectorWhereUniqueInput
  }

  /**
   * MovieDirector deleteMany
   */
  export type MovieDirectorDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MovieDirectors to delete
     */
    where?: MovieDirectorWhereInput
  }

  /**
   * MovieDirector without action
   */
  export type MovieDirectorDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MovieDirector
     */
    select?: MovieDirectorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MovieDirectorInclude<ExtArgs> | null
  }


  /**
   * Model MovieProducer
   */

  export type AggregateMovieProducer = {
    _count: MovieProducerCountAggregateOutputType | null
    _min: MovieProducerMinAggregateOutputType | null
    _max: MovieProducerMaxAggregateOutputType | null
  }

  export type MovieProducerMinAggregateOutputType = {
    personId: string | null
    movieId: string | null
    type: $Enums.ProducerType | null
  }

  export type MovieProducerMaxAggregateOutputType = {
    personId: string | null
    movieId: string | null
    type: $Enums.ProducerType | null
  }

  export type MovieProducerCountAggregateOutputType = {
    personId: number
    movieId: number
    type: number
    _all: number
  }


  export type MovieProducerMinAggregateInputType = {
    personId?: true
    movieId?: true
    type?: true
  }

  export type MovieProducerMaxAggregateInputType = {
    personId?: true
    movieId?: true
    type?: true
  }

  export type MovieProducerCountAggregateInputType = {
    personId?: true
    movieId?: true
    type?: true
    _all?: true
  }

  export type MovieProducerAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MovieProducer to aggregate.
     */
    where?: MovieProducerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MovieProducers to fetch.
     */
    orderBy?: MovieProducerOrderByWithRelationInput | MovieProducerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MovieProducerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MovieProducers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MovieProducers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MovieProducers
    **/
    _count?: true | MovieProducerCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MovieProducerMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MovieProducerMaxAggregateInputType
  }

  export type GetMovieProducerAggregateType<T extends MovieProducerAggregateArgs> = {
        [P in keyof T & keyof AggregateMovieProducer]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMovieProducer[P]>
      : GetScalarType<T[P], AggregateMovieProducer[P]>
  }




  export type MovieProducerGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MovieProducerWhereInput
    orderBy?: MovieProducerOrderByWithAggregationInput | MovieProducerOrderByWithAggregationInput[]
    by: MovieProducerScalarFieldEnum[] | MovieProducerScalarFieldEnum
    having?: MovieProducerScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MovieProducerCountAggregateInputType | true
    _min?: MovieProducerMinAggregateInputType
    _max?: MovieProducerMaxAggregateInputType
  }

  export type MovieProducerGroupByOutputType = {
    personId: string
    movieId: string
    type: $Enums.ProducerType
    _count: MovieProducerCountAggregateOutputType | null
    _min: MovieProducerMinAggregateOutputType | null
    _max: MovieProducerMaxAggregateOutputType | null
  }

  type GetMovieProducerGroupByPayload<T extends MovieProducerGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MovieProducerGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MovieProducerGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MovieProducerGroupByOutputType[P]>
            : GetScalarType<T[P], MovieProducerGroupByOutputType[P]>
        }
      >
    >


  export type MovieProducerSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    personId?: boolean
    movieId?: boolean
    type?: boolean
    person?: boolean | PersonDefaultArgs<ExtArgs>
    movie?: boolean | MovieDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["movieProducer"]>

  export type MovieProducerSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    personId?: boolean
    movieId?: boolean
    type?: boolean
    person?: boolean | PersonDefaultArgs<ExtArgs>
    movie?: boolean | MovieDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["movieProducer"]>

  export type MovieProducerSelectScalar = {
    personId?: boolean
    movieId?: boolean
    type?: boolean
  }

  export type MovieProducerInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    person?: boolean | PersonDefaultArgs<ExtArgs>
    movie?: boolean | MovieDefaultArgs<ExtArgs>
  }
  export type MovieProducerIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    person?: boolean | PersonDefaultArgs<ExtArgs>
    movie?: boolean | MovieDefaultArgs<ExtArgs>
  }

  export type $MovieProducerPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "MovieProducer"
    objects: {
      person: Prisma.$PersonPayload<ExtArgs>
      movie: Prisma.$MoviePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      personId: string
      movieId: string
      type: $Enums.ProducerType
    }, ExtArgs["result"]["movieProducer"]>
    composites: {}
  }

  type MovieProducerGetPayload<S extends boolean | null | undefined | MovieProducerDefaultArgs> = $Result.GetResult<Prisma.$MovieProducerPayload, S>

  type MovieProducerCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<MovieProducerFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: MovieProducerCountAggregateInputType | true
    }

  export interface MovieProducerDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['MovieProducer'], meta: { name: 'MovieProducer' } }
    /**
     * Find zero or one MovieProducer that matches the filter.
     * @param {MovieProducerFindUniqueArgs} args - Arguments to find a MovieProducer
     * @example
     * // Get one MovieProducer
     * const movieProducer = await prisma.movieProducer.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MovieProducerFindUniqueArgs>(args: SelectSubset<T, MovieProducerFindUniqueArgs<ExtArgs>>): Prisma__MovieProducerClient<$Result.GetResult<Prisma.$MovieProducerPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one MovieProducer that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {MovieProducerFindUniqueOrThrowArgs} args - Arguments to find a MovieProducer
     * @example
     * // Get one MovieProducer
     * const movieProducer = await prisma.movieProducer.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MovieProducerFindUniqueOrThrowArgs>(args: SelectSubset<T, MovieProducerFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MovieProducerClient<$Result.GetResult<Prisma.$MovieProducerPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first MovieProducer that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MovieProducerFindFirstArgs} args - Arguments to find a MovieProducer
     * @example
     * // Get one MovieProducer
     * const movieProducer = await prisma.movieProducer.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MovieProducerFindFirstArgs>(args?: SelectSubset<T, MovieProducerFindFirstArgs<ExtArgs>>): Prisma__MovieProducerClient<$Result.GetResult<Prisma.$MovieProducerPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first MovieProducer that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MovieProducerFindFirstOrThrowArgs} args - Arguments to find a MovieProducer
     * @example
     * // Get one MovieProducer
     * const movieProducer = await prisma.movieProducer.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MovieProducerFindFirstOrThrowArgs>(args?: SelectSubset<T, MovieProducerFindFirstOrThrowArgs<ExtArgs>>): Prisma__MovieProducerClient<$Result.GetResult<Prisma.$MovieProducerPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more MovieProducers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MovieProducerFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MovieProducers
     * const movieProducers = await prisma.movieProducer.findMany()
     * 
     * // Get first 10 MovieProducers
     * const movieProducers = await prisma.movieProducer.findMany({ take: 10 })
     * 
     * // Only select the `personId`
     * const movieProducerWithPersonIdOnly = await prisma.movieProducer.findMany({ select: { personId: true } })
     * 
     */
    findMany<T extends MovieProducerFindManyArgs>(args?: SelectSubset<T, MovieProducerFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MovieProducerPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a MovieProducer.
     * @param {MovieProducerCreateArgs} args - Arguments to create a MovieProducer.
     * @example
     * // Create one MovieProducer
     * const MovieProducer = await prisma.movieProducer.create({
     *   data: {
     *     // ... data to create a MovieProducer
     *   }
     * })
     * 
     */
    create<T extends MovieProducerCreateArgs>(args: SelectSubset<T, MovieProducerCreateArgs<ExtArgs>>): Prisma__MovieProducerClient<$Result.GetResult<Prisma.$MovieProducerPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many MovieProducers.
     * @param {MovieProducerCreateManyArgs} args - Arguments to create many MovieProducers.
     * @example
     * // Create many MovieProducers
     * const movieProducer = await prisma.movieProducer.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MovieProducerCreateManyArgs>(args?: SelectSubset<T, MovieProducerCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many MovieProducers and returns the data saved in the database.
     * @param {MovieProducerCreateManyAndReturnArgs} args - Arguments to create many MovieProducers.
     * @example
     * // Create many MovieProducers
     * const movieProducer = await prisma.movieProducer.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many MovieProducers and only return the `personId`
     * const movieProducerWithPersonIdOnly = await prisma.movieProducer.createManyAndReturn({ 
     *   select: { personId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MovieProducerCreateManyAndReturnArgs>(args?: SelectSubset<T, MovieProducerCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MovieProducerPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a MovieProducer.
     * @param {MovieProducerDeleteArgs} args - Arguments to delete one MovieProducer.
     * @example
     * // Delete one MovieProducer
     * const MovieProducer = await prisma.movieProducer.delete({
     *   where: {
     *     // ... filter to delete one MovieProducer
     *   }
     * })
     * 
     */
    delete<T extends MovieProducerDeleteArgs>(args: SelectSubset<T, MovieProducerDeleteArgs<ExtArgs>>): Prisma__MovieProducerClient<$Result.GetResult<Prisma.$MovieProducerPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one MovieProducer.
     * @param {MovieProducerUpdateArgs} args - Arguments to update one MovieProducer.
     * @example
     * // Update one MovieProducer
     * const movieProducer = await prisma.movieProducer.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MovieProducerUpdateArgs>(args: SelectSubset<T, MovieProducerUpdateArgs<ExtArgs>>): Prisma__MovieProducerClient<$Result.GetResult<Prisma.$MovieProducerPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more MovieProducers.
     * @param {MovieProducerDeleteManyArgs} args - Arguments to filter MovieProducers to delete.
     * @example
     * // Delete a few MovieProducers
     * const { count } = await prisma.movieProducer.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MovieProducerDeleteManyArgs>(args?: SelectSubset<T, MovieProducerDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MovieProducers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MovieProducerUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MovieProducers
     * const movieProducer = await prisma.movieProducer.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MovieProducerUpdateManyArgs>(args: SelectSubset<T, MovieProducerUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one MovieProducer.
     * @param {MovieProducerUpsertArgs} args - Arguments to update or create a MovieProducer.
     * @example
     * // Update or create a MovieProducer
     * const movieProducer = await prisma.movieProducer.upsert({
     *   create: {
     *     // ... data to create a MovieProducer
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MovieProducer we want to update
     *   }
     * })
     */
    upsert<T extends MovieProducerUpsertArgs>(args: SelectSubset<T, MovieProducerUpsertArgs<ExtArgs>>): Prisma__MovieProducerClient<$Result.GetResult<Prisma.$MovieProducerPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of MovieProducers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MovieProducerCountArgs} args - Arguments to filter MovieProducers to count.
     * @example
     * // Count the number of MovieProducers
     * const count = await prisma.movieProducer.count({
     *   where: {
     *     // ... the filter for the MovieProducers we want to count
     *   }
     * })
    **/
    count<T extends MovieProducerCountArgs>(
      args?: Subset<T, MovieProducerCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MovieProducerCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MovieProducer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MovieProducerAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MovieProducerAggregateArgs>(args: Subset<T, MovieProducerAggregateArgs>): Prisma.PrismaPromise<GetMovieProducerAggregateType<T>>

    /**
     * Group by MovieProducer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MovieProducerGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MovieProducerGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MovieProducerGroupByArgs['orderBy'] }
        : { orderBy?: MovieProducerGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MovieProducerGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMovieProducerGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the MovieProducer model
   */
  readonly fields: MovieProducerFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for MovieProducer.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MovieProducerClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    person<T extends PersonDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PersonDefaultArgs<ExtArgs>>): Prisma__PersonClient<$Result.GetResult<Prisma.$PersonPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    movie<T extends MovieDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MovieDefaultArgs<ExtArgs>>): Prisma__MovieClient<$Result.GetResult<Prisma.$MoviePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the MovieProducer model
   */ 
  interface MovieProducerFieldRefs {
    readonly personId: FieldRef<"MovieProducer", 'String'>
    readonly movieId: FieldRef<"MovieProducer", 'String'>
    readonly type: FieldRef<"MovieProducer", 'ProducerType'>
  }
    

  // Custom InputTypes
  /**
   * MovieProducer findUnique
   */
  export type MovieProducerFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MovieProducer
     */
    select?: MovieProducerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MovieProducerInclude<ExtArgs> | null
    /**
     * Filter, which MovieProducer to fetch.
     */
    where: MovieProducerWhereUniqueInput
  }

  /**
   * MovieProducer findUniqueOrThrow
   */
  export type MovieProducerFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MovieProducer
     */
    select?: MovieProducerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MovieProducerInclude<ExtArgs> | null
    /**
     * Filter, which MovieProducer to fetch.
     */
    where: MovieProducerWhereUniqueInput
  }

  /**
   * MovieProducer findFirst
   */
  export type MovieProducerFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MovieProducer
     */
    select?: MovieProducerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MovieProducerInclude<ExtArgs> | null
    /**
     * Filter, which MovieProducer to fetch.
     */
    where?: MovieProducerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MovieProducers to fetch.
     */
    orderBy?: MovieProducerOrderByWithRelationInput | MovieProducerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MovieProducers.
     */
    cursor?: MovieProducerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MovieProducers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MovieProducers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MovieProducers.
     */
    distinct?: MovieProducerScalarFieldEnum | MovieProducerScalarFieldEnum[]
  }

  /**
   * MovieProducer findFirstOrThrow
   */
  export type MovieProducerFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MovieProducer
     */
    select?: MovieProducerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MovieProducerInclude<ExtArgs> | null
    /**
     * Filter, which MovieProducer to fetch.
     */
    where?: MovieProducerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MovieProducers to fetch.
     */
    orderBy?: MovieProducerOrderByWithRelationInput | MovieProducerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MovieProducers.
     */
    cursor?: MovieProducerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MovieProducers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MovieProducers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MovieProducers.
     */
    distinct?: MovieProducerScalarFieldEnum | MovieProducerScalarFieldEnum[]
  }

  /**
   * MovieProducer findMany
   */
  export type MovieProducerFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MovieProducer
     */
    select?: MovieProducerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MovieProducerInclude<ExtArgs> | null
    /**
     * Filter, which MovieProducers to fetch.
     */
    where?: MovieProducerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MovieProducers to fetch.
     */
    orderBy?: MovieProducerOrderByWithRelationInput | MovieProducerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MovieProducers.
     */
    cursor?: MovieProducerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MovieProducers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MovieProducers.
     */
    skip?: number
    distinct?: MovieProducerScalarFieldEnum | MovieProducerScalarFieldEnum[]
  }

  /**
   * MovieProducer create
   */
  export type MovieProducerCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MovieProducer
     */
    select?: MovieProducerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MovieProducerInclude<ExtArgs> | null
    /**
     * The data needed to create a MovieProducer.
     */
    data: XOR<MovieProducerCreateInput, MovieProducerUncheckedCreateInput>
  }

  /**
   * MovieProducer createMany
   */
  export type MovieProducerCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many MovieProducers.
     */
    data: MovieProducerCreateManyInput | MovieProducerCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * MovieProducer createManyAndReturn
   */
  export type MovieProducerCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MovieProducer
     */
    select?: MovieProducerSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many MovieProducers.
     */
    data: MovieProducerCreateManyInput | MovieProducerCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MovieProducerIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * MovieProducer update
   */
  export type MovieProducerUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MovieProducer
     */
    select?: MovieProducerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MovieProducerInclude<ExtArgs> | null
    /**
     * The data needed to update a MovieProducer.
     */
    data: XOR<MovieProducerUpdateInput, MovieProducerUncheckedUpdateInput>
    /**
     * Choose, which MovieProducer to update.
     */
    where: MovieProducerWhereUniqueInput
  }

  /**
   * MovieProducer updateMany
   */
  export type MovieProducerUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update MovieProducers.
     */
    data: XOR<MovieProducerUpdateManyMutationInput, MovieProducerUncheckedUpdateManyInput>
    /**
     * Filter which MovieProducers to update
     */
    where?: MovieProducerWhereInput
  }

  /**
   * MovieProducer upsert
   */
  export type MovieProducerUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MovieProducer
     */
    select?: MovieProducerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MovieProducerInclude<ExtArgs> | null
    /**
     * The filter to search for the MovieProducer to update in case it exists.
     */
    where: MovieProducerWhereUniqueInput
    /**
     * In case the MovieProducer found by the `where` argument doesn't exist, create a new MovieProducer with this data.
     */
    create: XOR<MovieProducerCreateInput, MovieProducerUncheckedCreateInput>
    /**
     * In case the MovieProducer was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MovieProducerUpdateInput, MovieProducerUncheckedUpdateInput>
  }

  /**
   * MovieProducer delete
   */
  export type MovieProducerDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MovieProducer
     */
    select?: MovieProducerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MovieProducerInclude<ExtArgs> | null
    /**
     * Filter which MovieProducer to delete.
     */
    where: MovieProducerWhereUniqueInput
  }

  /**
   * MovieProducer deleteMany
   */
  export type MovieProducerDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MovieProducers to delete
     */
    where?: MovieProducerWhereInput
  }

  /**
   * MovieProducer without action
   */
  export type MovieProducerDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MovieProducer
     */
    select?: MovieProducerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MovieProducerInclude<ExtArgs> | null
  }


  /**
   * Model MovieCinemaOverride
   */

  export type AggregateMovieCinemaOverride = {
    _count: MovieCinemaOverrideCountAggregateOutputType | null
    _min: MovieCinemaOverrideMinAggregateOutputType | null
    _max: MovieCinemaOverrideMaxAggregateOutputType | null
  }

  export type MovieCinemaOverrideMinAggregateOutputType = {
    movieId: string | null
    cinemaId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MovieCinemaOverrideMaxAggregateOutputType = {
    movieId: string | null
    cinemaId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MovieCinemaOverrideCountAggregateOutputType = {
    movieId: number
    cinemaId: number
    movieDataOverrides: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type MovieCinemaOverrideMinAggregateInputType = {
    movieId?: true
    cinemaId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MovieCinemaOverrideMaxAggregateInputType = {
    movieId?: true
    cinemaId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MovieCinemaOverrideCountAggregateInputType = {
    movieId?: true
    cinemaId?: true
    movieDataOverrides?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type MovieCinemaOverrideAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MovieCinemaOverride to aggregate.
     */
    where?: MovieCinemaOverrideWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MovieCinemaOverrides to fetch.
     */
    orderBy?: MovieCinemaOverrideOrderByWithRelationInput | MovieCinemaOverrideOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MovieCinemaOverrideWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MovieCinemaOverrides from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MovieCinemaOverrides.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MovieCinemaOverrides
    **/
    _count?: true | MovieCinemaOverrideCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MovieCinemaOverrideMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MovieCinemaOverrideMaxAggregateInputType
  }

  export type GetMovieCinemaOverrideAggregateType<T extends MovieCinemaOverrideAggregateArgs> = {
        [P in keyof T & keyof AggregateMovieCinemaOverride]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMovieCinemaOverride[P]>
      : GetScalarType<T[P], AggregateMovieCinemaOverride[P]>
  }




  export type MovieCinemaOverrideGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MovieCinemaOverrideWhereInput
    orderBy?: MovieCinemaOverrideOrderByWithAggregationInput | MovieCinemaOverrideOrderByWithAggregationInput[]
    by: MovieCinemaOverrideScalarFieldEnum[] | MovieCinemaOverrideScalarFieldEnum
    having?: MovieCinemaOverrideScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MovieCinemaOverrideCountAggregateInputType | true
    _min?: MovieCinemaOverrideMinAggregateInputType
    _max?: MovieCinemaOverrideMaxAggregateInputType
  }

  export type MovieCinemaOverrideGroupByOutputType = {
    movieId: string
    cinemaId: string
    movieDataOverrides: JsonValue
    createdAt: Date
    updatedAt: Date
    _count: MovieCinemaOverrideCountAggregateOutputType | null
    _min: MovieCinemaOverrideMinAggregateOutputType | null
    _max: MovieCinemaOverrideMaxAggregateOutputType | null
  }

  type GetMovieCinemaOverrideGroupByPayload<T extends MovieCinemaOverrideGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MovieCinemaOverrideGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MovieCinemaOverrideGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MovieCinemaOverrideGroupByOutputType[P]>
            : GetScalarType<T[P], MovieCinemaOverrideGroupByOutputType[P]>
        }
      >
    >


  export type MovieCinemaOverrideSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    movieId?: boolean
    cinemaId?: boolean
    movieDataOverrides?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    movie?: boolean | MovieDefaultArgs<ExtArgs>
    cinema?: boolean | CinemaDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["movieCinemaOverride"]>

  export type MovieCinemaOverrideSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    movieId?: boolean
    cinemaId?: boolean
    movieDataOverrides?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    movie?: boolean | MovieDefaultArgs<ExtArgs>
    cinema?: boolean | CinemaDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["movieCinemaOverride"]>

  export type MovieCinemaOverrideSelectScalar = {
    movieId?: boolean
    cinemaId?: boolean
    movieDataOverrides?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type MovieCinemaOverrideInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    movie?: boolean | MovieDefaultArgs<ExtArgs>
    cinema?: boolean | CinemaDefaultArgs<ExtArgs>
  }
  export type MovieCinemaOverrideIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    movie?: boolean | MovieDefaultArgs<ExtArgs>
    cinema?: boolean | CinemaDefaultArgs<ExtArgs>
  }

  export type $MovieCinemaOverridePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "MovieCinemaOverride"
    objects: {
      movie: Prisma.$MoviePayload<ExtArgs>
      cinema: Prisma.$CinemaPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      movieId: string
      cinemaId: string
      movieDataOverrides: Prisma.JsonValue
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["movieCinemaOverride"]>
    composites: {}
  }

  type MovieCinemaOverrideGetPayload<S extends boolean | null | undefined | MovieCinemaOverrideDefaultArgs> = $Result.GetResult<Prisma.$MovieCinemaOverridePayload, S>

  type MovieCinemaOverrideCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<MovieCinemaOverrideFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: MovieCinemaOverrideCountAggregateInputType | true
    }

  export interface MovieCinemaOverrideDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['MovieCinemaOverride'], meta: { name: 'MovieCinemaOverride' } }
    /**
     * Find zero or one MovieCinemaOverride that matches the filter.
     * @param {MovieCinemaOverrideFindUniqueArgs} args - Arguments to find a MovieCinemaOverride
     * @example
     * // Get one MovieCinemaOverride
     * const movieCinemaOverride = await prisma.movieCinemaOverride.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MovieCinemaOverrideFindUniqueArgs>(args: SelectSubset<T, MovieCinemaOverrideFindUniqueArgs<ExtArgs>>): Prisma__MovieCinemaOverrideClient<$Result.GetResult<Prisma.$MovieCinemaOverridePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one MovieCinemaOverride that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {MovieCinemaOverrideFindUniqueOrThrowArgs} args - Arguments to find a MovieCinemaOverride
     * @example
     * // Get one MovieCinemaOverride
     * const movieCinemaOverride = await prisma.movieCinemaOverride.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MovieCinemaOverrideFindUniqueOrThrowArgs>(args: SelectSubset<T, MovieCinemaOverrideFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MovieCinemaOverrideClient<$Result.GetResult<Prisma.$MovieCinemaOverridePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first MovieCinemaOverride that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MovieCinemaOverrideFindFirstArgs} args - Arguments to find a MovieCinemaOverride
     * @example
     * // Get one MovieCinemaOverride
     * const movieCinemaOverride = await prisma.movieCinemaOverride.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MovieCinemaOverrideFindFirstArgs>(args?: SelectSubset<T, MovieCinemaOverrideFindFirstArgs<ExtArgs>>): Prisma__MovieCinemaOverrideClient<$Result.GetResult<Prisma.$MovieCinemaOverridePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first MovieCinemaOverride that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MovieCinemaOverrideFindFirstOrThrowArgs} args - Arguments to find a MovieCinemaOverride
     * @example
     * // Get one MovieCinemaOverride
     * const movieCinemaOverride = await prisma.movieCinemaOverride.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MovieCinemaOverrideFindFirstOrThrowArgs>(args?: SelectSubset<T, MovieCinemaOverrideFindFirstOrThrowArgs<ExtArgs>>): Prisma__MovieCinemaOverrideClient<$Result.GetResult<Prisma.$MovieCinemaOverridePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more MovieCinemaOverrides that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MovieCinemaOverrideFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MovieCinemaOverrides
     * const movieCinemaOverrides = await prisma.movieCinemaOverride.findMany()
     * 
     * // Get first 10 MovieCinemaOverrides
     * const movieCinemaOverrides = await prisma.movieCinemaOverride.findMany({ take: 10 })
     * 
     * // Only select the `movieId`
     * const movieCinemaOverrideWithMovieIdOnly = await prisma.movieCinemaOverride.findMany({ select: { movieId: true } })
     * 
     */
    findMany<T extends MovieCinemaOverrideFindManyArgs>(args?: SelectSubset<T, MovieCinemaOverrideFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MovieCinemaOverridePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a MovieCinemaOverride.
     * @param {MovieCinemaOverrideCreateArgs} args - Arguments to create a MovieCinemaOverride.
     * @example
     * // Create one MovieCinemaOverride
     * const MovieCinemaOverride = await prisma.movieCinemaOverride.create({
     *   data: {
     *     // ... data to create a MovieCinemaOverride
     *   }
     * })
     * 
     */
    create<T extends MovieCinemaOverrideCreateArgs>(args: SelectSubset<T, MovieCinemaOverrideCreateArgs<ExtArgs>>): Prisma__MovieCinemaOverrideClient<$Result.GetResult<Prisma.$MovieCinemaOverridePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many MovieCinemaOverrides.
     * @param {MovieCinemaOverrideCreateManyArgs} args - Arguments to create many MovieCinemaOverrides.
     * @example
     * // Create many MovieCinemaOverrides
     * const movieCinemaOverride = await prisma.movieCinemaOverride.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MovieCinemaOverrideCreateManyArgs>(args?: SelectSubset<T, MovieCinemaOverrideCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many MovieCinemaOverrides and returns the data saved in the database.
     * @param {MovieCinemaOverrideCreateManyAndReturnArgs} args - Arguments to create many MovieCinemaOverrides.
     * @example
     * // Create many MovieCinemaOverrides
     * const movieCinemaOverride = await prisma.movieCinemaOverride.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many MovieCinemaOverrides and only return the `movieId`
     * const movieCinemaOverrideWithMovieIdOnly = await prisma.movieCinemaOverride.createManyAndReturn({ 
     *   select: { movieId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MovieCinemaOverrideCreateManyAndReturnArgs>(args?: SelectSubset<T, MovieCinemaOverrideCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MovieCinemaOverridePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a MovieCinemaOverride.
     * @param {MovieCinemaOverrideDeleteArgs} args - Arguments to delete one MovieCinemaOverride.
     * @example
     * // Delete one MovieCinemaOverride
     * const MovieCinemaOverride = await prisma.movieCinemaOverride.delete({
     *   where: {
     *     // ... filter to delete one MovieCinemaOverride
     *   }
     * })
     * 
     */
    delete<T extends MovieCinemaOverrideDeleteArgs>(args: SelectSubset<T, MovieCinemaOverrideDeleteArgs<ExtArgs>>): Prisma__MovieCinemaOverrideClient<$Result.GetResult<Prisma.$MovieCinemaOverridePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one MovieCinemaOverride.
     * @param {MovieCinemaOverrideUpdateArgs} args - Arguments to update one MovieCinemaOverride.
     * @example
     * // Update one MovieCinemaOverride
     * const movieCinemaOverride = await prisma.movieCinemaOverride.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MovieCinemaOverrideUpdateArgs>(args: SelectSubset<T, MovieCinemaOverrideUpdateArgs<ExtArgs>>): Prisma__MovieCinemaOverrideClient<$Result.GetResult<Prisma.$MovieCinemaOverridePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more MovieCinemaOverrides.
     * @param {MovieCinemaOverrideDeleteManyArgs} args - Arguments to filter MovieCinemaOverrides to delete.
     * @example
     * // Delete a few MovieCinemaOverrides
     * const { count } = await prisma.movieCinemaOverride.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MovieCinemaOverrideDeleteManyArgs>(args?: SelectSubset<T, MovieCinemaOverrideDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MovieCinemaOverrides.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MovieCinemaOverrideUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MovieCinemaOverrides
     * const movieCinemaOverride = await prisma.movieCinemaOverride.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MovieCinemaOverrideUpdateManyArgs>(args: SelectSubset<T, MovieCinemaOverrideUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one MovieCinemaOverride.
     * @param {MovieCinemaOverrideUpsertArgs} args - Arguments to update or create a MovieCinemaOverride.
     * @example
     * // Update or create a MovieCinemaOverride
     * const movieCinemaOverride = await prisma.movieCinemaOverride.upsert({
     *   create: {
     *     // ... data to create a MovieCinemaOverride
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MovieCinemaOverride we want to update
     *   }
     * })
     */
    upsert<T extends MovieCinemaOverrideUpsertArgs>(args: SelectSubset<T, MovieCinemaOverrideUpsertArgs<ExtArgs>>): Prisma__MovieCinemaOverrideClient<$Result.GetResult<Prisma.$MovieCinemaOverridePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of MovieCinemaOverrides.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MovieCinemaOverrideCountArgs} args - Arguments to filter MovieCinemaOverrides to count.
     * @example
     * // Count the number of MovieCinemaOverrides
     * const count = await prisma.movieCinemaOverride.count({
     *   where: {
     *     // ... the filter for the MovieCinemaOverrides we want to count
     *   }
     * })
    **/
    count<T extends MovieCinemaOverrideCountArgs>(
      args?: Subset<T, MovieCinemaOverrideCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MovieCinemaOverrideCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MovieCinemaOverride.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MovieCinemaOverrideAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MovieCinemaOverrideAggregateArgs>(args: Subset<T, MovieCinemaOverrideAggregateArgs>): Prisma.PrismaPromise<GetMovieCinemaOverrideAggregateType<T>>

    /**
     * Group by MovieCinemaOverride.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MovieCinemaOverrideGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MovieCinemaOverrideGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MovieCinemaOverrideGroupByArgs['orderBy'] }
        : { orderBy?: MovieCinemaOverrideGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MovieCinemaOverrideGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMovieCinemaOverrideGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the MovieCinemaOverride model
   */
  readonly fields: MovieCinemaOverrideFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for MovieCinemaOverride.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MovieCinemaOverrideClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    movie<T extends MovieDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MovieDefaultArgs<ExtArgs>>): Prisma__MovieClient<$Result.GetResult<Prisma.$MoviePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    cinema<T extends CinemaDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CinemaDefaultArgs<ExtArgs>>): Prisma__CinemaClient<$Result.GetResult<Prisma.$CinemaPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the MovieCinemaOverride model
   */ 
  interface MovieCinemaOverrideFieldRefs {
    readonly movieId: FieldRef<"MovieCinemaOverride", 'String'>
    readonly cinemaId: FieldRef<"MovieCinemaOverride", 'String'>
    readonly movieDataOverrides: FieldRef<"MovieCinemaOverride", 'Json'>
    readonly createdAt: FieldRef<"MovieCinemaOverride", 'DateTime'>
    readonly updatedAt: FieldRef<"MovieCinemaOverride", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * MovieCinemaOverride findUnique
   */
  export type MovieCinemaOverrideFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MovieCinemaOverride
     */
    select?: MovieCinemaOverrideSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MovieCinemaOverrideInclude<ExtArgs> | null
    /**
     * Filter, which MovieCinemaOverride to fetch.
     */
    where: MovieCinemaOverrideWhereUniqueInput
  }

  /**
   * MovieCinemaOverride findUniqueOrThrow
   */
  export type MovieCinemaOverrideFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MovieCinemaOverride
     */
    select?: MovieCinemaOverrideSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MovieCinemaOverrideInclude<ExtArgs> | null
    /**
     * Filter, which MovieCinemaOverride to fetch.
     */
    where: MovieCinemaOverrideWhereUniqueInput
  }

  /**
   * MovieCinemaOverride findFirst
   */
  export type MovieCinemaOverrideFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MovieCinemaOverride
     */
    select?: MovieCinemaOverrideSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MovieCinemaOverrideInclude<ExtArgs> | null
    /**
     * Filter, which MovieCinemaOverride to fetch.
     */
    where?: MovieCinemaOverrideWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MovieCinemaOverrides to fetch.
     */
    orderBy?: MovieCinemaOverrideOrderByWithRelationInput | MovieCinemaOverrideOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MovieCinemaOverrides.
     */
    cursor?: MovieCinemaOverrideWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MovieCinemaOverrides from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MovieCinemaOverrides.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MovieCinemaOverrides.
     */
    distinct?: MovieCinemaOverrideScalarFieldEnum | MovieCinemaOverrideScalarFieldEnum[]
  }

  /**
   * MovieCinemaOverride findFirstOrThrow
   */
  export type MovieCinemaOverrideFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MovieCinemaOverride
     */
    select?: MovieCinemaOverrideSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MovieCinemaOverrideInclude<ExtArgs> | null
    /**
     * Filter, which MovieCinemaOverride to fetch.
     */
    where?: MovieCinemaOverrideWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MovieCinemaOverrides to fetch.
     */
    orderBy?: MovieCinemaOverrideOrderByWithRelationInput | MovieCinemaOverrideOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MovieCinemaOverrides.
     */
    cursor?: MovieCinemaOverrideWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MovieCinemaOverrides from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MovieCinemaOverrides.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MovieCinemaOverrides.
     */
    distinct?: MovieCinemaOverrideScalarFieldEnum | MovieCinemaOverrideScalarFieldEnum[]
  }

  /**
   * MovieCinemaOverride findMany
   */
  export type MovieCinemaOverrideFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MovieCinemaOverride
     */
    select?: MovieCinemaOverrideSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MovieCinemaOverrideInclude<ExtArgs> | null
    /**
     * Filter, which MovieCinemaOverrides to fetch.
     */
    where?: MovieCinemaOverrideWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MovieCinemaOverrides to fetch.
     */
    orderBy?: MovieCinemaOverrideOrderByWithRelationInput | MovieCinemaOverrideOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MovieCinemaOverrides.
     */
    cursor?: MovieCinemaOverrideWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MovieCinemaOverrides from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MovieCinemaOverrides.
     */
    skip?: number
    distinct?: MovieCinemaOverrideScalarFieldEnum | MovieCinemaOverrideScalarFieldEnum[]
  }

  /**
   * MovieCinemaOverride create
   */
  export type MovieCinemaOverrideCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MovieCinemaOverride
     */
    select?: MovieCinemaOverrideSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MovieCinemaOverrideInclude<ExtArgs> | null
    /**
     * The data needed to create a MovieCinemaOverride.
     */
    data: XOR<MovieCinemaOverrideCreateInput, MovieCinemaOverrideUncheckedCreateInput>
  }

  /**
   * MovieCinemaOverride createMany
   */
  export type MovieCinemaOverrideCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many MovieCinemaOverrides.
     */
    data: MovieCinemaOverrideCreateManyInput | MovieCinemaOverrideCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * MovieCinemaOverride createManyAndReturn
   */
  export type MovieCinemaOverrideCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MovieCinemaOverride
     */
    select?: MovieCinemaOverrideSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many MovieCinemaOverrides.
     */
    data: MovieCinemaOverrideCreateManyInput | MovieCinemaOverrideCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MovieCinemaOverrideIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * MovieCinemaOverride update
   */
  export type MovieCinemaOverrideUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MovieCinemaOverride
     */
    select?: MovieCinemaOverrideSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MovieCinemaOverrideInclude<ExtArgs> | null
    /**
     * The data needed to update a MovieCinemaOverride.
     */
    data: XOR<MovieCinemaOverrideUpdateInput, MovieCinemaOverrideUncheckedUpdateInput>
    /**
     * Choose, which MovieCinemaOverride to update.
     */
    where: MovieCinemaOverrideWhereUniqueInput
  }

  /**
   * MovieCinemaOverride updateMany
   */
  export type MovieCinemaOverrideUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update MovieCinemaOverrides.
     */
    data: XOR<MovieCinemaOverrideUpdateManyMutationInput, MovieCinemaOverrideUncheckedUpdateManyInput>
    /**
     * Filter which MovieCinemaOverrides to update
     */
    where?: MovieCinemaOverrideWhereInput
  }

  /**
   * MovieCinemaOverride upsert
   */
  export type MovieCinemaOverrideUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MovieCinemaOverride
     */
    select?: MovieCinemaOverrideSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MovieCinemaOverrideInclude<ExtArgs> | null
    /**
     * The filter to search for the MovieCinemaOverride to update in case it exists.
     */
    where: MovieCinemaOverrideWhereUniqueInput
    /**
     * In case the MovieCinemaOverride found by the `where` argument doesn't exist, create a new MovieCinemaOverride with this data.
     */
    create: XOR<MovieCinemaOverrideCreateInput, MovieCinemaOverrideUncheckedCreateInput>
    /**
     * In case the MovieCinemaOverride was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MovieCinemaOverrideUpdateInput, MovieCinemaOverrideUncheckedUpdateInput>
  }

  /**
   * MovieCinemaOverride delete
   */
  export type MovieCinemaOverrideDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MovieCinemaOverride
     */
    select?: MovieCinemaOverrideSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MovieCinemaOverrideInclude<ExtArgs> | null
    /**
     * Filter which MovieCinemaOverride to delete.
     */
    where: MovieCinemaOverrideWhereUniqueInput
  }

  /**
   * MovieCinemaOverride deleteMany
   */
  export type MovieCinemaOverrideDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MovieCinemaOverrides to delete
     */
    where?: MovieCinemaOverrideWhereInput
  }

  /**
   * MovieCinemaOverride without action
   */
  export type MovieCinemaOverrideDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MovieCinemaOverride
     */
    select?: MovieCinemaOverrideSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MovieCinemaOverrideInclude<ExtArgs> | null
  }


  /**
   * Model MovieProjection
   */

  export type AggregateMovieProjection = {
    _count: MovieProjectionCountAggregateOutputType | null
    _min: MovieProjectionMinAggregateOutputType | null
    _max: MovieProjectionMaxAggregateOutputType | null
  }

  export type MovieProjectionMinAggregateOutputType = {
    id: string | null
    movieId: string | null
    cinemaTheaterId: string | null
    projectionDateTime: Date | null
    createdAt: Date | null
    updatedAt: Date | null
    dubbedLanguageId: string | null
  }

  export type MovieProjectionMaxAggregateOutputType = {
    id: string | null
    movieId: string | null
    cinemaTheaterId: string | null
    projectionDateTime: Date | null
    createdAt: Date | null
    updatedAt: Date | null
    dubbedLanguageId: string | null
  }

  export type MovieProjectionCountAggregateOutputType = {
    id: number
    movieId: number
    cinemaTheaterId: number
    projectionDateTime: number
    createdAt: number
    updatedAt: number
    dubbedLanguageId: number
    options: number
    _all: number
  }


  export type MovieProjectionMinAggregateInputType = {
    id?: true
    movieId?: true
    cinemaTheaterId?: true
    projectionDateTime?: true
    createdAt?: true
    updatedAt?: true
    dubbedLanguageId?: true
  }

  export type MovieProjectionMaxAggregateInputType = {
    id?: true
    movieId?: true
    cinemaTheaterId?: true
    projectionDateTime?: true
    createdAt?: true
    updatedAt?: true
    dubbedLanguageId?: true
  }

  export type MovieProjectionCountAggregateInputType = {
    id?: true
    movieId?: true
    cinemaTheaterId?: true
    projectionDateTime?: true
    createdAt?: true
    updatedAt?: true
    dubbedLanguageId?: true
    options?: true
    _all?: true
  }

  export type MovieProjectionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MovieProjection to aggregate.
     */
    where?: MovieProjectionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MovieProjections to fetch.
     */
    orderBy?: MovieProjectionOrderByWithRelationInput | MovieProjectionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MovieProjectionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MovieProjections from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MovieProjections.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MovieProjections
    **/
    _count?: true | MovieProjectionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MovieProjectionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MovieProjectionMaxAggregateInputType
  }

  export type GetMovieProjectionAggregateType<T extends MovieProjectionAggregateArgs> = {
        [P in keyof T & keyof AggregateMovieProjection]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMovieProjection[P]>
      : GetScalarType<T[P], AggregateMovieProjection[P]>
  }




  export type MovieProjectionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MovieProjectionWhereInput
    orderBy?: MovieProjectionOrderByWithAggregationInput | MovieProjectionOrderByWithAggregationInput[]
    by: MovieProjectionScalarFieldEnum[] | MovieProjectionScalarFieldEnum
    having?: MovieProjectionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MovieProjectionCountAggregateInputType | true
    _min?: MovieProjectionMinAggregateInputType
    _max?: MovieProjectionMaxAggregateInputType
  }

  export type MovieProjectionGroupByOutputType = {
    id: string
    movieId: string
    cinemaTheaterId: string
    projectionDateTime: Date
    createdAt: Date
    updatedAt: Date
    dubbedLanguageId: string | null
    options: JsonValue
    _count: MovieProjectionCountAggregateOutputType | null
    _min: MovieProjectionMinAggregateOutputType | null
    _max: MovieProjectionMaxAggregateOutputType | null
  }

  type GetMovieProjectionGroupByPayload<T extends MovieProjectionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MovieProjectionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MovieProjectionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MovieProjectionGroupByOutputType[P]>
            : GetScalarType<T[P], MovieProjectionGroupByOutputType[P]>
        }
      >
    >


  export type MovieProjectionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    movieId?: boolean
    cinemaTheaterId?: boolean
    projectionDateTime?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    dubbedLanguageId?: boolean
    options?: boolean
    movie?: boolean | MovieDefaultArgs<ExtArgs>
    cinemaTheater?: boolean | CinemaTheaterDefaultArgs<ExtArgs>
    dubbedLanguage?: boolean | MovieProjection$dubbedLanguageArgs<ExtArgs>
    projectionPrices?: boolean | MovieProjection$projectionPricesArgs<ExtArgs>
    reservations?: boolean | MovieProjection$reservationsArgs<ExtArgs>
    _count?: boolean | MovieProjectionCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["movieProjection"]>

  export type MovieProjectionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    movieId?: boolean
    cinemaTheaterId?: boolean
    projectionDateTime?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    dubbedLanguageId?: boolean
    options?: boolean
    movie?: boolean | MovieDefaultArgs<ExtArgs>
    cinemaTheater?: boolean | CinemaTheaterDefaultArgs<ExtArgs>
    dubbedLanguage?: boolean | MovieProjection$dubbedLanguageArgs<ExtArgs>
  }, ExtArgs["result"]["movieProjection"]>

  export type MovieProjectionSelectScalar = {
    id?: boolean
    movieId?: boolean
    cinemaTheaterId?: boolean
    projectionDateTime?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    dubbedLanguageId?: boolean
    options?: boolean
  }

  export type MovieProjectionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    movie?: boolean | MovieDefaultArgs<ExtArgs>
    cinemaTheater?: boolean | CinemaTheaterDefaultArgs<ExtArgs>
    dubbedLanguage?: boolean | MovieProjection$dubbedLanguageArgs<ExtArgs>
    projectionPrices?: boolean | MovieProjection$projectionPricesArgs<ExtArgs>
    reservations?: boolean | MovieProjection$reservationsArgs<ExtArgs>
    _count?: boolean | MovieProjectionCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type MovieProjectionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    movie?: boolean | MovieDefaultArgs<ExtArgs>
    cinemaTheater?: boolean | CinemaTheaterDefaultArgs<ExtArgs>
    dubbedLanguage?: boolean | MovieProjection$dubbedLanguageArgs<ExtArgs>
  }

  export type $MovieProjectionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "MovieProjection"
    objects: {
      movie: Prisma.$MoviePayload<ExtArgs>
      cinemaTheater: Prisma.$CinemaTheaterPayload<ExtArgs>
      dubbedLanguage: Prisma.$LanguagePayload<ExtArgs> | null
      projectionPrices: Prisma.$ProjectionPricePayload<ExtArgs>[]
      reservations: Prisma.$ReservationPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      movieId: string
      cinemaTheaterId: string
      projectionDateTime: Date
      createdAt: Date
      updatedAt: Date
      dubbedLanguageId: string | null
      options: Prisma.JsonValue
    }, ExtArgs["result"]["movieProjection"]>
    composites: {}
  }

  type MovieProjectionGetPayload<S extends boolean | null | undefined | MovieProjectionDefaultArgs> = $Result.GetResult<Prisma.$MovieProjectionPayload, S>

  type MovieProjectionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<MovieProjectionFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: MovieProjectionCountAggregateInputType | true
    }

  export interface MovieProjectionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['MovieProjection'], meta: { name: 'MovieProjection' } }
    /**
     * Find zero or one MovieProjection that matches the filter.
     * @param {MovieProjectionFindUniqueArgs} args - Arguments to find a MovieProjection
     * @example
     * // Get one MovieProjection
     * const movieProjection = await prisma.movieProjection.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MovieProjectionFindUniqueArgs>(args: SelectSubset<T, MovieProjectionFindUniqueArgs<ExtArgs>>): Prisma__MovieProjectionClient<$Result.GetResult<Prisma.$MovieProjectionPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one MovieProjection that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {MovieProjectionFindUniqueOrThrowArgs} args - Arguments to find a MovieProjection
     * @example
     * // Get one MovieProjection
     * const movieProjection = await prisma.movieProjection.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MovieProjectionFindUniqueOrThrowArgs>(args: SelectSubset<T, MovieProjectionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MovieProjectionClient<$Result.GetResult<Prisma.$MovieProjectionPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first MovieProjection that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MovieProjectionFindFirstArgs} args - Arguments to find a MovieProjection
     * @example
     * // Get one MovieProjection
     * const movieProjection = await prisma.movieProjection.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MovieProjectionFindFirstArgs>(args?: SelectSubset<T, MovieProjectionFindFirstArgs<ExtArgs>>): Prisma__MovieProjectionClient<$Result.GetResult<Prisma.$MovieProjectionPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first MovieProjection that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MovieProjectionFindFirstOrThrowArgs} args - Arguments to find a MovieProjection
     * @example
     * // Get one MovieProjection
     * const movieProjection = await prisma.movieProjection.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MovieProjectionFindFirstOrThrowArgs>(args?: SelectSubset<T, MovieProjectionFindFirstOrThrowArgs<ExtArgs>>): Prisma__MovieProjectionClient<$Result.GetResult<Prisma.$MovieProjectionPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more MovieProjections that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MovieProjectionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MovieProjections
     * const movieProjections = await prisma.movieProjection.findMany()
     * 
     * // Get first 10 MovieProjections
     * const movieProjections = await prisma.movieProjection.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const movieProjectionWithIdOnly = await prisma.movieProjection.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MovieProjectionFindManyArgs>(args?: SelectSubset<T, MovieProjectionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MovieProjectionPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a MovieProjection.
     * @param {MovieProjectionCreateArgs} args - Arguments to create a MovieProjection.
     * @example
     * // Create one MovieProjection
     * const MovieProjection = await prisma.movieProjection.create({
     *   data: {
     *     // ... data to create a MovieProjection
     *   }
     * })
     * 
     */
    create<T extends MovieProjectionCreateArgs>(args: SelectSubset<T, MovieProjectionCreateArgs<ExtArgs>>): Prisma__MovieProjectionClient<$Result.GetResult<Prisma.$MovieProjectionPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many MovieProjections.
     * @param {MovieProjectionCreateManyArgs} args - Arguments to create many MovieProjections.
     * @example
     * // Create many MovieProjections
     * const movieProjection = await prisma.movieProjection.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MovieProjectionCreateManyArgs>(args?: SelectSubset<T, MovieProjectionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many MovieProjections and returns the data saved in the database.
     * @param {MovieProjectionCreateManyAndReturnArgs} args - Arguments to create many MovieProjections.
     * @example
     * // Create many MovieProjections
     * const movieProjection = await prisma.movieProjection.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many MovieProjections and only return the `id`
     * const movieProjectionWithIdOnly = await prisma.movieProjection.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MovieProjectionCreateManyAndReturnArgs>(args?: SelectSubset<T, MovieProjectionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MovieProjectionPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a MovieProjection.
     * @param {MovieProjectionDeleteArgs} args - Arguments to delete one MovieProjection.
     * @example
     * // Delete one MovieProjection
     * const MovieProjection = await prisma.movieProjection.delete({
     *   where: {
     *     // ... filter to delete one MovieProjection
     *   }
     * })
     * 
     */
    delete<T extends MovieProjectionDeleteArgs>(args: SelectSubset<T, MovieProjectionDeleteArgs<ExtArgs>>): Prisma__MovieProjectionClient<$Result.GetResult<Prisma.$MovieProjectionPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one MovieProjection.
     * @param {MovieProjectionUpdateArgs} args - Arguments to update one MovieProjection.
     * @example
     * // Update one MovieProjection
     * const movieProjection = await prisma.movieProjection.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MovieProjectionUpdateArgs>(args: SelectSubset<T, MovieProjectionUpdateArgs<ExtArgs>>): Prisma__MovieProjectionClient<$Result.GetResult<Prisma.$MovieProjectionPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more MovieProjections.
     * @param {MovieProjectionDeleteManyArgs} args - Arguments to filter MovieProjections to delete.
     * @example
     * // Delete a few MovieProjections
     * const { count } = await prisma.movieProjection.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MovieProjectionDeleteManyArgs>(args?: SelectSubset<T, MovieProjectionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MovieProjections.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MovieProjectionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MovieProjections
     * const movieProjection = await prisma.movieProjection.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MovieProjectionUpdateManyArgs>(args: SelectSubset<T, MovieProjectionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one MovieProjection.
     * @param {MovieProjectionUpsertArgs} args - Arguments to update or create a MovieProjection.
     * @example
     * // Update or create a MovieProjection
     * const movieProjection = await prisma.movieProjection.upsert({
     *   create: {
     *     // ... data to create a MovieProjection
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MovieProjection we want to update
     *   }
     * })
     */
    upsert<T extends MovieProjectionUpsertArgs>(args: SelectSubset<T, MovieProjectionUpsertArgs<ExtArgs>>): Prisma__MovieProjectionClient<$Result.GetResult<Prisma.$MovieProjectionPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of MovieProjections.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MovieProjectionCountArgs} args - Arguments to filter MovieProjections to count.
     * @example
     * // Count the number of MovieProjections
     * const count = await prisma.movieProjection.count({
     *   where: {
     *     // ... the filter for the MovieProjections we want to count
     *   }
     * })
    **/
    count<T extends MovieProjectionCountArgs>(
      args?: Subset<T, MovieProjectionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MovieProjectionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MovieProjection.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MovieProjectionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MovieProjectionAggregateArgs>(args: Subset<T, MovieProjectionAggregateArgs>): Prisma.PrismaPromise<GetMovieProjectionAggregateType<T>>

    /**
     * Group by MovieProjection.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MovieProjectionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MovieProjectionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MovieProjectionGroupByArgs['orderBy'] }
        : { orderBy?: MovieProjectionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MovieProjectionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMovieProjectionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the MovieProjection model
   */
  readonly fields: MovieProjectionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for MovieProjection.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MovieProjectionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    movie<T extends MovieDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MovieDefaultArgs<ExtArgs>>): Prisma__MovieClient<$Result.GetResult<Prisma.$MoviePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    cinemaTheater<T extends CinemaTheaterDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CinemaTheaterDefaultArgs<ExtArgs>>): Prisma__CinemaTheaterClient<$Result.GetResult<Prisma.$CinemaTheaterPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    dubbedLanguage<T extends MovieProjection$dubbedLanguageArgs<ExtArgs> = {}>(args?: Subset<T, MovieProjection$dubbedLanguageArgs<ExtArgs>>): Prisma__LanguageClient<$Result.GetResult<Prisma.$LanguagePayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    projectionPrices<T extends MovieProjection$projectionPricesArgs<ExtArgs> = {}>(args?: Subset<T, MovieProjection$projectionPricesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectionPricePayload<ExtArgs>, T, "findMany"> | Null>
    reservations<T extends MovieProjection$reservationsArgs<ExtArgs> = {}>(args?: Subset<T, MovieProjection$reservationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReservationPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the MovieProjection model
   */ 
  interface MovieProjectionFieldRefs {
    readonly id: FieldRef<"MovieProjection", 'String'>
    readonly movieId: FieldRef<"MovieProjection", 'String'>
    readonly cinemaTheaterId: FieldRef<"MovieProjection", 'String'>
    readonly projectionDateTime: FieldRef<"MovieProjection", 'DateTime'>
    readonly createdAt: FieldRef<"MovieProjection", 'DateTime'>
    readonly updatedAt: FieldRef<"MovieProjection", 'DateTime'>
    readonly dubbedLanguageId: FieldRef<"MovieProjection", 'String'>
    readonly options: FieldRef<"MovieProjection", 'Json'>
  }
    

  // Custom InputTypes
  /**
   * MovieProjection findUnique
   */
  export type MovieProjectionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MovieProjection
     */
    select?: MovieProjectionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MovieProjectionInclude<ExtArgs> | null
    /**
     * Filter, which MovieProjection to fetch.
     */
    where: MovieProjectionWhereUniqueInput
  }

  /**
   * MovieProjection findUniqueOrThrow
   */
  export type MovieProjectionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MovieProjection
     */
    select?: MovieProjectionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MovieProjectionInclude<ExtArgs> | null
    /**
     * Filter, which MovieProjection to fetch.
     */
    where: MovieProjectionWhereUniqueInput
  }

  /**
   * MovieProjection findFirst
   */
  export type MovieProjectionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MovieProjection
     */
    select?: MovieProjectionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MovieProjectionInclude<ExtArgs> | null
    /**
     * Filter, which MovieProjection to fetch.
     */
    where?: MovieProjectionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MovieProjections to fetch.
     */
    orderBy?: MovieProjectionOrderByWithRelationInput | MovieProjectionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MovieProjections.
     */
    cursor?: MovieProjectionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MovieProjections from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MovieProjections.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MovieProjections.
     */
    distinct?: MovieProjectionScalarFieldEnum | MovieProjectionScalarFieldEnum[]
  }

  /**
   * MovieProjection findFirstOrThrow
   */
  export type MovieProjectionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MovieProjection
     */
    select?: MovieProjectionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MovieProjectionInclude<ExtArgs> | null
    /**
     * Filter, which MovieProjection to fetch.
     */
    where?: MovieProjectionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MovieProjections to fetch.
     */
    orderBy?: MovieProjectionOrderByWithRelationInput | MovieProjectionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MovieProjections.
     */
    cursor?: MovieProjectionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MovieProjections from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MovieProjections.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MovieProjections.
     */
    distinct?: MovieProjectionScalarFieldEnum | MovieProjectionScalarFieldEnum[]
  }

  /**
   * MovieProjection findMany
   */
  export type MovieProjectionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MovieProjection
     */
    select?: MovieProjectionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MovieProjectionInclude<ExtArgs> | null
    /**
     * Filter, which MovieProjections to fetch.
     */
    where?: MovieProjectionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MovieProjections to fetch.
     */
    orderBy?: MovieProjectionOrderByWithRelationInput | MovieProjectionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MovieProjections.
     */
    cursor?: MovieProjectionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MovieProjections from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MovieProjections.
     */
    skip?: number
    distinct?: MovieProjectionScalarFieldEnum | MovieProjectionScalarFieldEnum[]
  }

  /**
   * MovieProjection create
   */
  export type MovieProjectionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MovieProjection
     */
    select?: MovieProjectionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MovieProjectionInclude<ExtArgs> | null
    /**
     * The data needed to create a MovieProjection.
     */
    data: XOR<MovieProjectionCreateInput, MovieProjectionUncheckedCreateInput>
  }

  /**
   * MovieProjection createMany
   */
  export type MovieProjectionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many MovieProjections.
     */
    data: MovieProjectionCreateManyInput | MovieProjectionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * MovieProjection createManyAndReturn
   */
  export type MovieProjectionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MovieProjection
     */
    select?: MovieProjectionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many MovieProjections.
     */
    data: MovieProjectionCreateManyInput | MovieProjectionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MovieProjectionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * MovieProjection update
   */
  export type MovieProjectionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MovieProjection
     */
    select?: MovieProjectionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MovieProjectionInclude<ExtArgs> | null
    /**
     * The data needed to update a MovieProjection.
     */
    data: XOR<MovieProjectionUpdateInput, MovieProjectionUncheckedUpdateInput>
    /**
     * Choose, which MovieProjection to update.
     */
    where: MovieProjectionWhereUniqueInput
  }

  /**
   * MovieProjection updateMany
   */
  export type MovieProjectionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update MovieProjections.
     */
    data: XOR<MovieProjectionUpdateManyMutationInput, MovieProjectionUncheckedUpdateManyInput>
    /**
     * Filter which MovieProjections to update
     */
    where?: MovieProjectionWhereInput
  }

  /**
   * MovieProjection upsert
   */
  export type MovieProjectionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MovieProjection
     */
    select?: MovieProjectionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MovieProjectionInclude<ExtArgs> | null
    /**
     * The filter to search for the MovieProjection to update in case it exists.
     */
    where: MovieProjectionWhereUniqueInput
    /**
     * In case the MovieProjection found by the `where` argument doesn't exist, create a new MovieProjection with this data.
     */
    create: XOR<MovieProjectionCreateInput, MovieProjectionUncheckedCreateInput>
    /**
     * In case the MovieProjection was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MovieProjectionUpdateInput, MovieProjectionUncheckedUpdateInput>
  }

  /**
   * MovieProjection delete
   */
  export type MovieProjectionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MovieProjection
     */
    select?: MovieProjectionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MovieProjectionInclude<ExtArgs> | null
    /**
     * Filter which MovieProjection to delete.
     */
    where: MovieProjectionWhereUniqueInput
  }

  /**
   * MovieProjection deleteMany
   */
  export type MovieProjectionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MovieProjections to delete
     */
    where?: MovieProjectionWhereInput
  }

  /**
   * MovieProjection.dubbedLanguage
   */
  export type MovieProjection$dubbedLanguageArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Language
     */
    select?: LanguageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LanguageInclude<ExtArgs> | null
    where?: LanguageWhereInput
  }

  /**
   * MovieProjection.projectionPrices
   */
  export type MovieProjection$projectionPricesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectionPrice
     */
    select?: ProjectionPriceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectionPriceInclude<ExtArgs> | null
    where?: ProjectionPriceWhereInput
    orderBy?: ProjectionPriceOrderByWithRelationInput | ProjectionPriceOrderByWithRelationInput[]
    cursor?: ProjectionPriceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProjectionPriceScalarFieldEnum | ProjectionPriceScalarFieldEnum[]
  }

  /**
   * MovieProjection.reservations
   */
  export type MovieProjection$reservationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reservation
     */
    select?: ReservationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReservationInclude<ExtArgs> | null
    where?: ReservationWhereInput
    orderBy?: ReservationOrderByWithRelationInput | ReservationOrderByWithRelationInput[]
    cursor?: ReservationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ReservationScalarFieldEnum | ReservationScalarFieldEnum[]
  }

  /**
   * MovieProjection without action
   */
  export type MovieProjectionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MovieProjection
     */
    select?: MovieProjectionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MovieProjectionInclude<ExtArgs> | null
  }


  /**
   * Model ProjectionPrice
   */

  export type AggregateProjectionPrice = {
    _count: ProjectionPriceCountAggregateOutputType | null
    _avg: ProjectionPriceAvgAggregateOutputType | null
    _sum: ProjectionPriceSumAggregateOutputType | null
    _min: ProjectionPriceMinAggregateOutputType | null
    _max: ProjectionPriceMaxAggregateOutputType | null
  }

  export type ProjectionPriceAvgAggregateOutputType = {
    price: Decimal | null
  }

  export type ProjectionPriceSumAggregateOutputType = {
    price: Decimal | null
  }

  export type ProjectionPriceMinAggregateOutputType = {
    projectionId: string | null
    groupId: string | null
    type: $Enums.PriceType | null
    price: Decimal | null
    currencyCode: $Enums.CurrencyCode | null
  }

  export type ProjectionPriceMaxAggregateOutputType = {
    projectionId: string | null
    groupId: string | null
    type: $Enums.PriceType | null
    price: Decimal | null
    currencyCode: $Enums.CurrencyCode | null
  }

  export type ProjectionPriceCountAggregateOutputType = {
    projectionId: number
    groupId: number
    type: number
    price: number
    currencyCode: number
    _all: number
  }


  export type ProjectionPriceAvgAggregateInputType = {
    price?: true
  }

  export type ProjectionPriceSumAggregateInputType = {
    price?: true
  }

  export type ProjectionPriceMinAggregateInputType = {
    projectionId?: true
    groupId?: true
    type?: true
    price?: true
    currencyCode?: true
  }

  export type ProjectionPriceMaxAggregateInputType = {
    projectionId?: true
    groupId?: true
    type?: true
    price?: true
    currencyCode?: true
  }

  export type ProjectionPriceCountAggregateInputType = {
    projectionId?: true
    groupId?: true
    type?: true
    price?: true
    currencyCode?: true
    _all?: true
  }

  export type ProjectionPriceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProjectionPrice to aggregate.
     */
    where?: ProjectionPriceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProjectionPrices to fetch.
     */
    orderBy?: ProjectionPriceOrderByWithRelationInput | ProjectionPriceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProjectionPriceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProjectionPrices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProjectionPrices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ProjectionPrices
    **/
    _count?: true | ProjectionPriceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProjectionPriceAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProjectionPriceSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProjectionPriceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProjectionPriceMaxAggregateInputType
  }

  export type GetProjectionPriceAggregateType<T extends ProjectionPriceAggregateArgs> = {
        [P in keyof T & keyof AggregateProjectionPrice]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProjectionPrice[P]>
      : GetScalarType<T[P], AggregateProjectionPrice[P]>
  }




  export type ProjectionPriceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProjectionPriceWhereInput
    orderBy?: ProjectionPriceOrderByWithAggregationInput | ProjectionPriceOrderByWithAggregationInput[]
    by: ProjectionPriceScalarFieldEnum[] | ProjectionPriceScalarFieldEnum
    having?: ProjectionPriceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProjectionPriceCountAggregateInputType | true
    _avg?: ProjectionPriceAvgAggregateInputType
    _sum?: ProjectionPriceSumAggregateInputType
    _min?: ProjectionPriceMinAggregateInputType
    _max?: ProjectionPriceMaxAggregateInputType
  }

  export type ProjectionPriceGroupByOutputType = {
    projectionId: string
    groupId: string
    type: $Enums.PriceType
    price: Decimal
    currencyCode: $Enums.CurrencyCode
    _count: ProjectionPriceCountAggregateOutputType | null
    _avg: ProjectionPriceAvgAggregateOutputType | null
    _sum: ProjectionPriceSumAggregateOutputType | null
    _min: ProjectionPriceMinAggregateOutputType | null
    _max: ProjectionPriceMaxAggregateOutputType | null
  }

  type GetProjectionPriceGroupByPayload<T extends ProjectionPriceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProjectionPriceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProjectionPriceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProjectionPriceGroupByOutputType[P]>
            : GetScalarType<T[P], ProjectionPriceGroupByOutputType[P]>
        }
      >
    >


  export type ProjectionPriceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    projectionId?: boolean
    groupId?: boolean
    type?: boolean
    price?: boolean
    currencyCode?: boolean
    cinemaSeatGroup?: boolean | CinemaSeatGroupDefaultArgs<ExtArgs>
    movieProjection?: boolean | MovieProjectionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["projectionPrice"]>

  export type ProjectionPriceSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    projectionId?: boolean
    groupId?: boolean
    type?: boolean
    price?: boolean
    currencyCode?: boolean
    cinemaSeatGroup?: boolean | CinemaSeatGroupDefaultArgs<ExtArgs>
    movieProjection?: boolean | MovieProjectionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["projectionPrice"]>

  export type ProjectionPriceSelectScalar = {
    projectionId?: boolean
    groupId?: boolean
    type?: boolean
    price?: boolean
    currencyCode?: boolean
  }

  export type ProjectionPriceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    cinemaSeatGroup?: boolean | CinemaSeatGroupDefaultArgs<ExtArgs>
    movieProjection?: boolean | MovieProjectionDefaultArgs<ExtArgs>
  }
  export type ProjectionPriceIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    cinemaSeatGroup?: boolean | CinemaSeatGroupDefaultArgs<ExtArgs>
    movieProjection?: boolean | MovieProjectionDefaultArgs<ExtArgs>
  }

  export type $ProjectionPricePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ProjectionPrice"
    objects: {
      cinemaSeatGroup: Prisma.$CinemaSeatGroupPayload<ExtArgs>
      movieProjection: Prisma.$MovieProjectionPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      projectionId: string
      groupId: string
      type: $Enums.PriceType
      price: Prisma.Decimal
      currencyCode: $Enums.CurrencyCode
    }, ExtArgs["result"]["projectionPrice"]>
    composites: {}
  }

  type ProjectionPriceGetPayload<S extends boolean | null | undefined | ProjectionPriceDefaultArgs> = $Result.GetResult<Prisma.$ProjectionPricePayload, S>

  type ProjectionPriceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ProjectionPriceFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ProjectionPriceCountAggregateInputType | true
    }

  export interface ProjectionPriceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ProjectionPrice'], meta: { name: 'ProjectionPrice' } }
    /**
     * Find zero or one ProjectionPrice that matches the filter.
     * @param {ProjectionPriceFindUniqueArgs} args - Arguments to find a ProjectionPrice
     * @example
     * // Get one ProjectionPrice
     * const projectionPrice = await prisma.projectionPrice.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProjectionPriceFindUniqueArgs>(args: SelectSubset<T, ProjectionPriceFindUniqueArgs<ExtArgs>>): Prisma__ProjectionPriceClient<$Result.GetResult<Prisma.$ProjectionPricePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ProjectionPrice that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ProjectionPriceFindUniqueOrThrowArgs} args - Arguments to find a ProjectionPrice
     * @example
     * // Get one ProjectionPrice
     * const projectionPrice = await prisma.projectionPrice.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProjectionPriceFindUniqueOrThrowArgs>(args: SelectSubset<T, ProjectionPriceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProjectionPriceClient<$Result.GetResult<Prisma.$ProjectionPricePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ProjectionPrice that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectionPriceFindFirstArgs} args - Arguments to find a ProjectionPrice
     * @example
     * // Get one ProjectionPrice
     * const projectionPrice = await prisma.projectionPrice.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProjectionPriceFindFirstArgs>(args?: SelectSubset<T, ProjectionPriceFindFirstArgs<ExtArgs>>): Prisma__ProjectionPriceClient<$Result.GetResult<Prisma.$ProjectionPricePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ProjectionPrice that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectionPriceFindFirstOrThrowArgs} args - Arguments to find a ProjectionPrice
     * @example
     * // Get one ProjectionPrice
     * const projectionPrice = await prisma.projectionPrice.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProjectionPriceFindFirstOrThrowArgs>(args?: SelectSubset<T, ProjectionPriceFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProjectionPriceClient<$Result.GetResult<Prisma.$ProjectionPricePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ProjectionPrices that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectionPriceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ProjectionPrices
     * const projectionPrices = await prisma.projectionPrice.findMany()
     * 
     * // Get first 10 ProjectionPrices
     * const projectionPrices = await prisma.projectionPrice.findMany({ take: 10 })
     * 
     * // Only select the `projectionId`
     * const projectionPriceWithProjectionIdOnly = await prisma.projectionPrice.findMany({ select: { projectionId: true } })
     * 
     */
    findMany<T extends ProjectionPriceFindManyArgs>(args?: SelectSubset<T, ProjectionPriceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectionPricePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ProjectionPrice.
     * @param {ProjectionPriceCreateArgs} args - Arguments to create a ProjectionPrice.
     * @example
     * // Create one ProjectionPrice
     * const ProjectionPrice = await prisma.projectionPrice.create({
     *   data: {
     *     // ... data to create a ProjectionPrice
     *   }
     * })
     * 
     */
    create<T extends ProjectionPriceCreateArgs>(args: SelectSubset<T, ProjectionPriceCreateArgs<ExtArgs>>): Prisma__ProjectionPriceClient<$Result.GetResult<Prisma.$ProjectionPricePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ProjectionPrices.
     * @param {ProjectionPriceCreateManyArgs} args - Arguments to create many ProjectionPrices.
     * @example
     * // Create many ProjectionPrices
     * const projectionPrice = await prisma.projectionPrice.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProjectionPriceCreateManyArgs>(args?: SelectSubset<T, ProjectionPriceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ProjectionPrices and returns the data saved in the database.
     * @param {ProjectionPriceCreateManyAndReturnArgs} args - Arguments to create many ProjectionPrices.
     * @example
     * // Create many ProjectionPrices
     * const projectionPrice = await prisma.projectionPrice.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ProjectionPrices and only return the `projectionId`
     * const projectionPriceWithProjectionIdOnly = await prisma.projectionPrice.createManyAndReturn({ 
     *   select: { projectionId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ProjectionPriceCreateManyAndReturnArgs>(args?: SelectSubset<T, ProjectionPriceCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectionPricePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a ProjectionPrice.
     * @param {ProjectionPriceDeleteArgs} args - Arguments to delete one ProjectionPrice.
     * @example
     * // Delete one ProjectionPrice
     * const ProjectionPrice = await prisma.projectionPrice.delete({
     *   where: {
     *     // ... filter to delete one ProjectionPrice
     *   }
     * })
     * 
     */
    delete<T extends ProjectionPriceDeleteArgs>(args: SelectSubset<T, ProjectionPriceDeleteArgs<ExtArgs>>): Prisma__ProjectionPriceClient<$Result.GetResult<Prisma.$ProjectionPricePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ProjectionPrice.
     * @param {ProjectionPriceUpdateArgs} args - Arguments to update one ProjectionPrice.
     * @example
     * // Update one ProjectionPrice
     * const projectionPrice = await prisma.projectionPrice.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProjectionPriceUpdateArgs>(args: SelectSubset<T, ProjectionPriceUpdateArgs<ExtArgs>>): Prisma__ProjectionPriceClient<$Result.GetResult<Prisma.$ProjectionPricePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ProjectionPrices.
     * @param {ProjectionPriceDeleteManyArgs} args - Arguments to filter ProjectionPrices to delete.
     * @example
     * // Delete a few ProjectionPrices
     * const { count } = await prisma.projectionPrice.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProjectionPriceDeleteManyArgs>(args?: SelectSubset<T, ProjectionPriceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProjectionPrices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectionPriceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ProjectionPrices
     * const projectionPrice = await prisma.projectionPrice.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProjectionPriceUpdateManyArgs>(args: SelectSubset<T, ProjectionPriceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ProjectionPrice.
     * @param {ProjectionPriceUpsertArgs} args - Arguments to update or create a ProjectionPrice.
     * @example
     * // Update or create a ProjectionPrice
     * const projectionPrice = await prisma.projectionPrice.upsert({
     *   create: {
     *     // ... data to create a ProjectionPrice
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ProjectionPrice we want to update
     *   }
     * })
     */
    upsert<T extends ProjectionPriceUpsertArgs>(args: SelectSubset<T, ProjectionPriceUpsertArgs<ExtArgs>>): Prisma__ProjectionPriceClient<$Result.GetResult<Prisma.$ProjectionPricePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ProjectionPrices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectionPriceCountArgs} args - Arguments to filter ProjectionPrices to count.
     * @example
     * // Count the number of ProjectionPrices
     * const count = await prisma.projectionPrice.count({
     *   where: {
     *     // ... the filter for the ProjectionPrices we want to count
     *   }
     * })
    **/
    count<T extends ProjectionPriceCountArgs>(
      args?: Subset<T, ProjectionPriceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProjectionPriceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ProjectionPrice.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectionPriceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProjectionPriceAggregateArgs>(args: Subset<T, ProjectionPriceAggregateArgs>): Prisma.PrismaPromise<GetProjectionPriceAggregateType<T>>

    /**
     * Group by ProjectionPrice.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectionPriceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProjectionPriceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProjectionPriceGroupByArgs['orderBy'] }
        : { orderBy?: ProjectionPriceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProjectionPriceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProjectionPriceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ProjectionPrice model
   */
  readonly fields: ProjectionPriceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ProjectionPrice.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProjectionPriceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    cinemaSeatGroup<T extends CinemaSeatGroupDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CinemaSeatGroupDefaultArgs<ExtArgs>>): Prisma__CinemaSeatGroupClient<$Result.GetResult<Prisma.$CinemaSeatGroupPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    movieProjection<T extends MovieProjectionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MovieProjectionDefaultArgs<ExtArgs>>): Prisma__MovieProjectionClient<$Result.GetResult<Prisma.$MovieProjectionPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ProjectionPrice model
   */ 
  interface ProjectionPriceFieldRefs {
    readonly projectionId: FieldRef<"ProjectionPrice", 'String'>
    readonly groupId: FieldRef<"ProjectionPrice", 'String'>
    readonly type: FieldRef<"ProjectionPrice", 'PriceType'>
    readonly price: FieldRef<"ProjectionPrice", 'Decimal'>
    readonly currencyCode: FieldRef<"ProjectionPrice", 'CurrencyCode'>
  }
    

  // Custom InputTypes
  /**
   * ProjectionPrice findUnique
   */
  export type ProjectionPriceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectionPrice
     */
    select?: ProjectionPriceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectionPriceInclude<ExtArgs> | null
    /**
     * Filter, which ProjectionPrice to fetch.
     */
    where: ProjectionPriceWhereUniqueInput
  }

  /**
   * ProjectionPrice findUniqueOrThrow
   */
  export type ProjectionPriceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectionPrice
     */
    select?: ProjectionPriceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectionPriceInclude<ExtArgs> | null
    /**
     * Filter, which ProjectionPrice to fetch.
     */
    where: ProjectionPriceWhereUniqueInput
  }

  /**
   * ProjectionPrice findFirst
   */
  export type ProjectionPriceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectionPrice
     */
    select?: ProjectionPriceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectionPriceInclude<ExtArgs> | null
    /**
     * Filter, which ProjectionPrice to fetch.
     */
    where?: ProjectionPriceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProjectionPrices to fetch.
     */
    orderBy?: ProjectionPriceOrderByWithRelationInput | ProjectionPriceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProjectionPrices.
     */
    cursor?: ProjectionPriceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProjectionPrices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProjectionPrices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProjectionPrices.
     */
    distinct?: ProjectionPriceScalarFieldEnum | ProjectionPriceScalarFieldEnum[]
  }

  /**
   * ProjectionPrice findFirstOrThrow
   */
  export type ProjectionPriceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectionPrice
     */
    select?: ProjectionPriceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectionPriceInclude<ExtArgs> | null
    /**
     * Filter, which ProjectionPrice to fetch.
     */
    where?: ProjectionPriceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProjectionPrices to fetch.
     */
    orderBy?: ProjectionPriceOrderByWithRelationInput | ProjectionPriceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProjectionPrices.
     */
    cursor?: ProjectionPriceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProjectionPrices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProjectionPrices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProjectionPrices.
     */
    distinct?: ProjectionPriceScalarFieldEnum | ProjectionPriceScalarFieldEnum[]
  }

  /**
   * ProjectionPrice findMany
   */
  export type ProjectionPriceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectionPrice
     */
    select?: ProjectionPriceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectionPriceInclude<ExtArgs> | null
    /**
     * Filter, which ProjectionPrices to fetch.
     */
    where?: ProjectionPriceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProjectionPrices to fetch.
     */
    orderBy?: ProjectionPriceOrderByWithRelationInput | ProjectionPriceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ProjectionPrices.
     */
    cursor?: ProjectionPriceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProjectionPrices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProjectionPrices.
     */
    skip?: number
    distinct?: ProjectionPriceScalarFieldEnum | ProjectionPriceScalarFieldEnum[]
  }

  /**
   * ProjectionPrice create
   */
  export type ProjectionPriceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectionPrice
     */
    select?: ProjectionPriceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectionPriceInclude<ExtArgs> | null
    /**
     * The data needed to create a ProjectionPrice.
     */
    data: XOR<ProjectionPriceCreateInput, ProjectionPriceUncheckedCreateInput>
  }

  /**
   * ProjectionPrice createMany
   */
  export type ProjectionPriceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ProjectionPrices.
     */
    data: ProjectionPriceCreateManyInput | ProjectionPriceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ProjectionPrice createManyAndReturn
   */
  export type ProjectionPriceCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectionPrice
     */
    select?: ProjectionPriceSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many ProjectionPrices.
     */
    data: ProjectionPriceCreateManyInput | ProjectionPriceCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectionPriceIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ProjectionPrice update
   */
  export type ProjectionPriceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectionPrice
     */
    select?: ProjectionPriceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectionPriceInclude<ExtArgs> | null
    /**
     * The data needed to update a ProjectionPrice.
     */
    data: XOR<ProjectionPriceUpdateInput, ProjectionPriceUncheckedUpdateInput>
    /**
     * Choose, which ProjectionPrice to update.
     */
    where: ProjectionPriceWhereUniqueInput
  }

  /**
   * ProjectionPrice updateMany
   */
  export type ProjectionPriceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ProjectionPrices.
     */
    data: XOR<ProjectionPriceUpdateManyMutationInput, ProjectionPriceUncheckedUpdateManyInput>
    /**
     * Filter which ProjectionPrices to update
     */
    where?: ProjectionPriceWhereInput
  }

  /**
   * ProjectionPrice upsert
   */
  export type ProjectionPriceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectionPrice
     */
    select?: ProjectionPriceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectionPriceInclude<ExtArgs> | null
    /**
     * The filter to search for the ProjectionPrice to update in case it exists.
     */
    where: ProjectionPriceWhereUniqueInput
    /**
     * In case the ProjectionPrice found by the `where` argument doesn't exist, create a new ProjectionPrice with this data.
     */
    create: XOR<ProjectionPriceCreateInput, ProjectionPriceUncheckedCreateInput>
    /**
     * In case the ProjectionPrice was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProjectionPriceUpdateInput, ProjectionPriceUncheckedUpdateInput>
  }

  /**
   * ProjectionPrice delete
   */
  export type ProjectionPriceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectionPrice
     */
    select?: ProjectionPriceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectionPriceInclude<ExtArgs> | null
    /**
     * Filter which ProjectionPrice to delete.
     */
    where: ProjectionPriceWhereUniqueInput
  }

  /**
   * ProjectionPrice deleteMany
   */
  export type ProjectionPriceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProjectionPrices to delete
     */
    where?: ProjectionPriceWhereInput
  }

  /**
   * ProjectionPrice without action
   */
  export type ProjectionPriceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectionPrice
     */
    select?: ProjectionPriceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectionPriceInclude<ExtArgs> | null
  }


  /**
   * Model AdminUser
   */

  export type AggregateAdminUser = {
    _count: AdminUserCountAggregateOutputType | null
    _min: AdminUserMinAggregateOutputType | null
    _max: AdminUserMaxAggregateOutputType | null
  }

  export type AdminUserMinAggregateOutputType = {
    id: string | null
    email: string | null
    password: string | null
    fullName: string | null
    role: $Enums.AdminRole | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AdminUserMaxAggregateOutputType = {
    id: string | null
    email: string | null
    password: string | null
    fullName: string | null
    role: $Enums.AdminRole | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AdminUserCountAggregateOutputType = {
    id: number
    email: number
    password: number
    fullName: number
    role: number
    cinemaIds: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type AdminUserMinAggregateInputType = {
    id?: true
    email?: true
    password?: true
    fullName?: true
    role?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AdminUserMaxAggregateInputType = {
    id?: true
    email?: true
    password?: true
    fullName?: true
    role?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AdminUserCountAggregateInputType = {
    id?: true
    email?: true
    password?: true
    fullName?: true
    role?: true
    cinemaIds?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type AdminUserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AdminUser to aggregate.
     */
    where?: AdminUserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdminUsers to fetch.
     */
    orderBy?: AdminUserOrderByWithRelationInput | AdminUserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AdminUserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdminUsers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdminUsers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AdminUsers
    **/
    _count?: true | AdminUserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AdminUserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AdminUserMaxAggregateInputType
  }

  export type GetAdminUserAggregateType<T extends AdminUserAggregateArgs> = {
        [P in keyof T & keyof AggregateAdminUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAdminUser[P]>
      : GetScalarType<T[P], AggregateAdminUser[P]>
  }




  export type AdminUserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AdminUserWhereInput
    orderBy?: AdminUserOrderByWithAggregationInput | AdminUserOrderByWithAggregationInput[]
    by: AdminUserScalarFieldEnum[] | AdminUserScalarFieldEnum
    having?: AdminUserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AdminUserCountAggregateInputType | true
    _min?: AdminUserMinAggregateInputType
    _max?: AdminUserMaxAggregateInputType
  }

  export type AdminUserGroupByOutputType = {
    id: string
    email: string
    password: string
    fullName: string
    role: $Enums.AdminRole
    cinemaIds: JsonValue
    createdAt: Date
    updatedAt: Date
    _count: AdminUserCountAggregateOutputType | null
    _min: AdminUserMinAggregateOutputType | null
    _max: AdminUserMaxAggregateOutputType | null
  }

  type GetAdminUserGroupByPayload<T extends AdminUserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AdminUserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AdminUserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AdminUserGroupByOutputType[P]>
            : GetScalarType<T[P], AdminUserGroupByOutputType[P]>
        }
      >
    >


  export type AdminUserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    password?: boolean
    fullName?: boolean
    role?: boolean
    cinemaIds?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    ValidatedReservationSeats?: boolean | AdminUser$ValidatedReservationSeatsArgs<ExtArgs>
    _count?: boolean | AdminUserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["adminUser"]>

  export type AdminUserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    password?: boolean
    fullName?: boolean
    role?: boolean
    cinemaIds?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["adminUser"]>

  export type AdminUserSelectScalar = {
    id?: boolean
    email?: boolean
    password?: boolean
    fullName?: boolean
    role?: boolean
    cinemaIds?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type AdminUserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    ValidatedReservationSeats?: boolean | AdminUser$ValidatedReservationSeatsArgs<ExtArgs>
    _count?: boolean | AdminUserCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type AdminUserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $AdminUserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AdminUser"
    objects: {
      ValidatedReservationSeats: Prisma.$ReservationSeatsPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      email: string
      password: string
      fullName: string
      role: $Enums.AdminRole
      cinemaIds: Prisma.JsonValue
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["adminUser"]>
    composites: {}
  }

  type AdminUserGetPayload<S extends boolean | null | undefined | AdminUserDefaultArgs> = $Result.GetResult<Prisma.$AdminUserPayload, S>

  type AdminUserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<AdminUserFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: AdminUserCountAggregateInputType | true
    }

  export interface AdminUserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AdminUser'], meta: { name: 'AdminUser' } }
    /**
     * Find zero or one AdminUser that matches the filter.
     * @param {AdminUserFindUniqueArgs} args - Arguments to find a AdminUser
     * @example
     * // Get one AdminUser
     * const adminUser = await prisma.adminUser.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AdminUserFindUniqueArgs>(args: SelectSubset<T, AdminUserFindUniqueArgs<ExtArgs>>): Prisma__AdminUserClient<$Result.GetResult<Prisma.$AdminUserPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one AdminUser that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {AdminUserFindUniqueOrThrowArgs} args - Arguments to find a AdminUser
     * @example
     * // Get one AdminUser
     * const adminUser = await prisma.adminUser.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AdminUserFindUniqueOrThrowArgs>(args: SelectSubset<T, AdminUserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AdminUserClient<$Result.GetResult<Prisma.$AdminUserPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first AdminUser that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminUserFindFirstArgs} args - Arguments to find a AdminUser
     * @example
     * // Get one AdminUser
     * const adminUser = await prisma.adminUser.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AdminUserFindFirstArgs>(args?: SelectSubset<T, AdminUserFindFirstArgs<ExtArgs>>): Prisma__AdminUserClient<$Result.GetResult<Prisma.$AdminUserPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first AdminUser that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminUserFindFirstOrThrowArgs} args - Arguments to find a AdminUser
     * @example
     * // Get one AdminUser
     * const adminUser = await prisma.adminUser.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AdminUserFindFirstOrThrowArgs>(args?: SelectSubset<T, AdminUserFindFirstOrThrowArgs<ExtArgs>>): Prisma__AdminUserClient<$Result.GetResult<Prisma.$AdminUserPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more AdminUsers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminUserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AdminUsers
     * const adminUsers = await prisma.adminUser.findMany()
     * 
     * // Get first 10 AdminUsers
     * const adminUsers = await prisma.adminUser.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const adminUserWithIdOnly = await prisma.adminUser.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AdminUserFindManyArgs>(args?: SelectSubset<T, AdminUserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdminUserPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a AdminUser.
     * @param {AdminUserCreateArgs} args - Arguments to create a AdminUser.
     * @example
     * // Create one AdminUser
     * const AdminUser = await prisma.adminUser.create({
     *   data: {
     *     // ... data to create a AdminUser
     *   }
     * })
     * 
     */
    create<T extends AdminUserCreateArgs>(args: SelectSubset<T, AdminUserCreateArgs<ExtArgs>>): Prisma__AdminUserClient<$Result.GetResult<Prisma.$AdminUserPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many AdminUsers.
     * @param {AdminUserCreateManyArgs} args - Arguments to create many AdminUsers.
     * @example
     * // Create many AdminUsers
     * const adminUser = await prisma.adminUser.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AdminUserCreateManyArgs>(args?: SelectSubset<T, AdminUserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AdminUsers and returns the data saved in the database.
     * @param {AdminUserCreateManyAndReturnArgs} args - Arguments to create many AdminUsers.
     * @example
     * // Create many AdminUsers
     * const adminUser = await prisma.adminUser.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AdminUsers and only return the `id`
     * const adminUserWithIdOnly = await prisma.adminUser.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AdminUserCreateManyAndReturnArgs>(args?: SelectSubset<T, AdminUserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdminUserPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a AdminUser.
     * @param {AdminUserDeleteArgs} args - Arguments to delete one AdminUser.
     * @example
     * // Delete one AdminUser
     * const AdminUser = await prisma.adminUser.delete({
     *   where: {
     *     // ... filter to delete one AdminUser
     *   }
     * })
     * 
     */
    delete<T extends AdminUserDeleteArgs>(args: SelectSubset<T, AdminUserDeleteArgs<ExtArgs>>): Prisma__AdminUserClient<$Result.GetResult<Prisma.$AdminUserPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one AdminUser.
     * @param {AdminUserUpdateArgs} args - Arguments to update one AdminUser.
     * @example
     * // Update one AdminUser
     * const adminUser = await prisma.adminUser.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AdminUserUpdateArgs>(args: SelectSubset<T, AdminUserUpdateArgs<ExtArgs>>): Prisma__AdminUserClient<$Result.GetResult<Prisma.$AdminUserPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more AdminUsers.
     * @param {AdminUserDeleteManyArgs} args - Arguments to filter AdminUsers to delete.
     * @example
     * // Delete a few AdminUsers
     * const { count } = await prisma.adminUser.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AdminUserDeleteManyArgs>(args?: SelectSubset<T, AdminUserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AdminUsers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminUserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AdminUsers
     * const adminUser = await prisma.adminUser.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AdminUserUpdateManyArgs>(args: SelectSubset<T, AdminUserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one AdminUser.
     * @param {AdminUserUpsertArgs} args - Arguments to update or create a AdminUser.
     * @example
     * // Update or create a AdminUser
     * const adminUser = await prisma.adminUser.upsert({
     *   create: {
     *     // ... data to create a AdminUser
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AdminUser we want to update
     *   }
     * })
     */
    upsert<T extends AdminUserUpsertArgs>(args: SelectSubset<T, AdminUserUpsertArgs<ExtArgs>>): Prisma__AdminUserClient<$Result.GetResult<Prisma.$AdminUserPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of AdminUsers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminUserCountArgs} args - Arguments to filter AdminUsers to count.
     * @example
     * // Count the number of AdminUsers
     * const count = await prisma.adminUser.count({
     *   where: {
     *     // ... the filter for the AdminUsers we want to count
     *   }
     * })
    **/
    count<T extends AdminUserCountArgs>(
      args?: Subset<T, AdminUserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AdminUserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AdminUser.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminUserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AdminUserAggregateArgs>(args: Subset<T, AdminUserAggregateArgs>): Prisma.PrismaPromise<GetAdminUserAggregateType<T>>

    /**
     * Group by AdminUser.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminUserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AdminUserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AdminUserGroupByArgs['orderBy'] }
        : { orderBy?: AdminUserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AdminUserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAdminUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AdminUser model
   */
  readonly fields: AdminUserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AdminUser.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AdminUserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    ValidatedReservationSeats<T extends AdminUser$ValidatedReservationSeatsArgs<ExtArgs> = {}>(args?: Subset<T, AdminUser$ValidatedReservationSeatsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReservationSeatsPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AdminUser model
   */ 
  interface AdminUserFieldRefs {
    readonly id: FieldRef<"AdminUser", 'String'>
    readonly email: FieldRef<"AdminUser", 'String'>
    readonly password: FieldRef<"AdminUser", 'String'>
    readonly fullName: FieldRef<"AdminUser", 'String'>
    readonly role: FieldRef<"AdminUser", 'AdminRole'>
    readonly cinemaIds: FieldRef<"AdminUser", 'Json'>
    readonly createdAt: FieldRef<"AdminUser", 'DateTime'>
    readonly updatedAt: FieldRef<"AdminUser", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AdminUser findUnique
   */
  export type AdminUserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminUser
     */
    select?: AdminUserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminUserInclude<ExtArgs> | null
    /**
     * Filter, which AdminUser to fetch.
     */
    where: AdminUserWhereUniqueInput
  }

  /**
   * AdminUser findUniqueOrThrow
   */
  export type AdminUserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminUser
     */
    select?: AdminUserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminUserInclude<ExtArgs> | null
    /**
     * Filter, which AdminUser to fetch.
     */
    where: AdminUserWhereUniqueInput
  }

  /**
   * AdminUser findFirst
   */
  export type AdminUserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminUser
     */
    select?: AdminUserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminUserInclude<ExtArgs> | null
    /**
     * Filter, which AdminUser to fetch.
     */
    where?: AdminUserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdminUsers to fetch.
     */
    orderBy?: AdminUserOrderByWithRelationInput | AdminUserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AdminUsers.
     */
    cursor?: AdminUserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdminUsers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdminUsers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AdminUsers.
     */
    distinct?: AdminUserScalarFieldEnum | AdminUserScalarFieldEnum[]
  }

  /**
   * AdminUser findFirstOrThrow
   */
  export type AdminUserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminUser
     */
    select?: AdminUserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminUserInclude<ExtArgs> | null
    /**
     * Filter, which AdminUser to fetch.
     */
    where?: AdminUserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdminUsers to fetch.
     */
    orderBy?: AdminUserOrderByWithRelationInput | AdminUserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AdminUsers.
     */
    cursor?: AdminUserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdminUsers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdminUsers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AdminUsers.
     */
    distinct?: AdminUserScalarFieldEnum | AdminUserScalarFieldEnum[]
  }

  /**
   * AdminUser findMany
   */
  export type AdminUserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminUser
     */
    select?: AdminUserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminUserInclude<ExtArgs> | null
    /**
     * Filter, which AdminUsers to fetch.
     */
    where?: AdminUserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdminUsers to fetch.
     */
    orderBy?: AdminUserOrderByWithRelationInput | AdminUserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AdminUsers.
     */
    cursor?: AdminUserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdminUsers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdminUsers.
     */
    skip?: number
    distinct?: AdminUserScalarFieldEnum | AdminUserScalarFieldEnum[]
  }

  /**
   * AdminUser create
   */
  export type AdminUserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminUser
     */
    select?: AdminUserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminUserInclude<ExtArgs> | null
    /**
     * The data needed to create a AdminUser.
     */
    data: XOR<AdminUserCreateInput, AdminUserUncheckedCreateInput>
  }

  /**
   * AdminUser createMany
   */
  export type AdminUserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AdminUsers.
     */
    data: AdminUserCreateManyInput | AdminUserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AdminUser createManyAndReturn
   */
  export type AdminUserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminUser
     */
    select?: AdminUserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many AdminUsers.
     */
    data: AdminUserCreateManyInput | AdminUserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AdminUser update
   */
  export type AdminUserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminUser
     */
    select?: AdminUserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminUserInclude<ExtArgs> | null
    /**
     * The data needed to update a AdminUser.
     */
    data: XOR<AdminUserUpdateInput, AdminUserUncheckedUpdateInput>
    /**
     * Choose, which AdminUser to update.
     */
    where: AdminUserWhereUniqueInput
  }

  /**
   * AdminUser updateMany
   */
  export type AdminUserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AdminUsers.
     */
    data: XOR<AdminUserUpdateManyMutationInput, AdminUserUncheckedUpdateManyInput>
    /**
     * Filter which AdminUsers to update
     */
    where?: AdminUserWhereInput
  }

  /**
   * AdminUser upsert
   */
  export type AdminUserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminUser
     */
    select?: AdminUserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminUserInclude<ExtArgs> | null
    /**
     * The filter to search for the AdminUser to update in case it exists.
     */
    where: AdminUserWhereUniqueInput
    /**
     * In case the AdminUser found by the `where` argument doesn't exist, create a new AdminUser with this data.
     */
    create: XOR<AdminUserCreateInput, AdminUserUncheckedCreateInput>
    /**
     * In case the AdminUser was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AdminUserUpdateInput, AdminUserUncheckedUpdateInput>
  }

  /**
   * AdminUser delete
   */
  export type AdminUserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminUser
     */
    select?: AdminUserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminUserInclude<ExtArgs> | null
    /**
     * Filter which AdminUser to delete.
     */
    where: AdminUserWhereUniqueInput
  }

  /**
   * AdminUser deleteMany
   */
  export type AdminUserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AdminUsers to delete
     */
    where?: AdminUserWhereInput
  }

  /**
   * AdminUser.ValidatedReservationSeats
   */
  export type AdminUser$ValidatedReservationSeatsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReservationSeats
     */
    select?: ReservationSeatsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReservationSeatsInclude<ExtArgs> | null
    where?: ReservationSeatsWhereInput
    orderBy?: ReservationSeatsOrderByWithRelationInput | ReservationSeatsOrderByWithRelationInput[]
    cursor?: ReservationSeatsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ReservationSeatsScalarFieldEnum | ReservationSeatsScalarFieldEnum[]
  }

  /**
   * AdminUser without action
   */
  export type AdminUserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminUser
     */
    select?: AdminUserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminUserInclude<ExtArgs> | null
  }


  /**
   * Model Reservation
   */

  export type AggregateReservation = {
    _count: ReservationCountAggregateOutputType | null
    _min: ReservationMinAggregateOutputType | null
    _max: ReservationMaxAggregateOutputType | null
  }

  export type ReservationMinAggregateOutputType = {
    id: string | null
    eventId: string | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type ReservationMaxAggregateOutputType = {
    id: string | null
    eventId: string | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type ReservationCountAggregateOutputType = {
    id: number
    eventId: number
    customerInformation: number
    createdAt: number
    updatedAt: number
    options: number
    deletedAt: number
    _all: number
  }


  export type ReservationMinAggregateInputType = {
    id?: true
    eventId?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type ReservationMaxAggregateInputType = {
    id?: true
    eventId?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type ReservationCountAggregateInputType = {
    id?: true
    eventId?: true
    customerInformation?: true
    createdAt?: true
    updatedAt?: true
    options?: true
    deletedAt?: true
    _all?: true
  }

  export type ReservationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Reservation to aggregate.
     */
    where?: ReservationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reservations to fetch.
     */
    orderBy?: ReservationOrderByWithRelationInput | ReservationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ReservationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reservations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reservations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Reservations
    **/
    _count?: true | ReservationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ReservationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ReservationMaxAggregateInputType
  }

  export type GetReservationAggregateType<T extends ReservationAggregateArgs> = {
        [P in keyof T & keyof AggregateReservation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateReservation[P]>
      : GetScalarType<T[P], AggregateReservation[P]>
  }




  export type ReservationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReservationWhereInput
    orderBy?: ReservationOrderByWithAggregationInput | ReservationOrderByWithAggregationInput[]
    by: ReservationScalarFieldEnum[] | ReservationScalarFieldEnum
    having?: ReservationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ReservationCountAggregateInputType | true
    _min?: ReservationMinAggregateInputType
    _max?: ReservationMaxAggregateInputType
  }

  export type ReservationGroupByOutputType = {
    id: string
    eventId: string
    customerInformation: JsonValue
    createdAt: Date
    updatedAt: Date
    options: JsonValue
    deletedAt: Date | null
    _count: ReservationCountAggregateOutputType | null
    _min: ReservationMinAggregateOutputType | null
    _max: ReservationMaxAggregateOutputType | null
  }

  type GetReservationGroupByPayload<T extends ReservationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ReservationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ReservationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ReservationGroupByOutputType[P]>
            : GetScalarType<T[P], ReservationGroupByOutputType[P]>
        }
      >
    >


  export type ReservationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    eventId?: boolean
    customerInformation?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    options?: boolean
    deletedAt?: boolean
    movieProjection?: boolean | MovieProjectionDefaultArgs<ExtArgs>
    reservationSeats?: boolean | Reservation$reservationSeatsArgs<ExtArgs>
    _count?: boolean | ReservationCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["reservation"]>

  export type ReservationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    eventId?: boolean
    customerInformation?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    options?: boolean
    deletedAt?: boolean
    movieProjection?: boolean | MovieProjectionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["reservation"]>

  export type ReservationSelectScalar = {
    id?: boolean
    eventId?: boolean
    customerInformation?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    options?: boolean
    deletedAt?: boolean
  }

  export type ReservationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    movieProjection?: boolean | MovieProjectionDefaultArgs<ExtArgs>
    reservationSeats?: boolean | Reservation$reservationSeatsArgs<ExtArgs>
    _count?: boolean | ReservationCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ReservationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    movieProjection?: boolean | MovieProjectionDefaultArgs<ExtArgs>
  }

  export type $ReservationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Reservation"
    objects: {
      movieProjection: Prisma.$MovieProjectionPayload<ExtArgs>
      reservationSeats: Prisma.$ReservationSeatsPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      eventId: string
      customerInformation: Prisma.JsonValue
      createdAt: Date
      updatedAt: Date
      options: Prisma.JsonValue
      deletedAt: Date | null
    }, ExtArgs["result"]["reservation"]>
    composites: {}
  }

  type ReservationGetPayload<S extends boolean | null | undefined | ReservationDefaultArgs> = $Result.GetResult<Prisma.$ReservationPayload, S>

  type ReservationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ReservationFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ReservationCountAggregateInputType | true
    }

  export interface ReservationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Reservation'], meta: { name: 'Reservation' } }
    /**
     * Find zero or one Reservation that matches the filter.
     * @param {ReservationFindUniqueArgs} args - Arguments to find a Reservation
     * @example
     * // Get one Reservation
     * const reservation = await prisma.reservation.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ReservationFindUniqueArgs>(args: SelectSubset<T, ReservationFindUniqueArgs<ExtArgs>>): Prisma__ReservationClient<$Result.GetResult<Prisma.$ReservationPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Reservation that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ReservationFindUniqueOrThrowArgs} args - Arguments to find a Reservation
     * @example
     * // Get one Reservation
     * const reservation = await prisma.reservation.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ReservationFindUniqueOrThrowArgs>(args: SelectSubset<T, ReservationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ReservationClient<$Result.GetResult<Prisma.$ReservationPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Reservation that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReservationFindFirstArgs} args - Arguments to find a Reservation
     * @example
     * // Get one Reservation
     * const reservation = await prisma.reservation.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ReservationFindFirstArgs>(args?: SelectSubset<T, ReservationFindFirstArgs<ExtArgs>>): Prisma__ReservationClient<$Result.GetResult<Prisma.$ReservationPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Reservation that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReservationFindFirstOrThrowArgs} args - Arguments to find a Reservation
     * @example
     * // Get one Reservation
     * const reservation = await prisma.reservation.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ReservationFindFirstOrThrowArgs>(args?: SelectSubset<T, ReservationFindFirstOrThrowArgs<ExtArgs>>): Prisma__ReservationClient<$Result.GetResult<Prisma.$ReservationPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Reservations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReservationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Reservations
     * const reservations = await prisma.reservation.findMany()
     * 
     * // Get first 10 Reservations
     * const reservations = await prisma.reservation.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const reservationWithIdOnly = await prisma.reservation.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ReservationFindManyArgs>(args?: SelectSubset<T, ReservationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReservationPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Reservation.
     * @param {ReservationCreateArgs} args - Arguments to create a Reservation.
     * @example
     * // Create one Reservation
     * const Reservation = await prisma.reservation.create({
     *   data: {
     *     // ... data to create a Reservation
     *   }
     * })
     * 
     */
    create<T extends ReservationCreateArgs>(args: SelectSubset<T, ReservationCreateArgs<ExtArgs>>): Prisma__ReservationClient<$Result.GetResult<Prisma.$ReservationPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Reservations.
     * @param {ReservationCreateManyArgs} args - Arguments to create many Reservations.
     * @example
     * // Create many Reservations
     * const reservation = await prisma.reservation.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ReservationCreateManyArgs>(args?: SelectSubset<T, ReservationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Reservations and returns the data saved in the database.
     * @param {ReservationCreateManyAndReturnArgs} args - Arguments to create many Reservations.
     * @example
     * // Create many Reservations
     * const reservation = await prisma.reservation.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Reservations and only return the `id`
     * const reservationWithIdOnly = await prisma.reservation.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ReservationCreateManyAndReturnArgs>(args?: SelectSubset<T, ReservationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReservationPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Reservation.
     * @param {ReservationDeleteArgs} args - Arguments to delete one Reservation.
     * @example
     * // Delete one Reservation
     * const Reservation = await prisma.reservation.delete({
     *   where: {
     *     // ... filter to delete one Reservation
     *   }
     * })
     * 
     */
    delete<T extends ReservationDeleteArgs>(args: SelectSubset<T, ReservationDeleteArgs<ExtArgs>>): Prisma__ReservationClient<$Result.GetResult<Prisma.$ReservationPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Reservation.
     * @param {ReservationUpdateArgs} args - Arguments to update one Reservation.
     * @example
     * // Update one Reservation
     * const reservation = await prisma.reservation.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ReservationUpdateArgs>(args: SelectSubset<T, ReservationUpdateArgs<ExtArgs>>): Prisma__ReservationClient<$Result.GetResult<Prisma.$ReservationPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Reservations.
     * @param {ReservationDeleteManyArgs} args - Arguments to filter Reservations to delete.
     * @example
     * // Delete a few Reservations
     * const { count } = await prisma.reservation.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ReservationDeleteManyArgs>(args?: SelectSubset<T, ReservationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Reservations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReservationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Reservations
     * const reservation = await prisma.reservation.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ReservationUpdateManyArgs>(args: SelectSubset<T, ReservationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Reservation.
     * @param {ReservationUpsertArgs} args - Arguments to update or create a Reservation.
     * @example
     * // Update or create a Reservation
     * const reservation = await prisma.reservation.upsert({
     *   create: {
     *     // ... data to create a Reservation
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Reservation we want to update
     *   }
     * })
     */
    upsert<T extends ReservationUpsertArgs>(args: SelectSubset<T, ReservationUpsertArgs<ExtArgs>>): Prisma__ReservationClient<$Result.GetResult<Prisma.$ReservationPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Reservations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReservationCountArgs} args - Arguments to filter Reservations to count.
     * @example
     * // Count the number of Reservations
     * const count = await prisma.reservation.count({
     *   where: {
     *     // ... the filter for the Reservations we want to count
     *   }
     * })
    **/
    count<T extends ReservationCountArgs>(
      args?: Subset<T, ReservationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ReservationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Reservation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReservationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ReservationAggregateArgs>(args: Subset<T, ReservationAggregateArgs>): Prisma.PrismaPromise<GetReservationAggregateType<T>>

    /**
     * Group by Reservation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReservationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ReservationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ReservationGroupByArgs['orderBy'] }
        : { orderBy?: ReservationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ReservationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetReservationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Reservation model
   */
  readonly fields: ReservationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Reservation.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ReservationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    movieProjection<T extends MovieProjectionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MovieProjectionDefaultArgs<ExtArgs>>): Prisma__MovieProjectionClient<$Result.GetResult<Prisma.$MovieProjectionPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    reservationSeats<T extends Reservation$reservationSeatsArgs<ExtArgs> = {}>(args?: Subset<T, Reservation$reservationSeatsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReservationSeatsPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Reservation model
   */ 
  interface ReservationFieldRefs {
    readonly id: FieldRef<"Reservation", 'String'>
    readonly eventId: FieldRef<"Reservation", 'String'>
    readonly customerInformation: FieldRef<"Reservation", 'Json'>
    readonly createdAt: FieldRef<"Reservation", 'DateTime'>
    readonly updatedAt: FieldRef<"Reservation", 'DateTime'>
    readonly options: FieldRef<"Reservation", 'Json'>
    readonly deletedAt: FieldRef<"Reservation", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Reservation findUnique
   */
  export type ReservationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reservation
     */
    select?: ReservationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReservationInclude<ExtArgs> | null
    /**
     * Filter, which Reservation to fetch.
     */
    where: ReservationWhereUniqueInput
  }

  /**
   * Reservation findUniqueOrThrow
   */
  export type ReservationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reservation
     */
    select?: ReservationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReservationInclude<ExtArgs> | null
    /**
     * Filter, which Reservation to fetch.
     */
    where: ReservationWhereUniqueInput
  }

  /**
   * Reservation findFirst
   */
  export type ReservationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reservation
     */
    select?: ReservationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReservationInclude<ExtArgs> | null
    /**
     * Filter, which Reservation to fetch.
     */
    where?: ReservationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reservations to fetch.
     */
    orderBy?: ReservationOrderByWithRelationInput | ReservationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Reservations.
     */
    cursor?: ReservationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reservations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reservations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Reservations.
     */
    distinct?: ReservationScalarFieldEnum | ReservationScalarFieldEnum[]
  }

  /**
   * Reservation findFirstOrThrow
   */
  export type ReservationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reservation
     */
    select?: ReservationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReservationInclude<ExtArgs> | null
    /**
     * Filter, which Reservation to fetch.
     */
    where?: ReservationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reservations to fetch.
     */
    orderBy?: ReservationOrderByWithRelationInput | ReservationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Reservations.
     */
    cursor?: ReservationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reservations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reservations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Reservations.
     */
    distinct?: ReservationScalarFieldEnum | ReservationScalarFieldEnum[]
  }

  /**
   * Reservation findMany
   */
  export type ReservationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reservation
     */
    select?: ReservationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReservationInclude<ExtArgs> | null
    /**
     * Filter, which Reservations to fetch.
     */
    where?: ReservationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reservations to fetch.
     */
    orderBy?: ReservationOrderByWithRelationInput | ReservationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Reservations.
     */
    cursor?: ReservationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reservations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reservations.
     */
    skip?: number
    distinct?: ReservationScalarFieldEnum | ReservationScalarFieldEnum[]
  }

  /**
   * Reservation create
   */
  export type ReservationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reservation
     */
    select?: ReservationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReservationInclude<ExtArgs> | null
    /**
     * The data needed to create a Reservation.
     */
    data: XOR<ReservationCreateInput, ReservationUncheckedCreateInput>
  }

  /**
   * Reservation createMany
   */
  export type ReservationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Reservations.
     */
    data: ReservationCreateManyInput | ReservationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Reservation createManyAndReturn
   */
  export type ReservationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reservation
     */
    select?: ReservationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Reservations.
     */
    data: ReservationCreateManyInput | ReservationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReservationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Reservation update
   */
  export type ReservationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reservation
     */
    select?: ReservationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReservationInclude<ExtArgs> | null
    /**
     * The data needed to update a Reservation.
     */
    data: XOR<ReservationUpdateInput, ReservationUncheckedUpdateInput>
    /**
     * Choose, which Reservation to update.
     */
    where: ReservationWhereUniqueInput
  }

  /**
   * Reservation updateMany
   */
  export type ReservationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Reservations.
     */
    data: XOR<ReservationUpdateManyMutationInput, ReservationUncheckedUpdateManyInput>
    /**
     * Filter which Reservations to update
     */
    where?: ReservationWhereInput
  }

  /**
   * Reservation upsert
   */
  export type ReservationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reservation
     */
    select?: ReservationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReservationInclude<ExtArgs> | null
    /**
     * The filter to search for the Reservation to update in case it exists.
     */
    where: ReservationWhereUniqueInput
    /**
     * In case the Reservation found by the `where` argument doesn't exist, create a new Reservation with this data.
     */
    create: XOR<ReservationCreateInput, ReservationUncheckedCreateInput>
    /**
     * In case the Reservation was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ReservationUpdateInput, ReservationUncheckedUpdateInput>
  }

  /**
   * Reservation delete
   */
  export type ReservationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reservation
     */
    select?: ReservationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReservationInclude<ExtArgs> | null
    /**
     * Filter which Reservation to delete.
     */
    where: ReservationWhereUniqueInput
  }

  /**
   * Reservation deleteMany
   */
  export type ReservationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Reservations to delete
     */
    where?: ReservationWhereInput
  }

  /**
   * Reservation.reservationSeats
   */
  export type Reservation$reservationSeatsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReservationSeats
     */
    select?: ReservationSeatsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReservationSeatsInclude<ExtArgs> | null
    where?: ReservationSeatsWhereInput
    orderBy?: ReservationSeatsOrderByWithRelationInput | ReservationSeatsOrderByWithRelationInput[]
    cursor?: ReservationSeatsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ReservationSeatsScalarFieldEnum | ReservationSeatsScalarFieldEnum[]
  }

  /**
   * Reservation without action
   */
  export type ReservationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reservation
     */
    select?: ReservationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReservationInclude<ExtArgs> | null
  }


  /**
   * Model ReservationSeats
   */

  export type AggregateReservationSeats = {
    _count: ReservationSeatsCountAggregateOutputType | null
    _min: ReservationSeatsMinAggregateOutputType | null
    _max: ReservationSeatsMaxAggregateOutputType | null
  }

  export type ReservationSeatsMinAggregateOutputType = {
    id: string | null
    reservationId: string | null
    eventId: string | null
    seatId: string | null
    deletedAt: Date | null
    validatedAt: Date | null
    validatedByAdminUserId: string | null
  }

  export type ReservationSeatsMaxAggregateOutputType = {
    id: string | null
    reservationId: string | null
    eventId: string | null
    seatId: string | null
    deletedAt: Date | null
    validatedAt: Date | null
    validatedByAdminUserId: string | null
  }

  export type ReservationSeatsCountAggregateOutputType = {
    id: number
    reservationId: number
    eventId: number
    seatId: number
    options: number
    deletedAt: number
    validatedAt: number
    validatedByAdminUserId: number
    _all: number
  }


  export type ReservationSeatsMinAggregateInputType = {
    id?: true
    reservationId?: true
    eventId?: true
    seatId?: true
    deletedAt?: true
    validatedAt?: true
    validatedByAdminUserId?: true
  }

  export type ReservationSeatsMaxAggregateInputType = {
    id?: true
    reservationId?: true
    eventId?: true
    seatId?: true
    deletedAt?: true
    validatedAt?: true
    validatedByAdminUserId?: true
  }

  export type ReservationSeatsCountAggregateInputType = {
    id?: true
    reservationId?: true
    eventId?: true
    seatId?: true
    options?: true
    deletedAt?: true
    validatedAt?: true
    validatedByAdminUserId?: true
    _all?: true
  }

  export type ReservationSeatsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ReservationSeats to aggregate.
     */
    where?: ReservationSeatsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ReservationSeats to fetch.
     */
    orderBy?: ReservationSeatsOrderByWithRelationInput | ReservationSeatsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ReservationSeatsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ReservationSeats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ReservationSeats.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ReservationSeats
    **/
    _count?: true | ReservationSeatsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ReservationSeatsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ReservationSeatsMaxAggregateInputType
  }

  export type GetReservationSeatsAggregateType<T extends ReservationSeatsAggregateArgs> = {
        [P in keyof T & keyof AggregateReservationSeats]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateReservationSeats[P]>
      : GetScalarType<T[P], AggregateReservationSeats[P]>
  }




  export type ReservationSeatsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReservationSeatsWhereInput
    orderBy?: ReservationSeatsOrderByWithAggregationInput | ReservationSeatsOrderByWithAggregationInput[]
    by: ReservationSeatsScalarFieldEnum[] | ReservationSeatsScalarFieldEnum
    having?: ReservationSeatsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ReservationSeatsCountAggregateInputType | true
    _min?: ReservationSeatsMinAggregateInputType
    _max?: ReservationSeatsMaxAggregateInputType
  }

  export type ReservationSeatsGroupByOutputType = {
    id: string
    reservationId: string
    eventId: string
    seatId: string
    options: JsonValue
    deletedAt: Date | null
    validatedAt: Date | null
    validatedByAdminUserId: string | null
    _count: ReservationSeatsCountAggregateOutputType | null
    _min: ReservationSeatsMinAggregateOutputType | null
    _max: ReservationSeatsMaxAggregateOutputType | null
  }

  type GetReservationSeatsGroupByPayload<T extends ReservationSeatsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ReservationSeatsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ReservationSeatsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ReservationSeatsGroupByOutputType[P]>
            : GetScalarType<T[P], ReservationSeatsGroupByOutputType[P]>
        }
      >
    >


  export type ReservationSeatsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    reservationId?: boolean
    eventId?: boolean
    seatId?: boolean
    options?: boolean
    deletedAt?: boolean
    validatedAt?: boolean
    validatedByAdminUserId?: boolean
    reservation?: boolean | ReservationDefaultArgs<ExtArgs>
    cinemaSeat?: boolean | CinemaSeatDefaultArgs<ExtArgs>
    validatedByAdminUser?: boolean | ReservationSeats$validatedByAdminUserArgs<ExtArgs>
  }, ExtArgs["result"]["reservationSeats"]>

  export type ReservationSeatsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    reservationId?: boolean
    eventId?: boolean
    seatId?: boolean
    options?: boolean
    deletedAt?: boolean
    validatedAt?: boolean
    validatedByAdminUserId?: boolean
    reservation?: boolean | ReservationDefaultArgs<ExtArgs>
    cinemaSeat?: boolean | CinemaSeatDefaultArgs<ExtArgs>
    validatedByAdminUser?: boolean | ReservationSeats$validatedByAdminUserArgs<ExtArgs>
  }, ExtArgs["result"]["reservationSeats"]>

  export type ReservationSeatsSelectScalar = {
    id?: boolean
    reservationId?: boolean
    eventId?: boolean
    seatId?: boolean
    options?: boolean
    deletedAt?: boolean
    validatedAt?: boolean
    validatedByAdminUserId?: boolean
  }

  export type ReservationSeatsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    reservation?: boolean | ReservationDefaultArgs<ExtArgs>
    cinemaSeat?: boolean | CinemaSeatDefaultArgs<ExtArgs>
    validatedByAdminUser?: boolean | ReservationSeats$validatedByAdminUserArgs<ExtArgs>
  }
  export type ReservationSeatsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    reservation?: boolean | ReservationDefaultArgs<ExtArgs>
    cinemaSeat?: boolean | CinemaSeatDefaultArgs<ExtArgs>
    validatedByAdminUser?: boolean | ReservationSeats$validatedByAdminUserArgs<ExtArgs>
  }

  export type $ReservationSeatsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ReservationSeats"
    objects: {
      reservation: Prisma.$ReservationPayload<ExtArgs>
      cinemaSeat: Prisma.$CinemaSeatPayload<ExtArgs>
      validatedByAdminUser: Prisma.$AdminUserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      reservationId: string
      eventId: string
      seatId: string
      options: Prisma.JsonValue
      deletedAt: Date | null
      validatedAt: Date | null
      validatedByAdminUserId: string | null
    }, ExtArgs["result"]["reservationSeats"]>
    composites: {}
  }

  type ReservationSeatsGetPayload<S extends boolean | null | undefined | ReservationSeatsDefaultArgs> = $Result.GetResult<Prisma.$ReservationSeatsPayload, S>

  type ReservationSeatsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ReservationSeatsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ReservationSeatsCountAggregateInputType | true
    }

  export interface ReservationSeatsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ReservationSeats'], meta: { name: 'ReservationSeats' } }
    /**
     * Find zero or one ReservationSeats that matches the filter.
     * @param {ReservationSeatsFindUniqueArgs} args - Arguments to find a ReservationSeats
     * @example
     * // Get one ReservationSeats
     * const reservationSeats = await prisma.reservationSeats.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ReservationSeatsFindUniqueArgs>(args: SelectSubset<T, ReservationSeatsFindUniqueArgs<ExtArgs>>): Prisma__ReservationSeatsClient<$Result.GetResult<Prisma.$ReservationSeatsPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ReservationSeats that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ReservationSeatsFindUniqueOrThrowArgs} args - Arguments to find a ReservationSeats
     * @example
     * // Get one ReservationSeats
     * const reservationSeats = await prisma.reservationSeats.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ReservationSeatsFindUniqueOrThrowArgs>(args: SelectSubset<T, ReservationSeatsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ReservationSeatsClient<$Result.GetResult<Prisma.$ReservationSeatsPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ReservationSeats that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReservationSeatsFindFirstArgs} args - Arguments to find a ReservationSeats
     * @example
     * // Get one ReservationSeats
     * const reservationSeats = await prisma.reservationSeats.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ReservationSeatsFindFirstArgs>(args?: SelectSubset<T, ReservationSeatsFindFirstArgs<ExtArgs>>): Prisma__ReservationSeatsClient<$Result.GetResult<Prisma.$ReservationSeatsPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ReservationSeats that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReservationSeatsFindFirstOrThrowArgs} args - Arguments to find a ReservationSeats
     * @example
     * // Get one ReservationSeats
     * const reservationSeats = await prisma.reservationSeats.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ReservationSeatsFindFirstOrThrowArgs>(args?: SelectSubset<T, ReservationSeatsFindFirstOrThrowArgs<ExtArgs>>): Prisma__ReservationSeatsClient<$Result.GetResult<Prisma.$ReservationSeatsPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ReservationSeats that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReservationSeatsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ReservationSeats
     * const reservationSeats = await prisma.reservationSeats.findMany()
     * 
     * // Get first 10 ReservationSeats
     * const reservationSeats = await prisma.reservationSeats.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const reservationSeatsWithIdOnly = await prisma.reservationSeats.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ReservationSeatsFindManyArgs>(args?: SelectSubset<T, ReservationSeatsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReservationSeatsPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ReservationSeats.
     * @param {ReservationSeatsCreateArgs} args - Arguments to create a ReservationSeats.
     * @example
     * // Create one ReservationSeats
     * const ReservationSeats = await prisma.reservationSeats.create({
     *   data: {
     *     // ... data to create a ReservationSeats
     *   }
     * })
     * 
     */
    create<T extends ReservationSeatsCreateArgs>(args: SelectSubset<T, ReservationSeatsCreateArgs<ExtArgs>>): Prisma__ReservationSeatsClient<$Result.GetResult<Prisma.$ReservationSeatsPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ReservationSeats.
     * @param {ReservationSeatsCreateManyArgs} args - Arguments to create many ReservationSeats.
     * @example
     * // Create many ReservationSeats
     * const reservationSeats = await prisma.reservationSeats.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ReservationSeatsCreateManyArgs>(args?: SelectSubset<T, ReservationSeatsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ReservationSeats and returns the data saved in the database.
     * @param {ReservationSeatsCreateManyAndReturnArgs} args - Arguments to create many ReservationSeats.
     * @example
     * // Create many ReservationSeats
     * const reservationSeats = await prisma.reservationSeats.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ReservationSeats and only return the `id`
     * const reservationSeatsWithIdOnly = await prisma.reservationSeats.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ReservationSeatsCreateManyAndReturnArgs>(args?: SelectSubset<T, ReservationSeatsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReservationSeatsPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a ReservationSeats.
     * @param {ReservationSeatsDeleteArgs} args - Arguments to delete one ReservationSeats.
     * @example
     * // Delete one ReservationSeats
     * const ReservationSeats = await prisma.reservationSeats.delete({
     *   where: {
     *     // ... filter to delete one ReservationSeats
     *   }
     * })
     * 
     */
    delete<T extends ReservationSeatsDeleteArgs>(args: SelectSubset<T, ReservationSeatsDeleteArgs<ExtArgs>>): Prisma__ReservationSeatsClient<$Result.GetResult<Prisma.$ReservationSeatsPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ReservationSeats.
     * @param {ReservationSeatsUpdateArgs} args - Arguments to update one ReservationSeats.
     * @example
     * // Update one ReservationSeats
     * const reservationSeats = await prisma.reservationSeats.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ReservationSeatsUpdateArgs>(args: SelectSubset<T, ReservationSeatsUpdateArgs<ExtArgs>>): Prisma__ReservationSeatsClient<$Result.GetResult<Prisma.$ReservationSeatsPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ReservationSeats.
     * @param {ReservationSeatsDeleteManyArgs} args - Arguments to filter ReservationSeats to delete.
     * @example
     * // Delete a few ReservationSeats
     * const { count } = await prisma.reservationSeats.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ReservationSeatsDeleteManyArgs>(args?: SelectSubset<T, ReservationSeatsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ReservationSeats.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReservationSeatsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ReservationSeats
     * const reservationSeats = await prisma.reservationSeats.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ReservationSeatsUpdateManyArgs>(args: SelectSubset<T, ReservationSeatsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ReservationSeats.
     * @param {ReservationSeatsUpsertArgs} args - Arguments to update or create a ReservationSeats.
     * @example
     * // Update or create a ReservationSeats
     * const reservationSeats = await prisma.reservationSeats.upsert({
     *   create: {
     *     // ... data to create a ReservationSeats
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ReservationSeats we want to update
     *   }
     * })
     */
    upsert<T extends ReservationSeatsUpsertArgs>(args: SelectSubset<T, ReservationSeatsUpsertArgs<ExtArgs>>): Prisma__ReservationSeatsClient<$Result.GetResult<Prisma.$ReservationSeatsPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ReservationSeats.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReservationSeatsCountArgs} args - Arguments to filter ReservationSeats to count.
     * @example
     * // Count the number of ReservationSeats
     * const count = await prisma.reservationSeats.count({
     *   where: {
     *     // ... the filter for the ReservationSeats we want to count
     *   }
     * })
    **/
    count<T extends ReservationSeatsCountArgs>(
      args?: Subset<T, ReservationSeatsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ReservationSeatsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ReservationSeats.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReservationSeatsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ReservationSeatsAggregateArgs>(args: Subset<T, ReservationSeatsAggregateArgs>): Prisma.PrismaPromise<GetReservationSeatsAggregateType<T>>

    /**
     * Group by ReservationSeats.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReservationSeatsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ReservationSeatsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ReservationSeatsGroupByArgs['orderBy'] }
        : { orderBy?: ReservationSeatsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ReservationSeatsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetReservationSeatsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ReservationSeats model
   */
  readonly fields: ReservationSeatsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ReservationSeats.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ReservationSeatsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    reservation<T extends ReservationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ReservationDefaultArgs<ExtArgs>>): Prisma__ReservationClient<$Result.GetResult<Prisma.$ReservationPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    cinemaSeat<T extends CinemaSeatDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CinemaSeatDefaultArgs<ExtArgs>>): Prisma__CinemaSeatClient<$Result.GetResult<Prisma.$CinemaSeatPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    validatedByAdminUser<T extends ReservationSeats$validatedByAdminUserArgs<ExtArgs> = {}>(args?: Subset<T, ReservationSeats$validatedByAdminUserArgs<ExtArgs>>): Prisma__AdminUserClient<$Result.GetResult<Prisma.$AdminUserPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ReservationSeats model
   */ 
  interface ReservationSeatsFieldRefs {
    readonly id: FieldRef<"ReservationSeats", 'String'>
    readonly reservationId: FieldRef<"ReservationSeats", 'String'>
    readonly eventId: FieldRef<"ReservationSeats", 'String'>
    readonly seatId: FieldRef<"ReservationSeats", 'String'>
    readonly options: FieldRef<"ReservationSeats", 'Json'>
    readonly deletedAt: FieldRef<"ReservationSeats", 'DateTime'>
    readonly validatedAt: FieldRef<"ReservationSeats", 'DateTime'>
    readonly validatedByAdminUserId: FieldRef<"ReservationSeats", 'String'>
  }
    

  // Custom InputTypes
  /**
   * ReservationSeats findUnique
   */
  export type ReservationSeatsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReservationSeats
     */
    select?: ReservationSeatsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReservationSeatsInclude<ExtArgs> | null
    /**
     * Filter, which ReservationSeats to fetch.
     */
    where: ReservationSeatsWhereUniqueInput
  }

  /**
   * ReservationSeats findUniqueOrThrow
   */
  export type ReservationSeatsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReservationSeats
     */
    select?: ReservationSeatsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReservationSeatsInclude<ExtArgs> | null
    /**
     * Filter, which ReservationSeats to fetch.
     */
    where: ReservationSeatsWhereUniqueInput
  }

  /**
   * ReservationSeats findFirst
   */
  export type ReservationSeatsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReservationSeats
     */
    select?: ReservationSeatsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReservationSeatsInclude<ExtArgs> | null
    /**
     * Filter, which ReservationSeats to fetch.
     */
    where?: ReservationSeatsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ReservationSeats to fetch.
     */
    orderBy?: ReservationSeatsOrderByWithRelationInput | ReservationSeatsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ReservationSeats.
     */
    cursor?: ReservationSeatsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ReservationSeats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ReservationSeats.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ReservationSeats.
     */
    distinct?: ReservationSeatsScalarFieldEnum | ReservationSeatsScalarFieldEnum[]
  }

  /**
   * ReservationSeats findFirstOrThrow
   */
  export type ReservationSeatsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReservationSeats
     */
    select?: ReservationSeatsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReservationSeatsInclude<ExtArgs> | null
    /**
     * Filter, which ReservationSeats to fetch.
     */
    where?: ReservationSeatsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ReservationSeats to fetch.
     */
    orderBy?: ReservationSeatsOrderByWithRelationInput | ReservationSeatsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ReservationSeats.
     */
    cursor?: ReservationSeatsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ReservationSeats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ReservationSeats.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ReservationSeats.
     */
    distinct?: ReservationSeatsScalarFieldEnum | ReservationSeatsScalarFieldEnum[]
  }

  /**
   * ReservationSeats findMany
   */
  export type ReservationSeatsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReservationSeats
     */
    select?: ReservationSeatsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReservationSeatsInclude<ExtArgs> | null
    /**
     * Filter, which ReservationSeats to fetch.
     */
    where?: ReservationSeatsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ReservationSeats to fetch.
     */
    orderBy?: ReservationSeatsOrderByWithRelationInput | ReservationSeatsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ReservationSeats.
     */
    cursor?: ReservationSeatsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ReservationSeats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ReservationSeats.
     */
    skip?: number
    distinct?: ReservationSeatsScalarFieldEnum | ReservationSeatsScalarFieldEnum[]
  }

  /**
   * ReservationSeats create
   */
  export type ReservationSeatsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReservationSeats
     */
    select?: ReservationSeatsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReservationSeatsInclude<ExtArgs> | null
    /**
     * The data needed to create a ReservationSeats.
     */
    data: XOR<ReservationSeatsCreateInput, ReservationSeatsUncheckedCreateInput>
  }

  /**
   * ReservationSeats createMany
   */
  export type ReservationSeatsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ReservationSeats.
     */
    data: ReservationSeatsCreateManyInput | ReservationSeatsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ReservationSeats createManyAndReturn
   */
  export type ReservationSeatsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReservationSeats
     */
    select?: ReservationSeatsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many ReservationSeats.
     */
    data: ReservationSeatsCreateManyInput | ReservationSeatsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReservationSeatsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ReservationSeats update
   */
  export type ReservationSeatsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReservationSeats
     */
    select?: ReservationSeatsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReservationSeatsInclude<ExtArgs> | null
    /**
     * The data needed to update a ReservationSeats.
     */
    data: XOR<ReservationSeatsUpdateInput, ReservationSeatsUncheckedUpdateInput>
    /**
     * Choose, which ReservationSeats to update.
     */
    where: ReservationSeatsWhereUniqueInput
  }

  /**
   * ReservationSeats updateMany
   */
  export type ReservationSeatsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ReservationSeats.
     */
    data: XOR<ReservationSeatsUpdateManyMutationInput, ReservationSeatsUncheckedUpdateManyInput>
    /**
     * Filter which ReservationSeats to update
     */
    where?: ReservationSeatsWhereInput
  }

  /**
   * ReservationSeats upsert
   */
  export type ReservationSeatsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReservationSeats
     */
    select?: ReservationSeatsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReservationSeatsInclude<ExtArgs> | null
    /**
     * The filter to search for the ReservationSeats to update in case it exists.
     */
    where: ReservationSeatsWhereUniqueInput
    /**
     * In case the ReservationSeats found by the `where` argument doesn't exist, create a new ReservationSeats with this data.
     */
    create: XOR<ReservationSeatsCreateInput, ReservationSeatsUncheckedCreateInput>
    /**
     * In case the ReservationSeats was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ReservationSeatsUpdateInput, ReservationSeatsUncheckedUpdateInput>
  }

  /**
   * ReservationSeats delete
   */
  export type ReservationSeatsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReservationSeats
     */
    select?: ReservationSeatsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReservationSeatsInclude<ExtArgs> | null
    /**
     * Filter which ReservationSeats to delete.
     */
    where: ReservationSeatsWhereUniqueInput
  }

  /**
   * ReservationSeats deleteMany
   */
  export type ReservationSeatsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ReservationSeats to delete
     */
    where?: ReservationSeatsWhereInput
  }

  /**
   * ReservationSeats.validatedByAdminUser
   */
  export type ReservationSeats$validatedByAdminUserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminUser
     */
    select?: AdminUserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminUserInclude<ExtArgs> | null
    where?: AdminUserWhereInput
  }

  /**
   * ReservationSeats without action
   */
  export type ReservationSeatsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReservationSeats
     */
    select?: ReservationSeatsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReservationSeatsInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const GenreScalarFieldEnum: {
    systemName: 'systemName',
    localizedName: 'localizedName'
  };

  export type GenreScalarFieldEnum = (typeof GenreScalarFieldEnum)[keyof typeof GenreScalarFieldEnum]


  export const LanguageScalarFieldEnum: {
    code: 'code',
    name: 'name'
  };

  export type LanguageScalarFieldEnum = (typeof LanguageScalarFieldEnum)[keyof typeof LanguageScalarFieldEnum]


  export const CountryScalarFieldEnum: {
    code: 'code',
    name: 'name'
  };

  export type CountryScalarFieldEnum = (typeof CountryScalarFieldEnum)[keyof typeof CountryScalarFieldEnum]


  export const CityScalarFieldEnum: {
    id: 'id',
    cityCode: 'cityCode',
    name: 'name',
    postalCode: 'postalCode',
    countryCode: 'countryCode'
  };

  export type CityScalarFieldEnum = (typeof CityScalarFieldEnum)[keyof typeof CityScalarFieldEnum]


  export const CinemaScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    cityId: 'cityId',
    address: 'address',
    rating: 'rating',
    phone: 'phone',
    posterImages: 'posterImages',
    geoLatitude: 'geoLatitude',
    geoLongitude: 'geoLongitude'
  };

  export type CinemaScalarFieldEnum = (typeof CinemaScalarFieldEnum)[keyof typeof CinemaScalarFieldEnum]


  export const CinemaTheaterScalarFieldEnum: {
    id: 'id',
    name: 'name',
    cinemaId: 'cinemaId',
    supports3D: 'supports3D',
    posterImages: 'posterImages'
  };

  export type CinemaTheaterScalarFieldEnum = (typeof CinemaTheaterScalarFieldEnum)[keyof typeof CinemaTheaterScalarFieldEnum]


  export const CinemaSeatGroupScalarFieldEnum: {
    id: 'id',
    cinemaTheaterId: 'cinemaTheaterId',
    name: 'name',
    rowCount: 'rowCount',
    columnCount: 'columnCount',
    position: 'position',
    options: 'options'
  };

  export type CinemaSeatGroupScalarFieldEnum = (typeof CinemaSeatGroupScalarFieldEnum)[keyof typeof CinemaSeatGroupScalarFieldEnum]


  export const CinemaSeatScalarFieldEnum: {
    id: 'id',
    cinemaSeatGroupId: 'cinemaSeatGroupId',
    seatRow: 'seatRow',
    seatColumn: 'seatColumn',
    options: 'options'
  };

  export type CinemaSeatScalarFieldEnum = (typeof CinemaSeatScalarFieldEnum)[keyof typeof CinemaSeatScalarFieldEnum]


  export const MovieScalarFieldEnum: {
    id: 'id',
    title: 'title',
    originalTitle: 'originalTitle',
    localizedTitle: 'localizedTitle',
    plot: 'plot',
    localizedPlot: 'localizedPlot',
    runtimeMinutes: 'runtimeMinutes',
    originalLanguageId: 'originalLanguageId',
    countryOfOriginId: 'countryOfOriginId',
    posterImages: 'posterImages',
    videos: 'videos',
    rating: 'rating',
    releaseDate: 'releaseDate',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    externalId: 'externalId',
    externalType: 'externalType',
    additionalData: 'additionalData'
  };

  export type MovieScalarFieldEnum = (typeof MovieScalarFieldEnum)[keyof typeof MovieScalarFieldEnum]


  export const PersonScalarFieldEnum: {
    id: 'id',
    name: 'name',
    biography: 'biography',
    dateOfBirth: 'dateOfBirth',
    dateOfDeath: 'dateOfDeath',
    gender: 'gender',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    externalId: 'externalId',
    externalType: 'externalType',
    additionalData: 'additionalData'
  };

  export type PersonScalarFieldEnum = (typeof PersonScalarFieldEnum)[keyof typeof PersonScalarFieldEnum]


  export const MovieActorScalarFieldEnum: {
    personId: 'personId',
    movieId: 'movieId',
    characterName: 'characterName',
    castOrder: 'castOrder'
  };

  export type MovieActorScalarFieldEnum = (typeof MovieActorScalarFieldEnum)[keyof typeof MovieActorScalarFieldEnum]


  export const MovieDirectorScalarFieldEnum: {
    personId: 'personId',
    movieId: 'movieId',
    type: 'type'
  };

  export type MovieDirectorScalarFieldEnum = (typeof MovieDirectorScalarFieldEnum)[keyof typeof MovieDirectorScalarFieldEnum]


  export const MovieProducerScalarFieldEnum: {
    personId: 'personId',
    movieId: 'movieId',
    type: 'type'
  };

  export type MovieProducerScalarFieldEnum = (typeof MovieProducerScalarFieldEnum)[keyof typeof MovieProducerScalarFieldEnum]


  export const MovieCinemaOverrideScalarFieldEnum: {
    movieId: 'movieId',
    cinemaId: 'cinemaId',
    movieDataOverrides: 'movieDataOverrides',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type MovieCinemaOverrideScalarFieldEnum = (typeof MovieCinemaOverrideScalarFieldEnum)[keyof typeof MovieCinemaOverrideScalarFieldEnum]


  export const MovieProjectionScalarFieldEnum: {
    id: 'id',
    movieId: 'movieId',
    cinemaTheaterId: 'cinemaTheaterId',
    projectionDateTime: 'projectionDateTime',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    dubbedLanguageId: 'dubbedLanguageId',
    options: 'options'
  };

  export type MovieProjectionScalarFieldEnum = (typeof MovieProjectionScalarFieldEnum)[keyof typeof MovieProjectionScalarFieldEnum]


  export const ProjectionPriceScalarFieldEnum: {
    projectionId: 'projectionId',
    groupId: 'groupId',
    type: 'type',
    price: 'price',
    currencyCode: 'currencyCode'
  };

  export type ProjectionPriceScalarFieldEnum = (typeof ProjectionPriceScalarFieldEnum)[keyof typeof ProjectionPriceScalarFieldEnum]


  export const AdminUserScalarFieldEnum: {
    id: 'id',
    email: 'email',
    password: 'password',
    fullName: 'fullName',
    role: 'role',
    cinemaIds: 'cinemaIds',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type AdminUserScalarFieldEnum = (typeof AdminUserScalarFieldEnum)[keyof typeof AdminUserScalarFieldEnum]


  export const ReservationScalarFieldEnum: {
    id: 'id',
    eventId: 'eventId',
    customerInformation: 'customerInformation',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    options: 'options',
    deletedAt: 'deletedAt'
  };

  export type ReservationScalarFieldEnum = (typeof ReservationScalarFieldEnum)[keyof typeof ReservationScalarFieldEnum]


  export const ReservationSeatsScalarFieldEnum: {
    id: 'id',
    reservationId: 'reservationId',
    eventId: 'eventId',
    seatId: 'seatId',
    options: 'options',
    deletedAt: 'deletedAt',
    validatedAt: 'validatedAt',
    validatedByAdminUserId: 'validatedByAdminUserId'
  };

  export type ReservationSeatsScalarFieldEnum = (typeof ReservationSeatsScalarFieldEnum)[keyof typeof ReservationSeatsScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const JsonNullValueInput: {
    JsonNull: typeof JsonNull
  };

  export type JsonNullValueInput = (typeof JsonNullValueInput)[keyof typeof JsonNullValueInput]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references 
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


  /**
   * Reference to a field of type 'Decimal'
   */
  export type DecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal'>
    


  /**
   * Reference to a field of type 'Decimal[]'
   */
  export type ListDecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'CinemaSeatGroupPositionEnum'
   */
  export type EnumCinemaSeatGroupPositionEnumFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CinemaSeatGroupPositionEnum'>
    


  /**
   * Reference to a field of type 'CinemaSeatGroupPositionEnum[]'
   */
  export type ListEnumCinemaSeatGroupPositionEnumFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CinemaSeatGroupPositionEnum[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'InputProvider'
   */
  export type EnumInputProviderFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'InputProvider'>
    


  /**
   * Reference to a field of type 'InputProvider[]'
   */
  export type ListEnumInputProviderFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'InputProvider[]'>
    


  /**
   * Reference to a field of type 'Gender'
   */
  export type EnumGenderFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Gender'>
    


  /**
   * Reference to a field of type 'Gender[]'
   */
  export type ListEnumGenderFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Gender[]'>
    


  /**
   * Reference to a field of type 'DirectorType'
   */
  export type EnumDirectorTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DirectorType'>
    


  /**
   * Reference to a field of type 'DirectorType[]'
   */
  export type ListEnumDirectorTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DirectorType[]'>
    


  /**
   * Reference to a field of type 'ProducerType'
   */
  export type EnumProducerTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ProducerType'>
    


  /**
   * Reference to a field of type 'ProducerType[]'
   */
  export type ListEnumProducerTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ProducerType[]'>
    


  /**
   * Reference to a field of type 'PriceType'
   */
  export type EnumPriceTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PriceType'>
    


  /**
   * Reference to a field of type 'PriceType[]'
   */
  export type ListEnumPriceTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PriceType[]'>
    


  /**
   * Reference to a field of type 'CurrencyCode'
   */
  export type EnumCurrencyCodeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CurrencyCode'>
    


  /**
   * Reference to a field of type 'CurrencyCode[]'
   */
  export type ListEnumCurrencyCodeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CurrencyCode[]'>
    


  /**
   * Reference to a field of type 'AdminRole'
   */
  export type EnumAdminRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AdminRole'>
    


  /**
   * Reference to a field of type 'AdminRole[]'
   */
  export type ListEnumAdminRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AdminRole[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    
  /**
   * Deep Input Types
   */


  export type GenreWhereInput = {
    AND?: GenreWhereInput | GenreWhereInput[]
    OR?: GenreWhereInput[]
    NOT?: GenreWhereInput | GenreWhereInput[]
    systemName?: StringFilter<"Genre"> | string
    localizedName?: StringFilter<"Genre"> | string
    movies?: MovieListRelationFilter
  }

  export type GenreOrderByWithRelationInput = {
    systemName?: SortOrder
    localizedName?: SortOrder
    movies?: MovieOrderByRelationAggregateInput
  }

  export type GenreWhereUniqueInput = Prisma.AtLeast<{
    systemName?: string
    localizedName?: string
    AND?: GenreWhereInput | GenreWhereInput[]
    OR?: GenreWhereInput[]
    NOT?: GenreWhereInput | GenreWhereInput[]
    movies?: MovieListRelationFilter
  }, "systemName" | "localizedName">

  export type GenreOrderByWithAggregationInput = {
    systemName?: SortOrder
    localizedName?: SortOrder
    _count?: GenreCountOrderByAggregateInput
    _max?: GenreMaxOrderByAggregateInput
    _min?: GenreMinOrderByAggregateInput
  }

  export type GenreScalarWhereWithAggregatesInput = {
    AND?: GenreScalarWhereWithAggregatesInput | GenreScalarWhereWithAggregatesInput[]
    OR?: GenreScalarWhereWithAggregatesInput[]
    NOT?: GenreScalarWhereWithAggregatesInput | GenreScalarWhereWithAggregatesInput[]
    systemName?: StringWithAggregatesFilter<"Genre"> | string
    localizedName?: StringWithAggregatesFilter<"Genre"> | string
  }

  export type LanguageWhereInput = {
    AND?: LanguageWhereInput | LanguageWhereInput[]
    OR?: LanguageWhereInput[]
    NOT?: LanguageWhereInput | LanguageWhereInput[]
    code?: StringFilter<"Language"> | string
    name?: StringFilter<"Language"> | string
    originalLanguageMovies?: MovieListRelationFilter
    dubbedLanguageMovieProjections?: MovieProjectionListRelationFilter
  }

  export type LanguageOrderByWithRelationInput = {
    code?: SortOrder
    name?: SortOrder
    originalLanguageMovies?: MovieOrderByRelationAggregateInput
    dubbedLanguageMovieProjections?: MovieProjectionOrderByRelationAggregateInput
  }

  export type LanguageWhereUniqueInput = Prisma.AtLeast<{
    code?: string
    name?: string
    AND?: LanguageWhereInput | LanguageWhereInput[]
    OR?: LanguageWhereInput[]
    NOT?: LanguageWhereInput | LanguageWhereInput[]
    originalLanguageMovies?: MovieListRelationFilter
    dubbedLanguageMovieProjections?: MovieProjectionListRelationFilter
  }, "code" | "name">

  export type LanguageOrderByWithAggregationInput = {
    code?: SortOrder
    name?: SortOrder
    _count?: LanguageCountOrderByAggregateInput
    _max?: LanguageMaxOrderByAggregateInput
    _min?: LanguageMinOrderByAggregateInput
  }

  export type LanguageScalarWhereWithAggregatesInput = {
    AND?: LanguageScalarWhereWithAggregatesInput | LanguageScalarWhereWithAggregatesInput[]
    OR?: LanguageScalarWhereWithAggregatesInput[]
    NOT?: LanguageScalarWhereWithAggregatesInput | LanguageScalarWhereWithAggregatesInput[]
    code?: StringWithAggregatesFilter<"Language"> | string
    name?: StringWithAggregatesFilter<"Language"> | string
  }

  export type CountryWhereInput = {
    AND?: CountryWhereInput | CountryWhereInput[]
    OR?: CountryWhereInput[]
    NOT?: CountryWhereInput | CountryWhereInput[]
    code?: StringFilter<"Country"> | string
    name?: StringFilter<"Country"> | string
    cities?: CityListRelationFilter
    movies?: MovieListRelationFilter
  }

  export type CountryOrderByWithRelationInput = {
    code?: SortOrder
    name?: SortOrder
    cities?: CityOrderByRelationAggregateInput
    movies?: MovieOrderByRelationAggregateInput
  }

  export type CountryWhereUniqueInput = Prisma.AtLeast<{
    code?: string
    name?: string
    AND?: CountryWhereInput | CountryWhereInput[]
    OR?: CountryWhereInput[]
    NOT?: CountryWhereInput | CountryWhereInput[]
    cities?: CityListRelationFilter
    movies?: MovieListRelationFilter
  }, "code" | "name">

  export type CountryOrderByWithAggregationInput = {
    code?: SortOrder
    name?: SortOrder
    _count?: CountryCountOrderByAggregateInput
    _max?: CountryMaxOrderByAggregateInput
    _min?: CountryMinOrderByAggregateInput
  }

  export type CountryScalarWhereWithAggregatesInput = {
    AND?: CountryScalarWhereWithAggregatesInput | CountryScalarWhereWithAggregatesInput[]
    OR?: CountryScalarWhereWithAggregatesInput[]
    NOT?: CountryScalarWhereWithAggregatesInput | CountryScalarWhereWithAggregatesInput[]
    code?: StringWithAggregatesFilter<"Country"> | string
    name?: StringWithAggregatesFilter<"Country"> | string
  }

  export type CityWhereInput = {
    AND?: CityWhereInput | CityWhereInput[]
    OR?: CityWhereInput[]
    NOT?: CityWhereInput | CityWhereInput[]
    id?: UuidFilter<"City"> | string
    cityCode?: StringFilter<"City"> | string
    name?: StringFilter<"City"> | string
    postalCode?: StringFilter<"City"> | string
    countryCode?: StringFilter<"City"> | string
    country?: XOR<CountryRelationFilter, CountryWhereInput>
    cinemas?: CinemaListRelationFilter
  }

  export type CityOrderByWithRelationInput = {
    id?: SortOrder
    cityCode?: SortOrder
    name?: SortOrder
    postalCode?: SortOrder
    countryCode?: SortOrder
    country?: CountryOrderByWithRelationInput
    cinemas?: CinemaOrderByRelationAggregateInput
  }

  export type CityWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    cityCode_countryCode?: CityCityCodeCountryCodeCompoundUniqueInput
    AND?: CityWhereInput | CityWhereInput[]
    OR?: CityWhereInput[]
    NOT?: CityWhereInput | CityWhereInput[]
    cityCode?: StringFilter<"City"> | string
    name?: StringFilter<"City"> | string
    postalCode?: StringFilter<"City"> | string
    countryCode?: StringFilter<"City"> | string
    country?: XOR<CountryRelationFilter, CountryWhereInput>
    cinemas?: CinemaListRelationFilter
  }, "id" | "cityCode_countryCode">

  export type CityOrderByWithAggregationInput = {
    id?: SortOrder
    cityCode?: SortOrder
    name?: SortOrder
    postalCode?: SortOrder
    countryCode?: SortOrder
    _count?: CityCountOrderByAggregateInput
    _max?: CityMaxOrderByAggregateInput
    _min?: CityMinOrderByAggregateInput
  }

  export type CityScalarWhereWithAggregatesInput = {
    AND?: CityScalarWhereWithAggregatesInput | CityScalarWhereWithAggregatesInput[]
    OR?: CityScalarWhereWithAggregatesInput[]
    NOT?: CityScalarWhereWithAggregatesInput | CityScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"City"> | string
    cityCode?: StringWithAggregatesFilter<"City"> | string
    name?: StringWithAggregatesFilter<"City"> | string
    postalCode?: StringWithAggregatesFilter<"City"> | string
    countryCode?: StringWithAggregatesFilter<"City"> | string
  }

  export type CinemaWhereInput = {
    AND?: CinemaWhereInput | CinemaWhereInput[]
    OR?: CinemaWhereInput[]
    NOT?: CinemaWhereInput | CinemaWhereInput[]
    id?: UuidFilter<"Cinema"> | string
    name?: StringFilter<"Cinema"> | string
    description?: StringFilter<"Cinema"> | string
    cityId?: UuidFilter<"Cinema"> | string
    address?: StringFilter<"Cinema"> | string
    rating?: IntFilter<"Cinema"> | number
    phone?: JsonFilter<"Cinema">
    posterImages?: JsonFilter<"Cinema">
    geoLatitude?: DecimalNullableFilter<"Cinema"> | Decimal | DecimalJsLike | number | string | null
    geoLongitude?: DecimalNullableFilter<"Cinema"> | Decimal | DecimalJsLike | number | string | null
    city?: XOR<CityRelationFilter, CityWhereInput>
    cinemaTheaters?: CinemaTheaterListRelationFilter
    movieCinemaOverrides?: MovieCinemaOverrideListRelationFilter
  }

  export type CinemaOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    cityId?: SortOrder
    address?: SortOrder
    rating?: SortOrder
    phone?: SortOrder
    posterImages?: SortOrder
    geoLatitude?: SortOrderInput | SortOrder
    geoLongitude?: SortOrderInput | SortOrder
    city?: CityOrderByWithRelationInput
    cinemaTheaters?: CinemaTheaterOrderByRelationAggregateInput
    movieCinemaOverrides?: MovieCinemaOverrideOrderByRelationAggregateInput
  }

  export type CinemaWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    name?: string
    AND?: CinemaWhereInput | CinemaWhereInput[]
    OR?: CinemaWhereInput[]
    NOT?: CinemaWhereInput | CinemaWhereInput[]
    description?: StringFilter<"Cinema"> | string
    cityId?: UuidFilter<"Cinema"> | string
    address?: StringFilter<"Cinema"> | string
    rating?: IntFilter<"Cinema"> | number
    phone?: JsonFilter<"Cinema">
    posterImages?: JsonFilter<"Cinema">
    geoLatitude?: DecimalNullableFilter<"Cinema"> | Decimal | DecimalJsLike | number | string | null
    geoLongitude?: DecimalNullableFilter<"Cinema"> | Decimal | DecimalJsLike | number | string | null
    city?: XOR<CityRelationFilter, CityWhereInput>
    cinemaTheaters?: CinemaTheaterListRelationFilter
    movieCinemaOverrides?: MovieCinemaOverrideListRelationFilter
  }, "id" | "name">

  export type CinemaOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    cityId?: SortOrder
    address?: SortOrder
    rating?: SortOrder
    phone?: SortOrder
    posterImages?: SortOrder
    geoLatitude?: SortOrderInput | SortOrder
    geoLongitude?: SortOrderInput | SortOrder
    _count?: CinemaCountOrderByAggregateInput
    _avg?: CinemaAvgOrderByAggregateInput
    _max?: CinemaMaxOrderByAggregateInput
    _min?: CinemaMinOrderByAggregateInput
    _sum?: CinemaSumOrderByAggregateInput
  }

  export type CinemaScalarWhereWithAggregatesInput = {
    AND?: CinemaScalarWhereWithAggregatesInput | CinemaScalarWhereWithAggregatesInput[]
    OR?: CinemaScalarWhereWithAggregatesInput[]
    NOT?: CinemaScalarWhereWithAggregatesInput | CinemaScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"Cinema"> | string
    name?: StringWithAggregatesFilter<"Cinema"> | string
    description?: StringWithAggregatesFilter<"Cinema"> | string
    cityId?: UuidWithAggregatesFilter<"Cinema"> | string
    address?: StringWithAggregatesFilter<"Cinema"> | string
    rating?: IntWithAggregatesFilter<"Cinema"> | number
    phone?: JsonWithAggregatesFilter<"Cinema">
    posterImages?: JsonWithAggregatesFilter<"Cinema">
    geoLatitude?: DecimalNullableWithAggregatesFilter<"Cinema"> | Decimal | DecimalJsLike | number | string | null
    geoLongitude?: DecimalNullableWithAggregatesFilter<"Cinema"> | Decimal | DecimalJsLike | number | string | null
  }

  export type CinemaTheaterWhereInput = {
    AND?: CinemaTheaterWhereInput | CinemaTheaterWhereInput[]
    OR?: CinemaTheaterWhereInput[]
    NOT?: CinemaTheaterWhereInput | CinemaTheaterWhereInput[]
    id?: UuidFilter<"CinemaTheater"> | string
    name?: StringFilter<"CinemaTheater"> | string
    cinemaId?: UuidFilter<"CinemaTheater"> | string
    supports3D?: BoolFilter<"CinemaTheater"> | boolean
    posterImages?: JsonFilter<"CinemaTheater">
    cinema?: XOR<CinemaRelationFilter, CinemaWhereInput>
    cinemaSeatGroups?: CinemaSeatGroupListRelationFilter
    movieProjections?: MovieProjectionListRelationFilter
  }

  export type CinemaTheaterOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    cinemaId?: SortOrder
    supports3D?: SortOrder
    posterImages?: SortOrder
    cinema?: CinemaOrderByWithRelationInput
    cinemaSeatGroups?: CinemaSeatGroupOrderByRelationAggregateInput
    movieProjections?: MovieProjectionOrderByRelationAggregateInput
  }

  export type CinemaTheaterWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CinemaTheaterWhereInput | CinemaTheaterWhereInput[]
    OR?: CinemaTheaterWhereInput[]
    NOT?: CinemaTheaterWhereInput | CinemaTheaterWhereInput[]
    name?: StringFilter<"CinemaTheater"> | string
    cinemaId?: UuidFilter<"CinemaTheater"> | string
    supports3D?: BoolFilter<"CinemaTheater"> | boolean
    posterImages?: JsonFilter<"CinemaTheater">
    cinema?: XOR<CinemaRelationFilter, CinemaWhereInput>
    cinemaSeatGroups?: CinemaSeatGroupListRelationFilter
    movieProjections?: MovieProjectionListRelationFilter
  }, "id">

  export type CinemaTheaterOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    cinemaId?: SortOrder
    supports3D?: SortOrder
    posterImages?: SortOrder
    _count?: CinemaTheaterCountOrderByAggregateInput
    _max?: CinemaTheaterMaxOrderByAggregateInput
    _min?: CinemaTheaterMinOrderByAggregateInput
  }

  export type CinemaTheaterScalarWhereWithAggregatesInput = {
    AND?: CinemaTheaterScalarWhereWithAggregatesInput | CinemaTheaterScalarWhereWithAggregatesInput[]
    OR?: CinemaTheaterScalarWhereWithAggregatesInput[]
    NOT?: CinemaTheaterScalarWhereWithAggregatesInput | CinemaTheaterScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"CinemaTheater"> | string
    name?: StringWithAggregatesFilter<"CinemaTheater"> | string
    cinemaId?: UuidWithAggregatesFilter<"CinemaTheater"> | string
    supports3D?: BoolWithAggregatesFilter<"CinemaTheater"> | boolean
    posterImages?: JsonWithAggregatesFilter<"CinemaTheater">
  }

  export type CinemaSeatGroupWhereInput = {
    AND?: CinemaSeatGroupWhereInput | CinemaSeatGroupWhereInput[]
    OR?: CinemaSeatGroupWhereInput[]
    NOT?: CinemaSeatGroupWhereInput | CinemaSeatGroupWhereInput[]
    id?: UuidFilter<"CinemaSeatGroup"> | string
    cinemaTheaterId?: UuidFilter<"CinemaSeatGroup"> | string
    name?: StringFilter<"CinemaSeatGroup"> | string
    rowCount?: IntFilter<"CinemaSeatGroup"> | number
    columnCount?: IntFilter<"CinemaSeatGroup"> | number
    position?: EnumCinemaSeatGroupPositionEnumFilter<"CinemaSeatGroup"> | $Enums.CinemaSeatGroupPositionEnum
    options?: JsonFilter<"CinemaSeatGroup">
    cinemaTheater?: XOR<CinemaTheaterRelationFilter, CinemaTheaterWhereInput>
    cinemaSeats?: CinemaSeatListRelationFilter
    projectionPrices?: ProjectionPriceListRelationFilter
  }

  export type CinemaSeatGroupOrderByWithRelationInput = {
    id?: SortOrder
    cinemaTheaterId?: SortOrder
    name?: SortOrder
    rowCount?: SortOrder
    columnCount?: SortOrder
    position?: SortOrder
    options?: SortOrder
    cinemaTheater?: CinemaTheaterOrderByWithRelationInput
    cinemaSeats?: CinemaSeatOrderByRelationAggregateInput
    projectionPrices?: ProjectionPriceOrderByRelationAggregateInput
  }

  export type CinemaSeatGroupWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    position_cinemaTheaterId?: CinemaSeatGroupPositionCinemaTheaterIdCompoundUniqueInput
    AND?: CinemaSeatGroupWhereInput | CinemaSeatGroupWhereInput[]
    OR?: CinemaSeatGroupWhereInput[]
    NOT?: CinemaSeatGroupWhereInput | CinemaSeatGroupWhereInput[]
    cinemaTheaterId?: UuidFilter<"CinemaSeatGroup"> | string
    name?: StringFilter<"CinemaSeatGroup"> | string
    rowCount?: IntFilter<"CinemaSeatGroup"> | number
    columnCount?: IntFilter<"CinemaSeatGroup"> | number
    position?: EnumCinemaSeatGroupPositionEnumFilter<"CinemaSeatGroup"> | $Enums.CinemaSeatGroupPositionEnum
    options?: JsonFilter<"CinemaSeatGroup">
    cinemaTheater?: XOR<CinemaTheaterRelationFilter, CinemaTheaterWhereInput>
    cinemaSeats?: CinemaSeatListRelationFilter
    projectionPrices?: ProjectionPriceListRelationFilter
  }, "id" | "position_cinemaTheaterId">

  export type CinemaSeatGroupOrderByWithAggregationInput = {
    id?: SortOrder
    cinemaTheaterId?: SortOrder
    name?: SortOrder
    rowCount?: SortOrder
    columnCount?: SortOrder
    position?: SortOrder
    options?: SortOrder
    _count?: CinemaSeatGroupCountOrderByAggregateInput
    _avg?: CinemaSeatGroupAvgOrderByAggregateInput
    _max?: CinemaSeatGroupMaxOrderByAggregateInput
    _min?: CinemaSeatGroupMinOrderByAggregateInput
    _sum?: CinemaSeatGroupSumOrderByAggregateInput
  }

  export type CinemaSeatGroupScalarWhereWithAggregatesInput = {
    AND?: CinemaSeatGroupScalarWhereWithAggregatesInput | CinemaSeatGroupScalarWhereWithAggregatesInput[]
    OR?: CinemaSeatGroupScalarWhereWithAggregatesInput[]
    NOT?: CinemaSeatGroupScalarWhereWithAggregatesInput | CinemaSeatGroupScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"CinemaSeatGroup"> | string
    cinemaTheaterId?: UuidWithAggregatesFilter<"CinemaSeatGroup"> | string
    name?: StringWithAggregatesFilter<"CinemaSeatGroup"> | string
    rowCount?: IntWithAggregatesFilter<"CinemaSeatGroup"> | number
    columnCount?: IntWithAggregatesFilter<"CinemaSeatGroup"> | number
    position?: EnumCinemaSeatGroupPositionEnumWithAggregatesFilter<"CinemaSeatGroup"> | $Enums.CinemaSeatGroupPositionEnum
    options?: JsonWithAggregatesFilter<"CinemaSeatGroup">
  }

  export type CinemaSeatWhereInput = {
    AND?: CinemaSeatWhereInput | CinemaSeatWhereInput[]
    OR?: CinemaSeatWhereInput[]
    NOT?: CinemaSeatWhereInput | CinemaSeatWhereInput[]
    id?: UuidFilter<"CinemaSeat"> | string
    cinemaSeatGroupId?: UuidFilter<"CinemaSeat"> | string
    seatRow?: StringFilter<"CinemaSeat"> | string
    seatColumn?: StringFilter<"CinemaSeat"> | string
    options?: JsonFilter<"CinemaSeat">
    cinemaSeatGroup?: XOR<CinemaSeatGroupRelationFilter, CinemaSeatGroupWhereInput>
    reservation?: ReservationSeatsListRelationFilter
  }

  export type CinemaSeatOrderByWithRelationInput = {
    id?: SortOrder
    cinemaSeatGroupId?: SortOrder
    seatRow?: SortOrder
    seatColumn?: SortOrder
    options?: SortOrder
    cinemaSeatGroup?: CinemaSeatGroupOrderByWithRelationInput
    reservation?: ReservationSeatsOrderByRelationAggregateInput
  }

  export type CinemaSeatWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CinemaSeatWhereInput | CinemaSeatWhereInput[]
    OR?: CinemaSeatWhereInput[]
    NOT?: CinemaSeatWhereInput | CinemaSeatWhereInput[]
    cinemaSeatGroupId?: UuidFilter<"CinemaSeat"> | string
    seatRow?: StringFilter<"CinemaSeat"> | string
    seatColumn?: StringFilter<"CinemaSeat"> | string
    options?: JsonFilter<"CinemaSeat">
    cinemaSeatGroup?: XOR<CinemaSeatGroupRelationFilter, CinemaSeatGroupWhereInput>
    reservation?: ReservationSeatsListRelationFilter
  }, "id">

  export type CinemaSeatOrderByWithAggregationInput = {
    id?: SortOrder
    cinemaSeatGroupId?: SortOrder
    seatRow?: SortOrder
    seatColumn?: SortOrder
    options?: SortOrder
    _count?: CinemaSeatCountOrderByAggregateInput
    _max?: CinemaSeatMaxOrderByAggregateInput
    _min?: CinemaSeatMinOrderByAggregateInput
  }

  export type CinemaSeatScalarWhereWithAggregatesInput = {
    AND?: CinemaSeatScalarWhereWithAggregatesInput | CinemaSeatScalarWhereWithAggregatesInput[]
    OR?: CinemaSeatScalarWhereWithAggregatesInput[]
    NOT?: CinemaSeatScalarWhereWithAggregatesInput | CinemaSeatScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"CinemaSeat"> | string
    cinemaSeatGroupId?: UuidWithAggregatesFilter<"CinemaSeat"> | string
    seatRow?: StringWithAggregatesFilter<"CinemaSeat"> | string
    seatColumn?: StringWithAggregatesFilter<"CinemaSeat"> | string
    options?: JsonWithAggregatesFilter<"CinemaSeat">
  }

  export type MovieWhereInput = {
    AND?: MovieWhereInput | MovieWhereInput[]
    OR?: MovieWhereInput[]
    NOT?: MovieWhereInput | MovieWhereInput[]
    id?: UuidFilter<"Movie"> | string
    title?: StringNullableFilter<"Movie"> | string | null
    originalTitle?: StringFilter<"Movie"> | string
    localizedTitle?: StringNullableFilter<"Movie"> | string | null
    plot?: StringFilter<"Movie"> | string
    localizedPlot?: StringNullableFilter<"Movie"> | string | null
    runtimeMinutes?: IntFilter<"Movie"> | number
    originalLanguageId?: StringFilter<"Movie"> | string
    countryOfOriginId?: StringFilter<"Movie"> | string
    posterImages?: JsonFilter<"Movie">
    videos?: JsonFilter<"Movie">
    rating?: IntFilter<"Movie"> | number
    releaseDate?: DateTimeFilter<"Movie"> | Date | string
    createdAt?: DateTimeFilter<"Movie"> | Date | string
    updatedAt?: DateTimeFilter<"Movie"> | Date | string
    externalId?: StringFilter<"Movie"> | string
    externalType?: EnumInputProviderFilter<"Movie"> | $Enums.InputProvider
    additionalData?: JsonFilter<"Movie">
    genres?: GenreListRelationFilter
    originalLanguage?: XOR<LanguageRelationFilter, LanguageWhereInput>
    countryOfOrigin?: XOR<CountryRelationFilter, CountryWhereInput>
    actors?: MovieActorListRelationFilter
    directors?: MovieDirectorListRelationFilter
    producers?: MovieProducerListRelationFilter
    movieCinemaOverrides?: MovieCinemaOverrideListRelationFilter
    movieProjections?: MovieProjectionListRelationFilter
  }

  export type MovieOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrderInput | SortOrder
    originalTitle?: SortOrder
    localizedTitle?: SortOrderInput | SortOrder
    plot?: SortOrder
    localizedPlot?: SortOrderInput | SortOrder
    runtimeMinutes?: SortOrder
    originalLanguageId?: SortOrder
    countryOfOriginId?: SortOrder
    posterImages?: SortOrder
    videos?: SortOrder
    rating?: SortOrder
    releaseDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    externalId?: SortOrder
    externalType?: SortOrder
    additionalData?: SortOrder
    genres?: GenreOrderByRelationAggregateInput
    originalLanguage?: LanguageOrderByWithRelationInput
    countryOfOrigin?: CountryOrderByWithRelationInput
    actors?: MovieActorOrderByRelationAggregateInput
    directors?: MovieDirectorOrderByRelationAggregateInput
    producers?: MovieProducerOrderByRelationAggregateInput
    movieCinemaOverrides?: MovieCinemaOverrideOrderByRelationAggregateInput
    movieProjections?: MovieProjectionOrderByRelationAggregateInput
  }

  export type MovieWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    externalId_externalType?: MovieExternalIdExternalTypeCompoundUniqueInput
    AND?: MovieWhereInput | MovieWhereInput[]
    OR?: MovieWhereInput[]
    NOT?: MovieWhereInput | MovieWhereInput[]
    title?: StringNullableFilter<"Movie"> | string | null
    originalTitle?: StringFilter<"Movie"> | string
    localizedTitle?: StringNullableFilter<"Movie"> | string | null
    plot?: StringFilter<"Movie"> | string
    localizedPlot?: StringNullableFilter<"Movie"> | string | null
    runtimeMinutes?: IntFilter<"Movie"> | number
    originalLanguageId?: StringFilter<"Movie"> | string
    countryOfOriginId?: StringFilter<"Movie"> | string
    posterImages?: JsonFilter<"Movie">
    videos?: JsonFilter<"Movie">
    rating?: IntFilter<"Movie"> | number
    releaseDate?: DateTimeFilter<"Movie"> | Date | string
    createdAt?: DateTimeFilter<"Movie"> | Date | string
    updatedAt?: DateTimeFilter<"Movie"> | Date | string
    externalId?: StringFilter<"Movie"> | string
    externalType?: EnumInputProviderFilter<"Movie"> | $Enums.InputProvider
    additionalData?: JsonFilter<"Movie">
    genres?: GenreListRelationFilter
    originalLanguage?: XOR<LanguageRelationFilter, LanguageWhereInput>
    countryOfOrigin?: XOR<CountryRelationFilter, CountryWhereInput>
    actors?: MovieActorListRelationFilter
    directors?: MovieDirectorListRelationFilter
    producers?: MovieProducerListRelationFilter
    movieCinemaOverrides?: MovieCinemaOverrideListRelationFilter
    movieProjections?: MovieProjectionListRelationFilter
  }, "id" | "externalId_externalType">

  export type MovieOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrderInput | SortOrder
    originalTitle?: SortOrder
    localizedTitle?: SortOrderInput | SortOrder
    plot?: SortOrder
    localizedPlot?: SortOrderInput | SortOrder
    runtimeMinutes?: SortOrder
    originalLanguageId?: SortOrder
    countryOfOriginId?: SortOrder
    posterImages?: SortOrder
    videos?: SortOrder
    rating?: SortOrder
    releaseDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    externalId?: SortOrder
    externalType?: SortOrder
    additionalData?: SortOrder
    _count?: MovieCountOrderByAggregateInput
    _avg?: MovieAvgOrderByAggregateInput
    _max?: MovieMaxOrderByAggregateInput
    _min?: MovieMinOrderByAggregateInput
    _sum?: MovieSumOrderByAggregateInput
  }

  export type MovieScalarWhereWithAggregatesInput = {
    AND?: MovieScalarWhereWithAggregatesInput | MovieScalarWhereWithAggregatesInput[]
    OR?: MovieScalarWhereWithAggregatesInput[]
    NOT?: MovieScalarWhereWithAggregatesInput | MovieScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"Movie"> | string
    title?: StringNullableWithAggregatesFilter<"Movie"> | string | null
    originalTitle?: StringWithAggregatesFilter<"Movie"> | string
    localizedTitle?: StringNullableWithAggregatesFilter<"Movie"> | string | null
    plot?: StringWithAggregatesFilter<"Movie"> | string
    localizedPlot?: StringNullableWithAggregatesFilter<"Movie"> | string | null
    runtimeMinutes?: IntWithAggregatesFilter<"Movie"> | number
    originalLanguageId?: StringWithAggregatesFilter<"Movie"> | string
    countryOfOriginId?: StringWithAggregatesFilter<"Movie"> | string
    posterImages?: JsonWithAggregatesFilter<"Movie">
    videos?: JsonWithAggregatesFilter<"Movie">
    rating?: IntWithAggregatesFilter<"Movie"> | number
    releaseDate?: DateTimeWithAggregatesFilter<"Movie"> | Date | string
    createdAt?: DateTimeWithAggregatesFilter<"Movie"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Movie"> | Date | string
    externalId?: StringWithAggregatesFilter<"Movie"> | string
    externalType?: EnumInputProviderWithAggregatesFilter<"Movie"> | $Enums.InputProvider
    additionalData?: JsonWithAggregatesFilter<"Movie">
  }

  export type PersonWhereInput = {
    AND?: PersonWhereInput | PersonWhereInput[]
    OR?: PersonWhereInput[]
    NOT?: PersonWhereInput | PersonWhereInput[]
    id?: UuidFilter<"Person"> | string
    name?: StringFilter<"Person"> | string
    biography?: StringFilter<"Person"> | string
    dateOfBirth?: DateTimeNullableFilter<"Person"> | Date | string | null
    dateOfDeath?: DateTimeNullableFilter<"Person"> | Date | string | null
    gender?: EnumGenderFilter<"Person"> | $Enums.Gender
    createdAt?: DateTimeFilter<"Person"> | Date | string
    updatedAt?: DateTimeFilter<"Person"> | Date | string
    externalId?: StringFilter<"Person"> | string
    externalType?: EnumInputProviderFilter<"Person"> | $Enums.InputProvider
    additionalData?: JsonFilter<"Person">
    actorInMovies?: MovieActorListRelationFilter
    directorInMovies?: MovieDirectorListRelationFilter
    producerInMovies?: MovieProducerListRelationFilter
  }

  export type PersonOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    biography?: SortOrder
    dateOfBirth?: SortOrderInput | SortOrder
    dateOfDeath?: SortOrderInput | SortOrder
    gender?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    externalId?: SortOrder
    externalType?: SortOrder
    additionalData?: SortOrder
    actorInMovies?: MovieActorOrderByRelationAggregateInput
    directorInMovies?: MovieDirectorOrderByRelationAggregateInput
    producerInMovies?: MovieProducerOrderByRelationAggregateInput
  }

  export type PersonWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    externalId_externalType?: PersonExternalIdExternalTypeCompoundUniqueInput
    AND?: PersonWhereInput | PersonWhereInput[]
    OR?: PersonWhereInput[]
    NOT?: PersonWhereInput | PersonWhereInput[]
    name?: StringFilter<"Person"> | string
    biography?: StringFilter<"Person"> | string
    dateOfBirth?: DateTimeNullableFilter<"Person"> | Date | string | null
    dateOfDeath?: DateTimeNullableFilter<"Person"> | Date | string | null
    gender?: EnumGenderFilter<"Person"> | $Enums.Gender
    createdAt?: DateTimeFilter<"Person"> | Date | string
    updatedAt?: DateTimeFilter<"Person"> | Date | string
    externalId?: StringFilter<"Person"> | string
    externalType?: EnumInputProviderFilter<"Person"> | $Enums.InputProvider
    additionalData?: JsonFilter<"Person">
    actorInMovies?: MovieActorListRelationFilter
    directorInMovies?: MovieDirectorListRelationFilter
    producerInMovies?: MovieProducerListRelationFilter
  }, "id" | "externalId_externalType">

  export type PersonOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    biography?: SortOrder
    dateOfBirth?: SortOrderInput | SortOrder
    dateOfDeath?: SortOrderInput | SortOrder
    gender?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    externalId?: SortOrder
    externalType?: SortOrder
    additionalData?: SortOrder
    _count?: PersonCountOrderByAggregateInput
    _max?: PersonMaxOrderByAggregateInput
    _min?: PersonMinOrderByAggregateInput
  }

  export type PersonScalarWhereWithAggregatesInput = {
    AND?: PersonScalarWhereWithAggregatesInput | PersonScalarWhereWithAggregatesInput[]
    OR?: PersonScalarWhereWithAggregatesInput[]
    NOT?: PersonScalarWhereWithAggregatesInput | PersonScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"Person"> | string
    name?: StringWithAggregatesFilter<"Person"> | string
    biography?: StringWithAggregatesFilter<"Person"> | string
    dateOfBirth?: DateTimeNullableWithAggregatesFilter<"Person"> | Date | string | null
    dateOfDeath?: DateTimeNullableWithAggregatesFilter<"Person"> | Date | string | null
    gender?: EnumGenderWithAggregatesFilter<"Person"> | $Enums.Gender
    createdAt?: DateTimeWithAggregatesFilter<"Person"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Person"> | Date | string
    externalId?: StringWithAggregatesFilter<"Person"> | string
    externalType?: EnumInputProviderWithAggregatesFilter<"Person"> | $Enums.InputProvider
    additionalData?: JsonWithAggregatesFilter<"Person">
  }

  export type MovieActorWhereInput = {
    AND?: MovieActorWhereInput | MovieActorWhereInput[]
    OR?: MovieActorWhereInput[]
    NOT?: MovieActorWhereInput | MovieActorWhereInput[]
    personId?: UuidFilter<"MovieActor"> | string
    movieId?: UuidFilter<"MovieActor"> | string
    characterName?: StringFilter<"MovieActor"> | string
    castOrder?: IntFilter<"MovieActor"> | number
    person?: XOR<PersonRelationFilter, PersonWhereInput>
    movie?: XOR<MovieRelationFilter, MovieWhereInput>
  }

  export type MovieActorOrderByWithRelationInput = {
    personId?: SortOrder
    movieId?: SortOrder
    characterName?: SortOrder
    castOrder?: SortOrder
    person?: PersonOrderByWithRelationInput
    movie?: MovieOrderByWithRelationInput
  }

  export type MovieActorWhereUniqueInput = Prisma.AtLeast<{
    personId_movieId?: MovieActorPersonIdMovieIdCompoundUniqueInput
    AND?: MovieActorWhereInput | MovieActorWhereInput[]
    OR?: MovieActorWhereInput[]
    NOT?: MovieActorWhereInput | MovieActorWhereInput[]
    personId?: UuidFilter<"MovieActor"> | string
    movieId?: UuidFilter<"MovieActor"> | string
    characterName?: StringFilter<"MovieActor"> | string
    castOrder?: IntFilter<"MovieActor"> | number
    person?: XOR<PersonRelationFilter, PersonWhereInput>
    movie?: XOR<MovieRelationFilter, MovieWhereInput>
  }, "personId_movieId">

  export type MovieActorOrderByWithAggregationInput = {
    personId?: SortOrder
    movieId?: SortOrder
    characterName?: SortOrder
    castOrder?: SortOrder
    _count?: MovieActorCountOrderByAggregateInput
    _avg?: MovieActorAvgOrderByAggregateInput
    _max?: MovieActorMaxOrderByAggregateInput
    _min?: MovieActorMinOrderByAggregateInput
    _sum?: MovieActorSumOrderByAggregateInput
  }

  export type MovieActorScalarWhereWithAggregatesInput = {
    AND?: MovieActorScalarWhereWithAggregatesInput | MovieActorScalarWhereWithAggregatesInput[]
    OR?: MovieActorScalarWhereWithAggregatesInput[]
    NOT?: MovieActorScalarWhereWithAggregatesInput | MovieActorScalarWhereWithAggregatesInput[]
    personId?: UuidWithAggregatesFilter<"MovieActor"> | string
    movieId?: UuidWithAggregatesFilter<"MovieActor"> | string
    characterName?: StringWithAggregatesFilter<"MovieActor"> | string
    castOrder?: IntWithAggregatesFilter<"MovieActor"> | number
  }

  export type MovieDirectorWhereInput = {
    AND?: MovieDirectorWhereInput | MovieDirectorWhereInput[]
    OR?: MovieDirectorWhereInput[]
    NOT?: MovieDirectorWhereInput | MovieDirectorWhereInput[]
    personId?: UuidFilter<"MovieDirector"> | string
    movieId?: UuidFilter<"MovieDirector"> | string
    type?: EnumDirectorTypeFilter<"MovieDirector"> | $Enums.DirectorType
    person?: XOR<PersonRelationFilter, PersonWhereInput>
    movie?: XOR<MovieRelationFilter, MovieWhereInput>
  }

  export type MovieDirectorOrderByWithRelationInput = {
    personId?: SortOrder
    movieId?: SortOrder
    type?: SortOrder
    person?: PersonOrderByWithRelationInput
    movie?: MovieOrderByWithRelationInput
  }

  export type MovieDirectorWhereUniqueInput = Prisma.AtLeast<{
    personId_movieId?: MovieDirectorPersonIdMovieIdCompoundUniqueInput
    AND?: MovieDirectorWhereInput | MovieDirectorWhereInput[]
    OR?: MovieDirectorWhereInput[]
    NOT?: MovieDirectorWhereInput | MovieDirectorWhereInput[]
    personId?: UuidFilter<"MovieDirector"> | string
    movieId?: UuidFilter<"MovieDirector"> | string
    type?: EnumDirectorTypeFilter<"MovieDirector"> | $Enums.DirectorType
    person?: XOR<PersonRelationFilter, PersonWhereInput>
    movie?: XOR<MovieRelationFilter, MovieWhereInput>
  }, "personId_movieId">

  export type MovieDirectorOrderByWithAggregationInput = {
    personId?: SortOrder
    movieId?: SortOrder
    type?: SortOrder
    _count?: MovieDirectorCountOrderByAggregateInput
    _max?: MovieDirectorMaxOrderByAggregateInput
    _min?: MovieDirectorMinOrderByAggregateInput
  }

  export type MovieDirectorScalarWhereWithAggregatesInput = {
    AND?: MovieDirectorScalarWhereWithAggregatesInput | MovieDirectorScalarWhereWithAggregatesInput[]
    OR?: MovieDirectorScalarWhereWithAggregatesInput[]
    NOT?: MovieDirectorScalarWhereWithAggregatesInput | MovieDirectorScalarWhereWithAggregatesInput[]
    personId?: UuidWithAggregatesFilter<"MovieDirector"> | string
    movieId?: UuidWithAggregatesFilter<"MovieDirector"> | string
    type?: EnumDirectorTypeWithAggregatesFilter<"MovieDirector"> | $Enums.DirectorType
  }

  export type MovieProducerWhereInput = {
    AND?: MovieProducerWhereInput | MovieProducerWhereInput[]
    OR?: MovieProducerWhereInput[]
    NOT?: MovieProducerWhereInput | MovieProducerWhereInput[]
    personId?: UuidFilter<"MovieProducer"> | string
    movieId?: UuidFilter<"MovieProducer"> | string
    type?: EnumProducerTypeFilter<"MovieProducer"> | $Enums.ProducerType
    person?: XOR<PersonRelationFilter, PersonWhereInput>
    movie?: XOR<MovieRelationFilter, MovieWhereInput>
  }

  export type MovieProducerOrderByWithRelationInput = {
    personId?: SortOrder
    movieId?: SortOrder
    type?: SortOrder
    person?: PersonOrderByWithRelationInput
    movie?: MovieOrderByWithRelationInput
  }

  export type MovieProducerWhereUniqueInput = Prisma.AtLeast<{
    personId_movieId?: MovieProducerPersonIdMovieIdCompoundUniqueInput
    AND?: MovieProducerWhereInput | MovieProducerWhereInput[]
    OR?: MovieProducerWhereInput[]
    NOT?: MovieProducerWhereInput | MovieProducerWhereInput[]
    personId?: UuidFilter<"MovieProducer"> | string
    movieId?: UuidFilter<"MovieProducer"> | string
    type?: EnumProducerTypeFilter<"MovieProducer"> | $Enums.ProducerType
    person?: XOR<PersonRelationFilter, PersonWhereInput>
    movie?: XOR<MovieRelationFilter, MovieWhereInput>
  }, "personId_movieId">

  export type MovieProducerOrderByWithAggregationInput = {
    personId?: SortOrder
    movieId?: SortOrder
    type?: SortOrder
    _count?: MovieProducerCountOrderByAggregateInput
    _max?: MovieProducerMaxOrderByAggregateInput
    _min?: MovieProducerMinOrderByAggregateInput
  }

  export type MovieProducerScalarWhereWithAggregatesInput = {
    AND?: MovieProducerScalarWhereWithAggregatesInput | MovieProducerScalarWhereWithAggregatesInput[]
    OR?: MovieProducerScalarWhereWithAggregatesInput[]
    NOT?: MovieProducerScalarWhereWithAggregatesInput | MovieProducerScalarWhereWithAggregatesInput[]
    personId?: UuidWithAggregatesFilter<"MovieProducer"> | string
    movieId?: UuidWithAggregatesFilter<"MovieProducer"> | string
    type?: EnumProducerTypeWithAggregatesFilter<"MovieProducer"> | $Enums.ProducerType
  }

  export type MovieCinemaOverrideWhereInput = {
    AND?: MovieCinemaOverrideWhereInput | MovieCinemaOverrideWhereInput[]
    OR?: MovieCinemaOverrideWhereInput[]
    NOT?: MovieCinemaOverrideWhereInput | MovieCinemaOverrideWhereInput[]
    movieId?: UuidFilter<"MovieCinemaOverride"> | string
    cinemaId?: UuidFilter<"MovieCinemaOverride"> | string
    movieDataOverrides?: JsonFilter<"MovieCinemaOverride">
    createdAt?: DateTimeFilter<"MovieCinemaOverride"> | Date | string
    updatedAt?: DateTimeFilter<"MovieCinemaOverride"> | Date | string
    movie?: XOR<MovieRelationFilter, MovieWhereInput>
    cinema?: XOR<CinemaRelationFilter, CinemaWhereInput>
  }

  export type MovieCinemaOverrideOrderByWithRelationInput = {
    movieId?: SortOrder
    cinemaId?: SortOrder
    movieDataOverrides?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    movie?: MovieOrderByWithRelationInput
    cinema?: CinemaOrderByWithRelationInput
  }

  export type MovieCinemaOverrideWhereUniqueInput = Prisma.AtLeast<{
    movieId_cinemaId?: MovieCinemaOverrideMovieIdCinemaIdCompoundUniqueInput
    AND?: MovieCinemaOverrideWhereInput | MovieCinemaOverrideWhereInput[]
    OR?: MovieCinemaOverrideWhereInput[]
    NOT?: MovieCinemaOverrideWhereInput | MovieCinemaOverrideWhereInput[]
    movieId?: UuidFilter<"MovieCinemaOverride"> | string
    cinemaId?: UuidFilter<"MovieCinemaOverride"> | string
    movieDataOverrides?: JsonFilter<"MovieCinemaOverride">
    createdAt?: DateTimeFilter<"MovieCinemaOverride"> | Date | string
    updatedAt?: DateTimeFilter<"MovieCinemaOverride"> | Date | string
    movie?: XOR<MovieRelationFilter, MovieWhereInput>
    cinema?: XOR<CinemaRelationFilter, CinemaWhereInput>
  }, "movieId_cinemaId">

  export type MovieCinemaOverrideOrderByWithAggregationInput = {
    movieId?: SortOrder
    cinemaId?: SortOrder
    movieDataOverrides?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: MovieCinemaOverrideCountOrderByAggregateInput
    _max?: MovieCinemaOverrideMaxOrderByAggregateInput
    _min?: MovieCinemaOverrideMinOrderByAggregateInput
  }

  export type MovieCinemaOverrideScalarWhereWithAggregatesInput = {
    AND?: MovieCinemaOverrideScalarWhereWithAggregatesInput | MovieCinemaOverrideScalarWhereWithAggregatesInput[]
    OR?: MovieCinemaOverrideScalarWhereWithAggregatesInput[]
    NOT?: MovieCinemaOverrideScalarWhereWithAggregatesInput | MovieCinemaOverrideScalarWhereWithAggregatesInput[]
    movieId?: UuidWithAggregatesFilter<"MovieCinemaOverride"> | string
    cinemaId?: UuidWithAggregatesFilter<"MovieCinemaOverride"> | string
    movieDataOverrides?: JsonWithAggregatesFilter<"MovieCinemaOverride">
    createdAt?: DateTimeWithAggregatesFilter<"MovieCinemaOverride"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"MovieCinemaOverride"> | Date | string
  }

  export type MovieProjectionWhereInput = {
    AND?: MovieProjectionWhereInput | MovieProjectionWhereInput[]
    OR?: MovieProjectionWhereInput[]
    NOT?: MovieProjectionWhereInput | MovieProjectionWhereInput[]
    id?: UuidFilter<"MovieProjection"> | string
    movieId?: UuidFilter<"MovieProjection"> | string
    cinemaTheaterId?: UuidFilter<"MovieProjection"> | string
    projectionDateTime?: DateTimeFilter<"MovieProjection"> | Date | string
    createdAt?: DateTimeFilter<"MovieProjection"> | Date | string
    updatedAt?: DateTimeFilter<"MovieProjection"> | Date | string
    dubbedLanguageId?: StringNullableFilter<"MovieProjection"> | string | null
    options?: JsonFilter<"MovieProjection">
    movie?: XOR<MovieRelationFilter, MovieWhereInput>
    cinemaTheater?: XOR<CinemaTheaterRelationFilter, CinemaTheaterWhereInput>
    dubbedLanguage?: XOR<LanguageNullableRelationFilter, LanguageWhereInput> | null
    projectionPrices?: ProjectionPriceListRelationFilter
    reservations?: ReservationListRelationFilter
  }

  export type MovieProjectionOrderByWithRelationInput = {
    id?: SortOrder
    movieId?: SortOrder
    cinemaTheaterId?: SortOrder
    projectionDateTime?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    dubbedLanguageId?: SortOrderInput | SortOrder
    options?: SortOrder
    movie?: MovieOrderByWithRelationInput
    cinemaTheater?: CinemaTheaterOrderByWithRelationInput
    dubbedLanguage?: LanguageOrderByWithRelationInput
    projectionPrices?: ProjectionPriceOrderByRelationAggregateInput
    reservations?: ReservationOrderByRelationAggregateInput
  }

  export type MovieProjectionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: MovieProjectionWhereInput | MovieProjectionWhereInput[]
    OR?: MovieProjectionWhereInput[]
    NOT?: MovieProjectionWhereInput | MovieProjectionWhereInput[]
    movieId?: UuidFilter<"MovieProjection"> | string
    cinemaTheaterId?: UuidFilter<"MovieProjection"> | string
    projectionDateTime?: DateTimeFilter<"MovieProjection"> | Date | string
    createdAt?: DateTimeFilter<"MovieProjection"> | Date | string
    updatedAt?: DateTimeFilter<"MovieProjection"> | Date | string
    dubbedLanguageId?: StringNullableFilter<"MovieProjection"> | string | null
    options?: JsonFilter<"MovieProjection">
    movie?: XOR<MovieRelationFilter, MovieWhereInput>
    cinemaTheater?: XOR<CinemaTheaterRelationFilter, CinemaTheaterWhereInput>
    dubbedLanguage?: XOR<LanguageNullableRelationFilter, LanguageWhereInput> | null
    projectionPrices?: ProjectionPriceListRelationFilter
    reservations?: ReservationListRelationFilter
  }, "id">

  export type MovieProjectionOrderByWithAggregationInput = {
    id?: SortOrder
    movieId?: SortOrder
    cinemaTheaterId?: SortOrder
    projectionDateTime?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    dubbedLanguageId?: SortOrderInput | SortOrder
    options?: SortOrder
    _count?: MovieProjectionCountOrderByAggregateInput
    _max?: MovieProjectionMaxOrderByAggregateInput
    _min?: MovieProjectionMinOrderByAggregateInput
  }

  export type MovieProjectionScalarWhereWithAggregatesInput = {
    AND?: MovieProjectionScalarWhereWithAggregatesInput | MovieProjectionScalarWhereWithAggregatesInput[]
    OR?: MovieProjectionScalarWhereWithAggregatesInput[]
    NOT?: MovieProjectionScalarWhereWithAggregatesInput | MovieProjectionScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"MovieProjection"> | string
    movieId?: UuidWithAggregatesFilter<"MovieProjection"> | string
    cinemaTheaterId?: UuidWithAggregatesFilter<"MovieProjection"> | string
    projectionDateTime?: DateTimeWithAggregatesFilter<"MovieProjection"> | Date | string
    createdAt?: DateTimeWithAggregatesFilter<"MovieProjection"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"MovieProjection"> | Date | string
    dubbedLanguageId?: StringNullableWithAggregatesFilter<"MovieProjection"> | string | null
    options?: JsonWithAggregatesFilter<"MovieProjection">
  }

  export type ProjectionPriceWhereInput = {
    AND?: ProjectionPriceWhereInput | ProjectionPriceWhereInput[]
    OR?: ProjectionPriceWhereInput[]
    NOT?: ProjectionPriceWhereInput | ProjectionPriceWhereInput[]
    projectionId?: UuidFilter<"ProjectionPrice"> | string
    groupId?: UuidFilter<"ProjectionPrice"> | string
    type?: EnumPriceTypeFilter<"ProjectionPrice"> | $Enums.PriceType
    price?: DecimalFilter<"ProjectionPrice"> | Decimal | DecimalJsLike | number | string
    currencyCode?: EnumCurrencyCodeFilter<"ProjectionPrice"> | $Enums.CurrencyCode
    cinemaSeatGroup?: XOR<CinemaSeatGroupRelationFilter, CinemaSeatGroupWhereInput>
    movieProjection?: XOR<MovieProjectionRelationFilter, MovieProjectionWhereInput>
  }

  export type ProjectionPriceOrderByWithRelationInput = {
    projectionId?: SortOrder
    groupId?: SortOrder
    type?: SortOrder
    price?: SortOrder
    currencyCode?: SortOrder
    cinemaSeatGroup?: CinemaSeatGroupOrderByWithRelationInput
    movieProjection?: MovieProjectionOrderByWithRelationInput
  }

  export type ProjectionPriceWhereUniqueInput = Prisma.AtLeast<{
    projectionId_groupId?: ProjectionPriceProjectionIdGroupIdCompoundUniqueInput
    AND?: ProjectionPriceWhereInput | ProjectionPriceWhereInput[]
    OR?: ProjectionPriceWhereInput[]
    NOT?: ProjectionPriceWhereInput | ProjectionPriceWhereInput[]
    projectionId?: UuidFilter<"ProjectionPrice"> | string
    groupId?: UuidFilter<"ProjectionPrice"> | string
    type?: EnumPriceTypeFilter<"ProjectionPrice"> | $Enums.PriceType
    price?: DecimalFilter<"ProjectionPrice"> | Decimal | DecimalJsLike | number | string
    currencyCode?: EnumCurrencyCodeFilter<"ProjectionPrice"> | $Enums.CurrencyCode
    cinemaSeatGroup?: XOR<CinemaSeatGroupRelationFilter, CinemaSeatGroupWhereInput>
    movieProjection?: XOR<MovieProjectionRelationFilter, MovieProjectionWhereInput>
  }, "projectionId_groupId">

  export type ProjectionPriceOrderByWithAggregationInput = {
    projectionId?: SortOrder
    groupId?: SortOrder
    type?: SortOrder
    price?: SortOrder
    currencyCode?: SortOrder
    _count?: ProjectionPriceCountOrderByAggregateInput
    _avg?: ProjectionPriceAvgOrderByAggregateInput
    _max?: ProjectionPriceMaxOrderByAggregateInput
    _min?: ProjectionPriceMinOrderByAggregateInput
    _sum?: ProjectionPriceSumOrderByAggregateInput
  }

  export type ProjectionPriceScalarWhereWithAggregatesInput = {
    AND?: ProjectionPriceScalarWhereWithAggregatesInput | ProjectionPriceScalarWhereWithAggregatesInput[]
    OR?: ProjectionPriceScalarWhereWithAggregatesInput[]
    NOT?: ProjectionPriceScalarWhereWithAggregatesInput | ProjectionPriceScalarWhereWithAggregatesInput[]
    projectionId?: UuidWithAggregatesFilter<"ProjectionPrice"> | string
    groupId?: UuidWithAggregatesFilter<"ProjectionPrice"> | string
    type?: EnumPriceTypeWithAggregatesFilter<"ProjectionPrice"> | $Enums.PriceType
    price?: DecimalWithAggregatesFilter<"ProjectionPrice"> | Decimal | DecimalJsLike | number | string
    currencyCode?: EnumCurrencyCodeWithAggregatesFilter<"ProjectionPrice"> | $Enums.CurrencyCode
  }

  export type AdminUserWhereInput = {
    AND?: AdminUserWhereInput | AdminUserWhereInput[]
    OR?: AdminUserWhereInput[]
    NOT?: AdminUserWhereInput | AdminUserWhereInput[]
    id?: UuidFilter<"AdminUser"> | string
    email?: StringFilter<"AdminUser"> | string
    password?: StringFilter<"AdminUser"> | string
    fullName?: StringFilter<"AdminUser"> | string
    role?: EnumAdminRoleFilter<"AdminUser"> | $Enums.AdminRole
    cinemaIds?: JsonFilter<"AdminUser">
    createdAt?: DateTimeFilter<"AdminUser"> | Date | string
    updatedAt?: DateTimeFilter<"AdminUser"> | Date | string
    ValidatedReservationSeats?: ReservationSeatsListRelationFilter
  }

  export type AdminUserOrderByWithRelationInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    fullName?: SortOrder
    role?: SortOrder
    cinemaIds?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    ValidatedReservationSeats?: ReservationSeatsOrderByRelationAggregateInput
  }

  export type AdminUserWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    AND?: AdminUserWhereInput | AdminUserWhereInput[]
    OR?: AdminUserWhereInput[]
    NOT?: AdminUserWhereInput | AdminUserWhereInput[]
    password?: StringFilter<"AdminUser"> | string
    fullName?: StringFilter<"AdminUser"> | string
    role?: EnumAdminRoleFilter<"AdminUser"> | $Enums.AdminRole
    cinemaIds?: JsonFilter<"AdminUser">
    createdAt?: DateTimeFilter<"AdminUser"> | Date | string
    updatedAt?: DateTimeFilter<"AdminUser"> | Date | string
    ValidatedReservationSeats?: ReservationSeatsListRelationFilter
  }, "id" | "email">

  export type AdminUserOrderByWithAggregationInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    fullName?: SortOrder
    role?: SortOrder
    cinemaIds?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: AdminUserCountOrderByAggregateInput
    _max?: AdminUserMaxOrderByAggregateInput
    _min?: AdminUserMinOrderByAggregateInput
  }

  export type AdminUserScalarWhereWithAggregatesInput = {
    AND?: AdminUserScalarWhereWithAggregatesInput | AdminUserScalarWhereWithAggregatesInput[]
    OR?: AdminUserScalarWhereWithAggregatesInput[]
    NOT?: AdminUserScalarWhereWithAggregatesInput | AdminUserScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"AdminUser"> | string
    email?: StringWithAggregatesFilter<"AdminUser"> | string
    password?: StringWithAggregatesFilter<"AdminUser"> | string
    fullName?: StringWithAggregatesFilter<"AdminUser"> | string
    role?: EnumAdminRoleWithAggregatesFilter<"AdminUser"> | $Enums.AdminRole
    cinemaIds?: JsonWithAggregatesFilter<"AdminUser">
    createdAt?: DateTimeWithAggregatesFilter<"AdminUser"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"AdminUser"> | Date | string
  }

  export type ReservationWhereInput = {
    AND?: ReservationWhereInput | ReservationWhereInput[]
    OR?: ReservationWhereInput[]
    NOT?: ReservationWhereInput | ReservationWhereInput[]
    id?: UuidFilter<"Reservation"> | string
    eventId?: UuidFilter<"Reservation"> | string
    customerInformation?: JsonFilter<"Reservation">
    createdAt?: DateTimeFilter<"Reservation"> | Date | string
    updatedAt?: DateTimeFilter<"Reservation"> | Date | string
    options?: JsonFilter<"Reservation">
    deletedAt?: DateTimeNullableFilter<"Reservation"> | Date | string | null
    movieProjection?: XOR<MovieProjectionRelationFilter, MovieProjectionWhereInput>
    reservationSeats?: ReservationSeatsListRelationFilter
  }

  export type ReservationOrderByWithRelationInput = {
    id?: SortOrder
    eventId?: SortOrder
    customerInformation?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    options?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    movieProjection?: MovieProjectionOrderByWithRelationInput
    reservationSeats?: ReservationSeatsOrderByRelationAggregateInput
  }

  export type ReservationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ReservationWhereInput | ReservationWhereInput[]
    OR?: ReservationWhereInput[]
    NOT?: ReservationWhereInput | ReservationWhereInput[]
    eventId?: UuidFilter<"Reservation"> | string
    customerInformation?: JsonFilter<"Reservation">
    createdAt?: DateTimeFilter<"Reservation"> | Date | string
    updatedAt?: DateTimeFilter<"Reservation"> | Date | string
    options?: JsonFilter<"Reservation">
    deletedAt?: DateTimeNullableFilter<"Reservation"> | Date | string | null
    movieProjection?: XOR<MovieProjectionRelationFilter, MovieProjectionWhereInput>
    reservationSeats?: ReservationSeatsListRelationFilter
  }, "id">

  export type ReservationOrderByWithAggregationInput = {
    id?: SortOrder
    eventId?: SortOrder
    customerInformation?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    options?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    _count?: ReservationCountOrderByAggregateInput
    _max?: ReservationMaxOrderByAggregateInput
    _min?: ReservationMinOrderByAggregateInput
  }

  export type ReservationScalarWhereWithAggregatesInput = {
    AND?: ReservationScalarWhereWithAggregatesInput | ReservationScalarWhereWithAggregatesInput[]
    OR?: ReservationScalarWhereWithAggregatesInput[]
    NOT?: ReservationScalarWhereWithAggregatesInput | ReservationScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"Reservation"> | string
    eventId?: UuidWithAggregatesFilter<"Reservation"> | string
    customerInformation?: JsonWithAggregatesFilter<"Reservation">
    createdAt?: DateTimeWithAggregatesFilter<"Reservation"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Reservation"> | Date | string
    options?: JsonWithAggregatesFilter<"Reservation">
    deletedAt?: DateTimeNullableWithAggregatesFilter<"Reservation"> | Date | string | null
  }

  export type ReservationSeatsWhereInput = {
    AND?: ReservationSeatsWhereInput | ReservationSeatsWhereInput[]
    OR?: ReservationSeatsWhereInput[]
    NOT?: ReservationSeatsWhereInput | ReservationSeatsWhereInput[]
    id?: UuidFilter<"ReservationSeats"> | string
    reservationId?: UuidFilter<"ReservationSeats"> | string
    eventId?: UuidFilter<"ReservationSeats"> | string
    seatId?: UuidFilter<"ReservationSeats"> | string
    options?: JsonFilter<"ReservationSeats">
    deletedAt?: DateTimeNullableFilter<"ReservationSeats"> | Date | string | null
    validatedAt?: DateTimeNullableFilter<"ReservationSeats"> | Date | string | null
    validatedByAdminUserId?: UuidNullableFilter<"ReservationSeats"> | string | null
    reservation?: XOR<ReservationRelationFilter, ReservationWhereInput>
    cinemaSeat?: XOR<CinemaSeatRelationFilter, CinemaSeatWhereInput>
    validatedByAdminUser?: XOR<AdminUserNullableRelationFilter, AdminUserWhereInput> | null
  }

  export type ReservationSeatsOrderByWithRelationInput = {
    id?: SortOrder
    reservationId?: SortOrder
    eventId?: SortOrder
    seatId?: SortOrder
    options?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    validatedAt?: SortOrderInput | SortOrder
    validatedByAdminUserId?: SortOrderInput | SortOrder
    reservation?: ReservationOrderByWithRelationInput
    cinemaSeat?: CinemaSeatOrderByWithRelationInput
    validatedByAdminUser?: AdminUserOrderByWithRelationInput
  }

  export type ReservationSeatsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    reservationId_seatId?: ReservationSeatsReservationIdSeatIdCompoundUniqueInput
    seatId_eventId_deletedAt?: ReservationSeatsSeatIdEventIdDeletedAtCompoundUniqueInput
    AND?: ReservationSeatsWhereInput | ReservationSeatsWhereInput[]
    OR?: ReservationSeatsWhereInput[]
    NOT?: ReservationSeatsWhereInput | ReservationSeatsWhereInput[]
    reservationId?: UuidFilter<"ReservationSeats"> | string
    eventId?: UuidFilter<"ReservationSeats"> | string
    seatId?: UuidFilter<"ReservationSeats"> | string
    options?: JsonFilter<"ReservationSeats">
    deletedAt?: DateTimeNullableFilter<"ReservationSeats"> | Date | string | null
    validatedAt?: DateTimeNullableFilter<"ReservationSeats"> | Date | string | null
    validatedByAdminUserId?: UuidNullableFilter<"ReservationSeats"> | string | null
    reservation?: XOR<ReservationRelationFilter, ReservationWhereInput>
    cinemaSeat?: XOR<CinemaSeatRelationFilter, CinemaSeatWhereInput>
    validatedByAdminUser?: XOR<AdminUserNullableRelationFilter, AdminUserWhereInput> | null
  }, "id" | "reservationId_seatId" | "seatId_eventId_deletedAt">

  export type ReservationSeatsOrderByWithAggregationInput = {
    id?: SortOrder
    reservationId?: SortOrder
    eventId?: SortOrder
    seatId?: SortOrder
    options?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    validatedAt?: SortOrderInput | SortOrder
    validatedByAdminUserId?: SortOrderInput | SortOrder
    _count?: ReservationSeatsCountOrderByAggregateInput
    _max?: ReservationSeatsMaxOrderByAggregateInput
    _min?: ReservationSeatsMinOrderByAggregateInput
  }

  export type ReservationSeatsScalarWhereWithAggregatesInput = {
    AND?: ReservationSeatsScalarWhereWithAggregatesInput | ReservationSeatsScalarWhereWithAggregatesInput[]
    OR?: ReservationSeatsScalarWhereWithAggregatesInput[]
    NOT?: ReservationSeatsScalarWhereWithAggregatesInput | ReservationSeatsScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"ReservationSeats"> | string
    reservationId?: UuidWithAggregatesFilter<"ReservationSeats"> | string
    eventId?: UuidWithAggregatesFilter<"ReservationSeats"> | string
    seatId?: UuidWithAggregatesFilter<"ReservationSeats"> | string
    options?: JsonWithAggregatesFilter<"ReservationSeats">
    deletedAt?: DateTimeNullableWithAggregatesFilter<"ReservationSeats"> | Date | string | null
    validatedAt?: DateTimeNullableWithAggregatesFilter<"ReservationSeats"> | Date | string | null
    validatedByAdminUserId?: UuidNullableWithAggregatesFilter<"ReservationSeats"> | string | null
  }

  export type GenreCreateInput = {
    systemName: string
    localizedName: string
    movies?: MovieCreateNestedManyWithoutGenresInput
  }

  export type GenreUncheckedCreateInput = {
    systemName: string
    localizedName: string
    movies?: MovieUncheckedCreateNestedManyWithoutGenresInput
  }

  export type GenreUpdateInput = {
    systemName?: StringFieldUpdateOperationsInput | string
    localizedName?: StringFieldUpdateOperationsInput | string
    movies?: MovieUpdateManyWithoutGenresNestedInput
  }

  export type GenreUncheckedUpdateInput = {
    systemName?: StringFieldUpdateOperationsInput | string
    localizedName?: StringFieldUpdateOperationsInput | string
    movies?: MovieUncheckedUpdateManyWithoutGenresNestedInput
  }

  export type GenreCreateManyInput = {
    systemName: string
    localizedName: string
  }

  export type GenreUpdateManyMutationInput = {
    systemName?: StringFieldUpdateOperationsInput | string
    localizedName?: StringFieldUpdateOperationsInput | string
  }

  export type GenreUncheckedUpdateManyInput = {
    systemName?: StringFieldUpdateOperationsInput | string
    localizedName?: StringFieldUpdateOperationsInput | string
  }

  export type LanguageCreateInput = {
    code: string
    name: string
    originalLanguageMovies?: MovieCreateNestedManyWithoutOriginalLanguageInput
    dubbedLanguageMovieProjections?: MovieProjectionCreateNestedManyWithoutDubbedLanguageInput
  }

  export type LanguageUncheckedCreateInput = {
    code: string
    name: string
    originalLanguageMovies?: MovieUncheckedCreateNestedManyWithoutOriginalLanguageInput
    dubbedLanguageMovieProjections?: MovieProjectionUncheckedCreateNestedManyWithoutDubbedLanguageInput
  }

  export type LanguageUpdateInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    originalLanguageMovies?: MovieUpdateManyWithoutOriginalLanguageNestedInput
    dubbedLanguageMovieProjections?: MovieProjectionUpdateManyWithoutDubbedLanguageNestedInput
  }

  export type LanguageUncheckedUpdateInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    originalLanguageMovies?: MovieUncheckedUpdateManyWithoutOriginalLanguageNestedInput
    dubbedLanguageMovieProjections?: MovieProjectionUncheckedUpdateManyWithoutDubbedLanguageNestedInput
  }

  export type LanguageCreateManyInput = {
    code: string
    name: string
  }

  export type LanguageUpdateManyMutationInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
  }

  export type LanguageUncheckedUpdateManyInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
  }

  export type CountryCreateInput = {
    code: string
    name: string
    cities?: CityCreateNestedManyWithoutCountryInput
    movies?: MovieCreateNestedManyWithoutCountryOfOriginInput
  }

  export type CountryUncheckedCreateInput = {
    code: string
    name: string
    cities?: CityUncheckedCreateNestedManyWithoutCountryInput
    movies?: MovieUncheckedCreateNestedManyWithoutCountryOfOriginInput
  }

  export type CountryUpdateInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    cities?: CityUpdateManyWithoutCountryNestedInput
    movies?: MovieUpdateManyWithoutCountryOfOriginNestedInput
  }

  export type CountryUncheckedUpdateInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    cities?: CityUncheckedUpdateManyWithoutCountryNestedInput
    movies?: MovieUncheckedUpdateManyWithoutCountryOfOriginNestedInput
  }

  export type CountryCreateManyInput = {
    code: string
    name: string
  }

  export type CountryUpdateManyMutationInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
  }

  export type CountryUncheckedUpdateManyInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
  }

  export type CityCreateInput = {
    id?: string
    cityCode: string
    name: string
    postalCode: string
    country: CountryCreateNestedOneWithoutCitiesInput
    cinemas?: CinemaCreateNestedManyWithoutCityInput
  }

  export type CityUncheckedCreateInput = {
    id?: string
    cityCode: string
    name: string
    postalCode: string
    countryCode: string
    cinemas?: CinemaUncheckedCreateNestedManyWithoutCityInput
  }

  export type CityUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    cityCode?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    postalCode?: StringFieldUpdateOperationsInput | string
    country?: CountryUpdateOneRequiredWithoutCitiesNestedInput
    cinemas?: CinemaUpdateManyWithoutCityNestedInput
  }

  export type CityUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    cityCode?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    postalCode?: StringFieldUpdateOperationsInput | string
    countryCode?: StringFieldUpdateOperationsInput | string
    cinemas?: CinemaUncheckedUpdateManyWithoutCityNestedInput
  }

  export type CityCreateManyInput = {
    id?: string
    cityCode: string
    name: string
    postalCode: string
    countryCode: string
  }

  export type CityUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    cityCode?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    postalCode?: StringFieldUpdateOperationsInput | string
  }

  export type CityUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    cityCode?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    postalCode?: StringFieldUpdateOperationsInput | string
    countryCode?: StringFieldUpdateOperationsInput | string
  }

  export type CinemaCreateInput = {
    id?: string
    name: string
    description: string
    address: string
    rating: number
    phone?: JsonNullValueInput | InputJsonValue
    posterImages?: JsonNullValueInput | InputJsonValue
    geoLatitude?: Decimal | DecimalJsLike | number | string | null
    geoLongitude?: Decimal | DecimalJsLike | number | string | null
    city: CityCreateNestedOneWithoutCinemasInput
    cinemaTheaters?: CinemaTheaterCreateNestedManyWithoutCinemaInput
    movieCinemaOverrides?: MovieCinemaOverrideCreateNestedManyWithoutCinemaInput
  }

  export type CinemaUncheckedCreateInput = {
    id?: string
    name: string
    description: string
    cityId: string
    address: string
    rating: number
    phone?: JsonNullValueInput | InputJsonValue
    posterImages?: JsonNullValueInput | InputJsonValue
    geoLatitude?: Decimal | DecimalJsLike | number | string | null
    geoLongitude?: Decimal | DecimalJsLike | number | string | null
    cinemaTheaters?: CinemaTheaterUncheckedCreateNestedManyWithoutCinemaInput
    movieCinemaOverrides?: MovieCinemaOverrideUncheckedCreateNestedManyWithoutCinemaInput
  }

  export type CinemaUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    phone?: JsonNullValueInput | InputJsonValue
    posterImages?: JsonNullValueInput | InputJsonValue
    geoLatitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    geoLongitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    city?: CityUpdateOneRequiredWithoutCinemasNestedInput
    cinemaTheaters?: CinemaTheaterUpdateManyWithoutCinemaNestedInput
    movieCinemaOverrides?: MovieCinemaOverrideUpdateManyWithoutCinemaNestedInput
  }

  export type CinemaUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    cityId?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    phone?: JsonNullValueInput | InputJsonValue
    posterImages?: JsonNullValueInput | InputJsonValue
    geoLatitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    geoLongitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    cinemaTheaters?: CinemaTheaterUncheckedUpdateManyWithoutCinemaNestedInput
    movieCinemaOverrides?: MovieCinemaOverrideUncheckedUpdateManyWithoutCinemaNestedInput
  }

  export type CinemaCreateManyInput = {
    id?: string
    name: string
    description: string
    cityId: string
    address: string
    rating: number
    phone?: JsonNullValueInput | InputJsonValue
    posterImages?: JsonNullValueInput | InputJsonValue
    geoLatitude?: Decimal | DecimalJsLike | number | string | null
    geoLongitude?: Decimal | DecimalJsLike | number | string | null
  }

  export type CinemaUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    phone?: JsonNullValueInput | InputJsonValue
    posterImages?: JsonNullValueInput | InputJsonValue
    geoLatitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    geoLongitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
  }

  export type CinemaUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    cityId?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    phone?: JsonNullValueInput | InputJsonValue
    posterImages?: JsonNullValueInput | InputJsonValue
    geoLatitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    geoLongitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
  }

  export type CinemaTheaterCreateInput = {
    id?: string
    name: string
    supports3D?: boolean
    posterImages?: JsonNullValueInput | InputJsonValue
    cinema: CinemaCreateNestedOneWithoutCinemaTheatersInput
    cinemaSeatGroups?: CinemaSeatGroupCreateNestedManyWithoutCinemaTheaterInput
    movieProjections?: MovieProjectionCreateNestedManyWithoutCinemaTheaterInput
  }

  export type CinemaTheaterUncheckedCreateInput = {
    id?: string
    name: string
    cinemaId: string
    supports3D?: boolean
    posterImages?: JsonNullValueInput | InputJsonValue
    cinemaSeatGroups?: CinemaSeatGroupUncheckedCreateNestedManyWithoutCinemaTheaterInput
    movieProjections?: MovieProjectionUncheckedCreateNestedManyWithoutCinemaTheaterInput
  }

  export type CinemaTheaterUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    supports3D?: BoolFieldUpdateOperationsInput | boolean
    posterImages?: JsonNullValueInput | InputJsonValue
    cinema?: CinemaUpdateOneRequiredWithoutCinemaTheatersNestedInput
    cinemaSeatGroups?: CinemaSeatGroupUpdateManyWithoutCinemaTheaterNestedInput
    movieProjections?: MovieProjectionUpdateManyWithoutCinemaTheaterNestedInput
  }

  export type CinemaTheaterUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    cinemaId?: StringFieldUpdateOperationsInput | string
    supports3D?: BoolFieldUpdateOperationsInput | boolean
    posterImages?: JsonNullValueInput | InputJsonValue
    cinemaSeatGroups?: CinemaSeatGroupUncheckedUpdateManyWithoutCinemaTheaterNestedInput
    movieProjections?: MovieProjectionUncheckedUpdateManyWithoutCinemaTheaterNestedInput
  }

  export type CinemaTheaterCreateManyInput = {
    id?: string
    name: string
    cinemaId: string
    supports3D?: boolean
    posterImages?: JsonNullValueInput | InputJsonValue
  }

  export type CinemaTheaterUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    supports3D?: BoolFieldUpdateOperationsInput | boolean
    posterImages?: JsonNullValueInput | InputJsonValue
  }

  export type CinemaTheaterUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    cinemaId?: StringFieldUpdateOperationsInput | string
    supports3D?: BoolFieldUpdateOperationsInput | boolean
    posterImages?: JsonNullValueInput | InputJsonValue
  }

  export type CinemaSeatGroupCreateInput = {
    id?: string
    name: string
    rowCount: number
    columnCount: number
    position?: $Enums.CinemaSeatGroupPositionEnum
    options?: JsonNullValueInput | InputJsonValue
    cinemaTheater: CinemaTheaterCreateNestedOneWithoutCinemaSeatGroupsInput
    cinemaSeats?: CinemaSeatCreateNestedManyWithoutCinemaSeatGroupInput
    projectionPrices?: ProjectionPriceCreateNestedManyWithoutCinemaSeatGroupInput
  }

  export type CinemaSeatGroupUncheckedCreateInput = {
    id?: string
    cinemaTheaterId: string
    name: string
    rowCount: number
    columnCount: number
    position?: $Enums.CinemaSeatGroupPositionEnum
    options?: JsonNullValueInput | InputJsonValue
    cinemaSeats?: CinemaSeatUncheckedCreateNestedManyWithoutCinemaSeatGroupInput
    projectionPrices?: ProjectionPriceUncheckedCreateNestedManyWithoutCinemaSeatGroupInput
  }

  export type CinemaSeatGroupUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    rowCount?: IntFieldUpdateOperationsInput | number
    columnCount?: IntFieldUpdateOperationsInput | number
    position?: EnumCinemaSeatGroupPositionEnumFieldUpdateOperationsInput | $Enums.CinemaSeatGroupPositionEnum
    options?: JsonNullValueInput | InputJsonValue
    cinemaTheater?: CinemaTheaterUpdateOneRequiredWithoutCinemaSeatGroupsNestedInput
    cinemaSeats?: CinemaSeatUpdateManyWithoutCinemaSeatGroupNestedInput
    projectionPrices?: ProjectionPriceUpdateManyWithoutCinemaSeatGroupNestedInput
  }

  export type CinemaSeatGroupUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    cinemaTheaterId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    rowCount?: IntFieldUpdateOperationsInput | number
    columnCount?: IntFieldUpdateOperationsInput | number
    position?: EnumCinemaSeatGroupPositionEnumFieldUpdateOperationsInput | $Enums.CinemaSeatGroupPositionEnum
    options?: JsonNullValueInput | InputJsonValue
    cinemaSeats?: CinemaSeatUncheckedUpdateManyWithoutCinemaSeatGroupNestedInput
    projectionPrices?: ProjectionPriceUncheckedUpdateManyWithoutCinemaSeatGroupNestedInput
  }

  export type CinemaSeatGroupCreateManyInput = {
    id?: string
    cinemaTheaterId: string
    name: string
    rowCount: number
    columnCount: number
    position?: $Enums.CinemaSeatGroupPositionEnum
    options?: JsonNullValueInput | InputJsonValue
  }

  export type CinemaSeatGroupUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    rowCount?: IntFieldUpdateOperationsInput | number
    columnCount?: IntFieldUpdateOperationsInput | number
    position?: EnumCinemaSeatGroupPositionEnumFieldUpdateOperationsInput | $Enums.CinemaSeatGroupPositionEnum
    options?: JsonNullValueInput | InputJsonValue
  }

  export type CinemaSeatGroupUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    cinemaTheaterId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    rowCount?: IntFieldUpdateOperationsInput | number
    columnCount?: IntFieldUpdateOperationsInput | number
    position?: EnumCinemaSeatGroupPositionEnumFieldUpdateOperationsInput | $Enums.CinemaSeatGroupPositionEnum
    options?: JsonNullValueInput | InputJsonValue
  }

  export type CinemaSeatCreateInput = {
    id?: string
    seatRow: string
    seatColumn: string
    options?: JsonNullValueInput | InputJsonValue
    cinemaSeatGroup: CinemaSeatGroupCreateNestedOneWithoutCinemaSeatsInput
    reservation?: ReservationSeatsCreateNestedManyWithoutCinemaSeatInput
  }

  export type CinemaSeatUncheckedCreateInput = {
    id?: string
    cinemaSeatGroupId: string
    seatRow: string
    seatColumn: string
    options?: JsonNullValueInput | InputJsonValue
    reservation?: ReservationSeatsUncheckedCreateNestedManyWithoutCinemaSeatInput
  }

  export type CinemaSeatUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    seatRow?: StringFieldUpdateOperationsInput | string
    seatColumn?: StringFieldUpdateOperationsInput | string
    options?: JsonNullValueInput | InputJsonValue
    cinemaSeatGroup?: CinemaSeatGroupUpdateOneRequiredWithoutCinemaSeatsNestedInput
    reservation?: ReservationSeatsUpdateManyWithoutCinemaSeatNestedInput
  }

  export type CinemaSeatUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    cinemaSeatGroupId?: StringFieldUpdateOperationsInput | string
    seatRow?: StringFieldUpdateOperationsInput | string
    seatColumn?: StringFieldUpdateOperationsInput | string
    options?: JsonNullValueInput | InputJsonValue
    reservation?: ReservationSeatsUncheckedUpdateManyWithoutCinemaSeatNestedInput
  }

  export type CinemaSeatCreateManyInput = {
    id?: string
    cinemaSeatGroupId: string
    seatRow: string
    seatColumn: string
    options?: JsonNullValueInput | InputJsonValue
  }

  export type CinemaSeatUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    seatRow?: StringFieldUpdateOperationsInput | string
    seatColumn?: StringFieldUpdateOperationsInput | string
    options?: JsonNullValueInput | InputJsonValue
  }

  export type CinemaSeatUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    cinemaSeatGroupId?: StringFieldUpdateOperationsInput | string
    seatRow?: StringFieldUpdateOperationsInput | string
    seatColumn?: StringFieldUpdateOperationsInput | string
    options?: JsonNullValueInput | InputJsonValue
  }

  export type MovieCreateInput = {
    id?: string
    title?: string | null
    originalTitle: string
    localizedTitle?: string | null
    plot: string
    localizedPlot?: string | null
    runtimeMinutes: number
    posterImages?: JsonNullValueInput | InputJsonValue
    videos?: JsonNullValueInput | InputJsonValue
    rating: number
    releaseDate: Date | string
    createdAt?: Date | string
    updatedAt: Date | string
    externalId: string
    externalType: $Enums.InputProvider
    additionalData?: JsonNullValueInput | InputJsonValue
    genres?: GenreCreateNestedManyWithoutMoviesInput
    originalLanguage: LanguageCreateNestedOneWithoutOriginalLanguageMoviesInput
    countryOfOrigin: CountryCreateNestedOneWithoutMoviesInput
    actors?: MovieActorCreateNestedManyWithoutMovieInput
    directors?: MovieDirectorCreateNestedManyWithoutMovieInput
    producers?: MovieProducerCreateNestedManyWithoutMovieInput
    movieCinemaOverrides?: MovieCinemaOverrideCreateNestedManyWithoutMovieInput
    movieProjections?: MovieProjectionCreateNestedManyWithoutMovieInput
  }

  export type MovieUncheckedCreateInput = {
    id?: string
    title?: string | null
    originalTitle: string
    localizedTitle?: string | null
    plot: string
    localizedPlot?: string | null
    runtimeMinutes: number
    originalLanguageId: string
    countryOfOriginId: string
    posterImages?: JsonNullValueInput | InputJsonValue
    videos?: JsonNullValueInput | InputJsonValue
    rating: number
    releaseDate: Date | string
    createdAt?: Date | string
    updatedAt: Date | string
    externalId: string
    externalType: $Enums.InputProvider
    additionalData?: JsonNullValueInput | InputJsonValue
    genres?: GenreUncheckedCreateNestedManyWithoutMoviesInput
    actors?: MovieActorUncheckedCreateNestedManyWithoutMovieInput
    directors?: MovieDirectorUncheckedCreateNestedManyWithoutMovieInput
    producers?: MovieProducerUncheckedCreateNestedManyWithoutMovieInput
    movieCinemaOverrides?: MovieCinemaOverrideUncheckedCreateNestedManyWithoutMovieInput
    movieProjections?: MovieProjectionUncheckedCreateNestedManyWithoutMovieInput
  }

  export type MovieUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    originalTitle?: StringFieldUpdateOperationsInput | string
    localizedTitle?: NullableStringFieldUpdateOperationsInput | string | null
    plot?: StringFieldUpdateOperationsInput | string
    localizedPlot?: NullableStringFieldUpdateOperationsInput | string | null
    runtimeMinutes?: IntFieldUpdateOperationsInput | number
    posterImages?: JsonNullValueInput | InputJsonValue
    videos?: JsonNullValueInput | InputJsonValue
    rating?: IntFieldUpdateOperationsInput | number
    releaseDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    externalId?: StringFieldUpdateOperationsInput | string
    externalType?: EnumInputProviderFieldUpdateOperationsInput | $Enums.InputProvider
    additionalData?: JsonNullValueInput | InputJsonValue
    genres?: GenreUpdateManyWithoutMoviesNestedInput
    originalLanguage?: LanguageUpdateOneRequiredWithoutOriginalLanguageMoviesNestedInput
    countryOfOrigin?: CountryUpdateOneRequiredWithoutMoviesNestedInput
    actors?: MovieActorUpdateManyWithoutMovieNestedInput
    directors?: MovieDirectorUpdateManyWithoutMovieNestedInput
    producers?: MovieProducerUpdateManyWithoutMovieNestedInput
    movieCinemaOverrides?: MovieCinemaOverrideUpdateManyWithoutMovieNestedInput
    movieProjections?: MovieProjectionUpdateManyWithoutMovieNestedInput
  }

  export type MovieUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    originalTitle?: StringFieldUpdateOperationsInput | string
    localizedTitle?: NullableStringFieldUpdateOperationsInput | string | null
    plot?: StringFieldUpdateOperationsInput | string
    localizedPlot?: NullableStringFieldUpdateOperationsInput | string | null
    runtimeMinutes?: IntFieldUpdateOperationsInput | number
    originalLanguageId?: StringFieldUpdateOperationsInput | string
    countryOfOriginId?: StringFieldUpdateOperationsInput | string
    posterImages?: JsonNullValueInput | InputJsonValue
    videos?: JsonNullValueInput | InputJsonValue
    rating?: IntFieldUpdateOperationsInput | number
    releaseDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    externalId?: StringFieldUpdateOperationsInput | string
    externalType?: EnumInputProviderFieldUpdateOperationsInput | $Enums.InputProvider
    additionalData?: JsonNullValueInput | InputJsonValue
    genres?: GenreUncheckedUpdateManyWithoutMoviesNestedInput
    actors?: MovieActorUncheckedUpdateManyWithoutMovieNestedInput
    directors?: MovieDirectorUncheckedUpdateManyWithoutMovieNestedInput
    producers?: MovieProducerUncheckedUpdateManyWithoutMovieNestedInput
    movieCinemaOverrides?: MovieCinemaOverrideUncheckedUpdateManyWithoutMovieNestedInput
    movieProjections?: MovieProjectionUncheckedUpdateManyWithoutMovieNestedInput
  }

  export type MovieCreateManyInput = {
    id?: string
    title?: string | null
    originalTitle: string
    localizedTitle?: string | null
    plot: string
    localizedPlot?: string | null
    runtimeMinutes: number
    originalLanguageId: string
    countryOfOriginId: string
    posterImages?: JsonNullValueInput | InputJsonValue
    videos?: JsonNullValueInput | InputJsonValue
    rating: number
    releaseDate: Date | string
    createdAt?: Date | string
    updatedAt: Date | string
    externalId: string
    externalType: $Enums.InputProvider
    additionalData?: JsonNullValueInput | InputJsonValue
  }

  export type MovieUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    originalTitle?: StringFieldUpdateOperationsInput | string
    localizedTitle?: NullableStringFieldUpdateOperationsInput | string | null
    plot?: StringFieldUpdateOperationsInput | string
    localizedPlot?: NullableStringFieldUpdateOperationsInput | string | null
    runtimeMinutes?: IntFieldUpdateOperationsInput | number
    posterImages?: JsonNullValueInput | InputJsonValue
    videos?: JsonNullValueInput | InputJsonValue
    rating?: IntFieldUpdateOperationsInput | number
    releaseDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    externalId?: StringFieldUpdateOperationsInput | string
    externalType?: EnumInputProviderFieldUpdateOperationsInput | $Enums.InputProvider
    additionalData?: JsonNullValueInput | InputJsonValue
  }

  export type MovieUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    originalTitle?: StringFieldUpdateOperationsInput | string
    localizedTitle?: NullableStringFieldUpdateOperationsInput | string | null
    plot?: StringFieldUpdateOperationsInput | string
    localizedPlot?: NullableStringFieldUpdateOperationsInput | string | null
    runtimeMinutes?: IntFieldUpdateOperationsInput | number
    originalLanguageId?: StringFieldUpdateOperationsInput | string
    countryOfOriginId?: StringFieldUpdateOperationsInput | string
    posterImages?: JsonNullValueInput | InputJsonValue
    videos?: JsonNullValueInput | InputJsonValue
    rating?: IntFieldUpdateOperationsInput | number
    releaseDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    externalId?: StringFieldUpdateOperationsInput | string
    externalType?: EnumInputProviderFieldUpdateOperationsInput | $Enums.InputProvider
    additionalData?: JsonNullValueInput | InputJsonValue
  }

  export type PersonCreateInput = {
    id?: string
    name: string
    biography?: string
    dateOfBirth?: Date | string | null
    dateOfDeath?: Date | string | null
    gender: $Enums.Gender
    createdAt?: Date | string
    updatedAt: Date | string
    externalId: string
    externalType: $Enums.InputProvider
    additionalData?: JsonNullValueInput | InputJsonValue
    actorInMovies?: MovieActorCreateNestedManyWithoutPersonInput
    directorInMovies?: MovieDirectorCreateNestedManyWithoutPersonInput
    producerInMovies?: MovieProducerCreateNestedManyWithoutPersonInput
  }

  export type PersonUncheckedCreateInput = {
    id?: string
    name: string
    biography?: string
    dateOfBirth?: Date | string | null
    dateOfDeath?: Date | string | null
    gender: $Enums.Gender
    createdAt?: Date | string
    updatedAt: Date | string
    externalId: string
    externalType: $Enums.InputProvider
    additionalData?: JsonNullValueInput | InputJsonValue
    actorInMovies?: MovieActorUncheckedCreateNestedManyWithoutPersonInput
    directorInMovies?: MovieDirectorUncheckedCreateNestedManyWithoutPersonInput
    producerInMovies?: MovieProducerUncheckedCreateNestedManyWithoutPersonInput
  }

  export type PersonUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    biography?: StringFieldUpdateOperationsInput | string
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dateOfDeath?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    externalId?: StringFieldUpdateOperationsInput | string
    externalType?: EnumInputProviderFieldUpdateOperationsInput | $Enums.InputProvider
    additionalData?: JsonNullValueInput | InputJsonValue
    actorInMovies?: MovieActorUpdateManyWithoutPersonNestedInput
    directorInMovies?: MovieDirectorUpdateManyWithoutPersonNestedInput
    producerInMovies?: MovieProducerUpdateManyWithoutPersonNestedInput
  }

  export type PersonUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    biography?: StringFieldUpdateOperationsInput | string
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dateOfDeath?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    externalId?: StringFieldUpdateOperationsInput | string
    externalType?: EnumInputProviderFieldUpdateOperationsInput | $Enums.InputProvider
    additionalData?: JsonNullValueInput | InputJsonValue
    actorInMovies?: MovieActorUncheckedUpdateManyWithoutPersonNestedInput
    directorInMovies?: MovieDirectorUncheckedUpdateManyWithoutPersonNestedInput
    producerInMovies?: MovieProducerUncheckedUpdateManyWithoutPersonNestedInput
  }

  export type PersonCreateManyInput = {
    id?: string
    name: string
    biography?: string
    dateOfBirth?: Date | string | null
    dateOfDeath?: Date | string | null
    gender: $Enums.Gender
    createdAt?: Date | string
    updatedAt: Date | string
    externalId: string
    externalType: $Enums.InputProvider
    additionalData?: JsonNullValueInput | InputJsonValue
  }

  export type PersonUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    biography?: StringFieldUpdateOperationsInput | string
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dateOfDeath?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    externalId?: StringFieldUpdateOperationsInput | string
    externalType?: EnumInputProviderFieldUpdateOperationsInput | $Enums.InputProvider
    additionalData?: JsonNullValueInput | InputJsonValue
  }

  export type PersonUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    biography?: StringFieldUpdateOperationsInput | string
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dateOfDeath?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    externalId?: StringFieldUpdateOperationsInput | string
    externalType?: EnumInputProviderFieldUpdateOperationsInput | $Enums.InputProvider
    additionalData?: JsonNullValueInput | InputJsonValue
  }

  export type MovieActorCreateInput = {
    characterName: string
    castOrder: number
    person: PersonCreateNestedOneWithoutActorInMoviesInput
    movie: MovieCreateNestedOneWithoutActorsInput
  }

  export type MovieActorUncheckedCreateInput = {
    personId: string
    movieId: string
    characterName: string
    castOrder: number
  }

  export type MovieActorUpdateInput = {
    characterName?: StringFieldUpdateOperationsInput | string
    castOrder?: IntFieldUpdateOperationsInput | number
    person?: PersonUpdateOneRequiredWithoutActorInMoviesNestedInput
    movie?: MovieUpdateOneRequiredWithoutActorsNestedInput
  }

  export type MovieActorUncheckedUpdateInput = {
    personId?: StringFieldUpdateOperationsInput | string
    movieId?: StringFieldUpdateOperationsInput | string
    characterName?: StringFieldUpdateOperationsInput | string
    castOrder?: IntFieldUpdateOperationsInput | number
  }

  export type MovieActorCreateManyInput = {
    personId: string
    movieId: string
    characterName: string
    castOrder: number
  }

  export type MovieActorUpdateManyMutationInput = {
    characterName?: StringFieldUpdateOperationsInput | string
    castOrder?: IntFieldUpdateOperationsInput | number
  }

  export type MovieActorUncheckedUpdateManyInput = {
    personId?: StringFieldUpdateOperationsInput | string
    movieId?: StringFieldUpdateOperationsInput | string
    characterName?: StringFieldUpdateOperationsInput | string
    castOrder?: IntFieldUpdateOperationsInput | number
  }

  export type MovieDirectorCreateInput = {
    type: $Enums.DirectorType
    person: PersonCreateNestedOneWithoutDirectorInMoviesInput
    movie: MovieCreateNestedOneWithoutDirectorsInput
  }

  export type MovieDirectorUncheckedCreateInput = {
    personId: string
    movieId: string
    type: $Enums.DirectorType
  }

  export type MovieDirectorUpdateInput = {
    type?: EnumDirectorTypeFieldUpdateOperationsInput | $Enums.DirectorType
    person?: PersonUpdateOneRequiredWithoutDirectorInMoviesNestedInput
    movie?: MovieUpdateOneRequiredWithoutDirectorsNestedInput
  }

  export type MovieDirectorUncheckedUpdateInput = {
    personId?: StringFieldUpdateOperationsInput | string
    movieId?: StringFieldUpdateOperationsInput | string
    type?: EnumDirectorTypeFieldUpdateOperationsInput | $Enums.DirectorType
  }

  export type MovieDirectorCreateManyInput = {
    personId: string
    movieId: string
    type: $Enums.DirectorType
  }

  export type MovieDirectorUpdateManyMutationInput = {
    type?: EnumDirectorTypeFieldUpdateOperationsInput | $Enums.DirectorType
  }

  export type MovieDirectorUncheckedUpdateManyInput = {
    personId?: StringFieldUpdateOperationsInput | string
    movieId?: StringFieldUpdateOperationsInput | string
    type?: EnumDirectorTypeFieldUpdateOperationsInput | $Enums.DirectorType
  }

  export type MovieProducerCreateInput = {
    type: $Enums.ProducerType
    person: PersonCreateNestedOneWithoutProducerInMoviesInput
    movie: MovieCreateNestedOneWithoutProducersInput
  }

  export type MovieProducerUncheckedCreateInput = {
    personId: string
    movieId: string
    type: $Enums.ProducerType
  }

  export type MovieProducerUpdateInput = {
    type?: EnumProducerTypeFieldUpdateOperationsInput | $Enums.ProducerType
    person?: PersonUpdateOneRequiredWithoutProducerInMoviesNestedInput
    movie?: MovieUpdateOneRequiredWithoutProducersNestedInput
  }

  export type MovieProducerUncheckedUpdateInput = {
    personId?: StringFieldUpdateOperationsInput | string
    movieId?: StringFieldUpdateOperationsInput | string
    type?: EnumProducerTypeFieldUpdateOperationsInput | $Enums.ProducerType
  }

  export type MovieProducerCreateManyInput = {
    personId: string
    movieId: string
    type: $Enums.ProducerType
  }

  export type MovieProducerUpdateManyMutationInput = {
    type?: EnumProducerTypeFieldUpdateOperationsInput | $Enums.ProducerType
  }

  export type MovieProducerUncheckedUpdateManyInput = {
    personId?: StringFieldUpdateOperationsInput | string
    movieId?: StringFieldUpdateOperationsInput | string
    type?: EnumProducerTypeFieldUpdateOperationsInput | $Enums.ProducerType
  }

  export type MovieCinemaOverrideCreateInput = {
    movieDataOverrides?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt: Date | string
    movie: MovieCreateNestedOneWithoutMovieCinemaOverridesInput
    cinema: CinemaCreateNestedOneWithoutMovieCinemaOverridesInput
  }

  export type MovieCinemaOverrideUncheckedCreateInput = {
    movieId: string
    cinemaId: string
    movieDataOverrides?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type MovieCinemaOverrideUpdateInput = {
    movieDataOverrides?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    movie?: MovieUpdateOneRequiredWithoutMovieCinemaOverridesNestedInput
    cinema?: CinemaUpdateOneRequiredWithoutMovieCinemaOverridesNestedInput
  }

  export type MovieCinemaOverrideUncheckedUpdateInput = {
    movieId?: StringFieldUpdateOperationsInput | string
    cinemaId?: StringFieldUpdateOperationsInput | string
    movieDataOverrides?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MovieCinemaOverrideCreateManyInput = {
    movieId: string
    cinemaId: string
    movieDataOverrides?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type MovieCinemaOverrideUpdateManyMutationInput = {
    movieDataOverrides?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MovieCinemaOverrideUncheckedUpdateManyInput = {
    movieId?: StringFieldUpdateOperationsInput | string
    cinemaId?: StringFieldUpdateOperationsInput | string
    movieDataOverrides?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MovieProjectionCreateInput = {
    id?: string
    projectionDateTime: Date | string
    createdAt?: Date | string
    updatedAt: Date | string
    options?: JsonNullValueInput | InputJsonValue
    movie: MovieCreateNestedOneWithoutMovieProjectionsInput
    cinemaTheater: CinemaTheaterCreateNestedOneWithoutMovieProjectionsInput
    dubbedLanguage?: LanguageCreateNestedOneWithoutDubbedLanguageMovieProjectionsInput
    projectionPrices?: ProjectionPriceCreateNestedManyWithoutMovieProjectionInput
    reservations?: ReservationCreateNestedManyWithoutMovieProjectionInput
  }

  export type MovieProjectionUncheckedCreateInput = {
    id?: string
    movieId: string
    cinemaTheaterId: string
    projectionDateTime: Date | string
    createdAt?: Date | string
    updatedAt: Date | string
    dubbedLanguageId?: string | null
    options?: JsonNullValueInput | InputJsonValue
    projectionPrices?: ProjectionPriceUncheckedCreateNestedManyWithoutMovieProjectionInput
    reservations?: ReservationUncheckedCreateNestedManyWithoutMovieProjectionInput
  }

  export type MovieProjectionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectionDateTime?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    options?: JsonNullValueInput | InputJsonValue
    movie?: MovieUpdateOneRequiredWithoutMovieProjectionsNestedInput
    cinemaTheater?: CinemaTheaterUpdateOneRequiredWithoutMovieProjectionsNestedInput
    dubbedLanguage?: LanguageUpdateOneWithoutDubbedLanguageMovieProjectionsNestedInput
    projectionPrices?: ProjectionPriceUpdateManyWithoutMovieProjectionNestedInput
    reservations?: ReservationUpdateManyWithoutMovieProjectionNestedInput
  }

  export type MovieProjectionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    movieId?: StringFieldUpdateOperationsInput | string
    cinemaTheaterId?: StringFieldUpdateOperationsInput | string
    projectionDateTime?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dubbedLanguageId?: NullableStringFieldUpdateOperationsInput | string | null
    options?: JsonNullValueInput | InputJsonValue
    projectionPrices?: ProjectionPriceUncheckedUpdateManyWithoutMovieProjectionNestedInput
    reservations?: ReservationUncheckedUpdateManyWithoutMovieProjectionNestedInput
  }

  export type MovieProjectionCreateManyInput = {
    id?: string
    movieId: string
    cinemaTheaterId: string
    projectionDateTime: Date | string
    createdAt?: Date | string
    updatedAt: Date | string
    dubbedLanguageId?: string | null
    options?: JsonNullValueInput | InputJsonValue
  }

  export type MovieProjectionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectionDateTime?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    options?: JsonNullValueInput | InputJsonValue
  }

  export type MovieProjectionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    movieId?: StringFieldUpdateOperationsInput | string
    cinemaTheaterId?: StringFieldUpdateOperationsInput | string
    projectionDateTime?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dubbedLanguageId?: NullableStringFieldUpdateOperationsInput | string | null
    options?: JsonNullValueInput | InputJsonValue
  }

  export type ProjectionPriceCreateInput = {
    type?: $Enums.PriceType
    price: Decimal | DecimalJsLike | number | string
    currencyCode: $Enums.CurrencyCode
    cinemaSeatGroup: CinemaSeatGroupCreateNestedOneWithoutProjectionPricesInput
    movieProjection: MovieProjectionCreateNestedOneWithoutProjectionPricesInput
  }

  export type ProjectionPriceUncheckedCreateInput = {
    projectionId: string
    groupId: string
    type?: $Enums.PriceType
    price: Decimal | DecimalJsLike | number | string
    currencyCode: $Enums.CurrencyCode
  }

  export type ProjectionPriceUpdateInput = {
    type?: EnumPriceTypeFieldUpdateOperationsInput | $Enums.PriceType
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currencyCode?: EnumCurrencyCodeFieldUpdateOperationsInput | $Enums.CurrencyCode
    cinemaSeatGroup?: CinemaSeatGroupUpdateOneRequiredWithoutProjectionPricesNestedInput
    movieProjection?: MovieProjectionUpdateOneRequiredWithoutProjectionPricesNestedInput
  }

  export type ProjectionPriceUncheckedUpdateInput = {
    projectionId?: StringFieldUpdateOperationsInput | string
    groupId?: StringFieldUpdateOperationsInput | string
    type?: EnumPriceTypeFieldUpdateOperationsInput | $Enums.PriceType
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currencyCode?: EnumCurrencyCodeFieldUpdateOperationsInput | $Enums.CurrencyCode
  }

  export type ProjectionPriceCreateManyInput = {
    projectionId: string
    groupId: string
    type?: $Enums.PriceType
    price: Decimal | DecimalJsLike | number | string
    currencyCode: $Enums.CurrencyCode
  }

  export type ProjectionPriceUpdateManyMutationInput = {
    type?: EnumPriceTypeFieldUpdateOperationsInput | $Enums.PriceType
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currencyCode?: EnumCurrencyCodeFieldUpdateOperationsInput | $Enums.CurrencyCode
  }

  export type ProjectionPriceUncheckedUpdateManyInput = {
    projectionId?: StringFieldUpdateOperationsInput | string
    groupId?: StringFieldUpdateOperationsInput | string
    type?: EnumPriceTypeFieldUpdateOperationsInput | $Enums.PriceType
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currencyCode?: EnumCurrencyCodeFieldUpdateOperationsInput | $Enums.CurrencyCode
  }

  export type AdminUserCreateInput = {
    id?: string
    email: string
    password: string
    fullName: string
    role: $Enums.AdminRole
    cinemaIds?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt: Date | string
    ValidatedReservationSeats?: ReservationSeatsCreateNestedManyWithoutValidatedByAdminUserInput
  }

  export type AdminUserUncheckedCreateInput = {
    id?: string
    email: string
    password: string
    fullName: string
    role: $Enums.AdminRole
    cinemaIds?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt: Date | string
    ValidatedReservationSeats?: ReservationSeatsUncheckedCreateNestedManyWithoutValidatedByAdminUserInput
  }

  export type AdminUserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    role?: EnumAdminRoleFieldUpdateOperationsInput | $Enums.AdminRole
    cinemaIds?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ValidatedReservationSeats?: ReservationSeatsUpdateManyWithoutValidatedByAdminUserNestedInput
  }

  export type AdminUserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    role?: EnumAdminRoleFieldUpdateOperationsInput | $Enums.AdminRole
    cinemaIds?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ValidatedReservationSeats?: ReservationSeatsUncheckedUpdateManyWithoutValidatedByAdminUserNestedInput
  }

  export type AdminUserCreateManyInput = {
    id?: string
    email: string
    password: string
    fullName: string
    role: $Enums.AdminRole
    cinemaIds?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type AdminUserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    role?: EnumAdminRoleFieldUpdateOperationsInput | $Enums.AdminRole
    cinemaIds?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdminUserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    role?: EnumAdminRoleFieldUpdateOperationsInput | $Enums.AdminRole
    cinemaIds?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReservationCreateInput = {
    id?: string
    customerInformation?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt: Date | string
    options?: JsonNullValueInput | InputJsonValue
    deletedAt?: Date | string | null
    movieProjection: MovieProjectionCreateNestedOneWithoutReservationsInput
    reservationSeats?: ReservationSeatsCreateNestedManyWithoutReservationInput
  }

  export type ReservationUncheckedCreateInput = {
    id?: string
    eventId: string
    customerInformation?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt: Date | string
    options?: JsonNullValueInput | InputJsonValue
    deletedAt?: Date | string | null
    reservationSeats?: ReservationSeatsUncheckedCreateNestedManyWithoutReservationInput
  }

  export type ReservationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    customerInformation?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    options?: JsonNullValueInput | InputJsonValue
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    movieProjection?: MovieProjectionUpdateOneRequiredWithoutReservationsNestedInput
    reservationSeats?: ReservationSeatsUpdateManyWithoutReservationNestedInput
  }

  export type ReservationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    eventId?: StringFieldUpdateOperationsInput | string
    customerInformation?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    options?: JsonNullValueInput | InputJsonValue
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reservationSeats?: ReservationSeatsUncheckedUpdateManyWithoutReservationNestedInput
  }

  export type ReservationCreateManyInput = {
    id?: string
    eventId: string
    customerInformation?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt: Date | string
    options?: JsonNullValueInput | InputJsonValue
    deletedAt?: Date | string | null
  }

  export type ReservationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    customerInformation?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    options?: JsonNullValueInput | InputJsonValue
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ReservationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    eventId?: StringFieldUpdateOperationsInput | string
    customerInformation?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    options?: JsonNullValueInput | InputJsonValue
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ReservationSeatsCreateInput = {
    id?: string
    eventId: string
    options?: JsonNullValueInput | InputJsonValue
    deletedAt?: Date | string | null
    validatedAt?: Date | string | null
    reservation: ReservationCreateNestedOneWithoutReservationSeatsInput
    cinemaSeat: CinemaSeatCreateNestedOneWithoutReservationInput
    validatedByAdminUser?: AdminUserCreateNestedOneWithoutValidatedReservationSeatsInput
  }

  export type ReservationSeatsUncheckedCreateInput = {
    id?: string
    reservationId: string
    eventId: string
    seatId: string
    options?: JsonNullValueInput | InputJsonValue
    deletedAt?: Date | string | null
    validatedAt?: Date | string | null
    validatedByAdminUserId?: string | null
  }

  export type ReservationSeatsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    eventId?: StringFieldUpdateOperationsInput | string
    options?: JsonNullValueInput | InputJsonValue
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    validatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reservation?: ReservationUpdateOneRequiredWithoutReservationSeatsNestedInput
    cinemaSeat?: CinemaSeatUpdateOneRequiredWithoutReservationNestedInput
    validatedByAdminUser?: AdminUserUpdateOneWithoutValidatedReservationSeatsNestedInput
  }

  export type ReservationSeatsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    reservationId?: StringFieldUpdateOperationsInput | string
    eventId?: StringFieldUpdateOperationsInput | string
    seatId?: StringFieldUpdateOperationsInput | string
    options?: JsonNullValueInput | InputJsonValue
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    validatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    validatedByAdminUserId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ReservationSeatsCreateManyInput = {
    id?: string
    reservationId: string
    eventId: string
    seatId: string
    options?: JsonNullValueInput | InputJsonValue
    deletedAt?: Date | string | null
    validatedAt?: Date | string | null
    validatedByAdminUserId?: string | null
  }

  export type ReservationSeatsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    eventId?: StringFieldUpdateOperationsInput | string
    options?: JsonNullValueInput | InputJsonValue
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    validatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ReservationSeatsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    reservationId?: StringFieldUpdateOperationsInput | string
    eventId?: StringFieldUpdateOperationsInput | string
    seatId?: StringFieldUpdateOperationsInput | string
    options?: JsonNullValueInput | InputJsonValue
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    validatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    validatedByAdminUserId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type MovieListRelationFilter = {
    every?: MovieWhereInput
    some?: MovieWhereInput
    none?: MovieWhereInput
  }

  export type MovieOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type GenreCountOrderByAggregateInput = {
    systemName?: SortOrder
    localizedName?: SortOrder
  }

  export type GenreMaxOrderByAggregateInput = {
    systemName?: SortOrder
    localizedName?: SortOrder
  }

  export type GenreMinOrderByAggregateInput = {
    systemName?: SortOrder
    localizedName?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type MovieProjectionListRelationFilter = {
    every?: MovieProjectionWhereInput
    some?: MovieProjectionWhereInput
    none?: MovieProjectionWhereInput
  }

  export type MovieProjectionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type LanguageCountOrderByAggregateInput = {
    code?: SortOrder
    name?: SortOrder
  }

  export type LanguageMaxOrderByAggregateInput = {
    code?: SortOrder
    name?: SortOrder
  }

  export type LanguageMinOrderByAggregateInput = {
    code?: SortOrder
    name?: SortOrder
  }

  export type CityListRelationFilter = {
    every?: CityWhereInput
    some?: CityWhereInput
    none?: CityWhereInput
  }

  export type CityOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CountryCountOrderByAggregateInput = {
    code?: SortOrder
    name?: SortOrder
  }

  export type CountryMaxOrderByAggregateInput = {
    code?: SortOrder
    name?: SortOrder
  }

  export type CountryMinOrderByAggregateInput = {
    code?: SortOrder
    name?: SortOrder
  }

  export type UuidFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedUuidFilter<$PrismaModel> | string
  }

  export type CountryRelationFilter = {
    is?: CountryWhereInput
    isNot?: CountryWhereInput
  }

  export type CinemaListRelationFilter = {
    every?: CinemaWhereInput
    some?: CinemaWhereInput
    none?: CinemaWhereInput
  }

  export type CinemaOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CityCityCodeCountryCodeCompoundUniqueInput = {
    cityCode: string
    countryCode: string
  }

  export type CityCountOrderByAggregateInput = {
    id?: SortOrder
    cityCode?: SortOrder
    name?: SortOrder
    postalCode?: SortOrder
    countryCode?: SortOrder
  }

  export type CityMaxOrderByAggregateInput = {
    id?: SortOrder
    cityCode?: SortOrder
    name?: SortOrder
    postalCode?: SortOrder
    countryCode?: SortOrder
  }

  export type CityMinOrderByAggregateInput = {
    id?: SortOrder
    cityCode?: SortOrder
    name?: SortOrder
    postalCode?: SortOrder
    countryCode?: SortOrder
  }

  export type UuidWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedUuidWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }
  export type JsonFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonFilterBase<$PrismaModel>>, 'path'>>

  export type JsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type DecimalNullableFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
  }

  export type CityRelationFilter = {
    is?: CityWhereInput
    isNot?: CityWhereInput
  }

  export type CinemaTheaterListRelationFilter = {
    every?: CinemaTheaterWhereInput
    some?: CinemaTheaterWhereInput
    none?: CinemaTheaterWhereInput
  }

  export type MovieCinemaOverrideListRelationFilter = {
    every?: MovieCinemaOverrideWhereInput
    some?: MovieCinemaOverrideWhereInput
    none?: MovieCinemaOverrideWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type CinemaTheaterOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MovieCinemaOverrideOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CinemaCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    cityId?: SortOrder
    address?: SortOrder
    rating?: SortOrder
    phone?: SortOrder
    posterImages?: SortOrder
    geoLatitude?: SortOrder
    geoLongitude?: SortOrder
  }

  export type CinemaAvgOrderByAggregateInput = {
    rating?: SortOrder
    geoLatitude?: SortOrder
    geoLongitude?: SortOrder
  }

  export type CinemaMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    cityId?: SortOrder
    address?: SortOrder
    rating?: SortOrder
    geoLatitude?: SortOrder
    geoLongitude?: SortOrder
  }

  export type CinemaMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    cityId?: SortOrder
    address?: SortOrder
    rating?: SortOrder
    geoLatitude?: SortOrder
    geoLongitude?: SortOrder
  }

  export type CinemaSumOrderByAggregateInput = {
    rating?: SortOrder
    geoLatitude?: SortOrder
    geoLongitude?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }
  export type JsonWithAggregatesFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedJsonFilter<$PrismaModel>
    _max?: NestedJsonFilter<$PrismaModel>
  }

  export type DecimalNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedDecimalNullableFilter<$PrismaModel>
    _sum?: NestedDecimalNullableFilter<$PrismaModel>
    _min?: NestedDecimalNullableFilter<$PrismaModel>
    _max?: NestedDecimalNullableFilter<$PrismaModel>
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type CinemaRelationFilter = {
    is?: CinemaWhereInput
    isNot?: CinemaWhereInput
  }

  export type CinemaSeatGroupListRelationFilter = {
    every?: CinemaSeatGroupWhereInput
    some?: CinemaSeatGroupWhereInput
    none?: CinemaSeatGroupWhereInput
  }

  export type CinemaSeatGroupOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CinemaTheaterCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    cinemaId?: SortOrder
    supports3D?: SortOrder
    posterImages?: SortOrder
  }

  export type CinemaTheaterMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    cinemaId?: SortOrder
    supports3D?: SortOrder
  }

  export type CinemaTheaterMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    cinemaId?: SortOrder
    supports3D?: SortOrder
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type EnumCinemaSeatGroupPositionEnumFilter<$PrismaModel = never> = {
    equals?: $Enums.CinemaSeatGroupPositionEnum | EnumCinemaSeatGroupPositionEnumFieldRefInput<$PrismaModel>
    in?: $Enums.CinemaSeatGroupPositionEnum[] | ListEnumCinemaSeatGroupPositionEnumFieldRefInput<$PrismaModel>
    notIn?: $Enums.CinemaSeatGroupPositionEnum[] | ListEnumCinemaSeatGroupPositionEnumFieldRefInput<$PrismaModel>
    not?: NestedEnumCinemaSeatGroupPositionEnumFilter<$PrismaModel> | $Enums.CinemaSeatGroupPositionEnum
  }

  export type CinemaTheaterRelationFilter = {
    is?: CinemaTheaterWhereInput
    isNot?: CinemaTheaterWhereInput
  }

  export type CinemaSeatListRelationFilter = {
    every?: CinemaSeatWhereInput
    some?: CinemaSeatWhereInput
    none?: CinemaSeatWhereInput
  }

  export type ProjectionPriceListRelationFilter = {
    every?: ProjectionPriceWhereInput
    some?: ProjectionPriceWhereInput
    none?: ProjectionPriceWhereInput
  }

  export type CinemaSeatOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProjectionPriceOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CinemaSeatGroupPositionCinemaTheaterIdCompoundUniqueInput = {
    position: $Enums.CinemaSeatGroupPositionEnum
    cinemaTheaterId: string
  }

  export type CinemaSeatGroupCountOrderByAggregateInput = {
    id?: SortOrder
    cinemaTheaterId?: SortOrder
    name?: SortOrder
    rowCount?: SortOrder
    columnCount?: SortOrder
    position?: SortOrder
    options?: SortOrder
  }

  export type CinemaSeatGroupAvgOrderByAggregateInput = {
    rowCount?: SortOrder
    columnCount?: SortOrder
  }

  export type CinemaSeatGroupMaxOrderByAggregateInput = {
    id?: SortOrder
    cinemaTheaterId?: SortOrder
    name?: SortOrder
    rowCount?: SortOrder
    columnCount?: SortOrder
    position?: SortOrder
  }

  export type CinemaSeatGroupMinOrderByAggregateInput = {
    id?: SortOrder
    cinemaTheaterId?: SortOrder
    name?: SortOrder
    rowCount?: SortOrder
    columnCount?: SortOrder
    position?: SortOrder
  }

  export type CinemaSeatGroupSumOrderByAggregateInput = {
    rowCount?: SortOrder
    columnCount?: SortOrder
  }

  export type EnumCinemaSeatGroupPositionEnumWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CinemaSeatGroupPositionEnum | EnumCinemaSeatGroupPositionEnumFieldRefInput<$PrismaModel>
    in?: $Enums.CinemaSeatGroupPositionEnum[] | ListEnumCinemaSeatGroupPositionEnumFieldRefInput<$PrismaModel>
    notIn?: $Enums.CinemaSeatGroupPositionEnum[] | ListEnumCinemaSeatGroupPositionEnumFieldRefInput<$PrismaModel>
    not?: NestedEnumCinemaSeatGroupPositionEnumWithAggregatesFilter<$PrismaModel> | $Enums.CinemaSeatGroupPositionEnum
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCinemaSeatGroupPositionEnumFilter<$PrismaModel>
    _max?: NestedEnumCinemaSeatGroupPositionEnumFilter<$PrismaModel>
  }

  export type CinemaSeatGroupRelationFilter = {
    is?: CinemaSeatGroupWhereInput
    isNot?: CinemaSeatGroupWhereInput
  }

  export type ReservationSeatsListRelationFilter = {
    every?: ReservationSeatsWhereInput
    some?: ReservationSeatsWhereInput
    none?: ReservationSeatsWhereInput
  }

  export type ReservationSeatsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CinemaSeatCountOrderByAggregateInput = {
    id?: SortOrder
    cinemaSeatGroupId?: SortOrder
    seatRow?: SortOrder
    seatColumn?: SortOrder
    options?: SortOrder
  }

  export type CinemaSeatMaxOrderByAggregateInput = {
    id?: SortOrder
    cinemaSeatGroupId?: SortOrder
    seatRow?: SortOrder
    seatColumn?: SortOrder
  }

  export type CinemaSeatMinOrderByAggregateInput = {
    id?: SortOrder
    cinemaSeatGroupId?: SortOrder
    seatRow?: SortOrder
    seatColumn?: SortOrder
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type EnumInputProviderFilter<$PrismaModel = never> = {
    equals?: $Enums.InputProvider | EnumInputProviderFieldRefInput<$PrismaModel>
    in?: $Enums.InputProvider[] | ListEnumInputProviderFieldRefInput<$PrismaModel>
    notIn?: $Enums.InputProvider[] | ListEnumInputProviderFieldRefInput<$PrismaModel>
    not?: NestedEnumInputProviderFilter<$PrismaModel> | $Enums.InputProvider
  }

  export type GenreListRelationFilter = {
    every?: GenreWhereInput
    some?: GenreWhereInput
    none?: GenreWhereInput
  }

  export type LanguageRelationFilter = {
    is?: LanguageWhereInput
    isNot?: LanguageWhereInput
  }

  export type MovieActorListRelationFilter = {
    every?: MovieActorWhereInput
    some?: MovieActorWhereInput
    none?: MovieActorWhereInput
  }

  export type MovieDirectorListRelationFilter = {
    every?: MovieDirectorWhereInput
    some?: MovieDirectorWhereInput
    none?: MovieDirectorWhereInput
  }

  export type MovieProducerListRelationFilter = {
    every?: MovieProducerWhereInput
    some?: MovieProducerWhereInput
    none?: MovieProducerWhereInput
  }

  export type GenreOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MovieActorOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MovieDirectorOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MovieProducerOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MovieExternalIdExternalTypeCompoundUniqueInput = {
    externalId: string
    externalType: $Enums.InputProvider
  }

  export type MovieCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    originalTitle?: SortOrder
    localizedTitle?: SortOrder
    plot?: SortOrder
    localizedPlot?: SortOrder
    runtimeMinutes?: SortOrder
    originalLanguageId?: SortOrder
    countryOfOriginId?: SortOrder
    posterImages?: SortOrder
    videos?: SortOrder
    rating?: SortOrder
    releaseDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    externalId?: SortOrder
    externalType?: SortOrder
    additionalData?: SortOrder
  }

  export type MovieAvgOrderByAggregateInput = {
    runtimeMinutes?: SortOrder
    rating?: SortOrder
  }

  export type MovieMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    originalTitle?: SortOrder
    localizedTitle?: SortOrder
    plot?: SortOrder
    localizedPlot?: SortOrder
    runtimeMinutes?: SortOrder
    originalLanguageId?: SortOrder
    countryOfOriginId?: SortOrder
    rating?: SortOrder
    releaseDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    externalId?: SortOrder
    externalType?: SortOrder
  }

  export type MovieMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    originalTitle?: SortOrder
    localizedTitle?: SortOrder
    plot?: SortOrder
    localizedPlot?: SortOrder
    runtimeMinutes?: SortOrder
    originalLanguageId?: SortOrder
    countryOfOriginId?: SortOrder
    rating?: SortOrder
    releaseDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    externalId?: SortOrder
    externalType?: SortOrder
  }

  export type MovieSumOrderByAggregateInput = {
    runtimeMinutes?: SortOrder
    rating?: SortOrder
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type EnumInputProviderWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.InputProvider | EnumInputProviderFieldRefInput<$PrismaModel>
    in?: $Enums.InputProvider[] | ListEnumInputProviderFieldRefInput<$PrismaModel>
    notIn?: $Enums.InputProvider[] | ListEnumInputProviderFieldRefInput<$PrismaModel>
    not?: NestedEnumInputProviderWithAggregatesFilter<$PrismaModel> | $Enums.InputProvider
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumInputProviderFilter<$PrismaModel>
    _max?: NestedEnumInputProviderFilter<$PrismaModel>
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type EnumGenderFilter<$PrismaModel = never> = {
    equals?: $Enums.Gender | EnumGenderFieldRefInput<$PrismaModel>
    in?: $Enums.Gender[] | ListEnumGenderFieldRefInput<$PrismaModel>
    notIn?: $Enums.Gender[] | ListEnumGenderFieldRefInput<$PrismaModel>
    not?: NestedEnumGenderFilter<$PrismaModel> | $Enums.Gender
  }

  export type PersonExternalIdExternalTypeCompoundUniqueInput = {
    externalId: string
    externalType: $Enums.InputProvider
  }

  export type PersonCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    biography?: SortOrder
    dateOfBirth?: SortOrder
    dateOfDeath?: SortOrder
    gender?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    externalId?: SortOrder
    externalType?: SortOrder
    additionalData?: SortOrder
  }

  export type PersonMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    biography?: SortOrder
    dateOfBirth?: SortOrder
    dateOfDeath?: SortOrder
    gender?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    externalId?: SortOrder
    externalType?: SortOrder
  }

  export type PersonMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    biography?: SortOrder
    dateOfBirth?: SortOrder
    dateOfDeath?: SortOrder
    gender?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    externalId?: SortOrder
    externalType?: SortOrder
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type EnumGenderWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Gender | EnumGenderFieldRefInput<$PrismaModel>
    in?: $Enums.Gender[] | ListEnumGenderFieldRefInput<$PrismaModel>
    notIn?: $Enums.Gender[] | ListEnumGenderFieldRefInput<$PrismaModel>
    not?: NestedEnumGenderWithAggregatesFilter<$PrismaModel> | $Enums.Gender
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumGenderFilter<$PrismaModel>
    _max?: NestedEnumGenderFilter<$PrismaModel>
  }

  export type PersonRelationFilter = {
    is?: PersonWhereInput
    isNot?: PersonWhereInput
  }

  export type MovieRelationFilter = {
    is?: MovieWhereInput
    isNot?: MovieWhereInput
  }

  export type MovieActorPersonIdMovieIdCompoundUniqueInput = {
    personId: string
    movieId: string
  }

  export type MovieActorCountOrderByAggregateInput = {
    personId?: SortOrder
    movieId?: SortOrder
    characterName?: SortOrder
    castOrder?: SortOrder
  }

  export type MovieActorAvgOrderByAggregateInput = {
    castOrder?: SortOrder
  }

  export type MovieActorMaxOrderByAggregateInput = {
    personId?: SortOrder
    movieId?: SortOrder
    characterName?: SortOrder
    castOrder?: SortOrder
  }

  export type MovieActorMinOrderByAggregateInput = {
    personId?: SortOrder
    movieId?: SortOrder
    characterName?: SortOrder
    castOrder?: SortOrder
  }

  export type MovieActorSumOrderByAggregateInput = {
    castOrder?: SortOrder
  }

  export type EnumDirectorTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.DirectorType | EnumDirectorTypeFieldRefInput<$PrismaModel>
    in?: $Enums.DirectorType[] | ListEnumDirectorTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.DirectorType[] | ListEnumDirectorTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumDirectorTypeFilter<$PrismaModel> | $Enums.DirectorType
  }

  export type MovieDirectorPersonIdMovieIdCompoundUniqueInput = {
    personId: string
    movieId: string
  }

  export type MovieDirectorCountOrderByAggregateInput = {
    personId?: SortOrder
    movieId?: SortOrder
    type?: SortOrder
  }

  export type MovieDirectorMaxOrderByAggregateInput = {
    personId?: SortOrder
    movieId?: SortOrder
    type?: SortOrder
  }

  export type MovieDirectorMinOrderByAggregateInput = {
    personId?: SortOrder
    movieId?: SortOrder
    type?: SortOrder
  }

  export type EnumDirectorTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.DirectorType | EnumDirectorTypeFieldRefInput<$PrismaModel>
    in?: $Enums.DirectorType[] | ListEnumDirectorTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.DirectorType[] | ListEnumDirectorTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumDirectorTypeWithAggregatesFilter<$PrismaModel> | $Enums.DirectorType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumDirectorTypeFilter<$PrismaModel>
    _max?: NestedEnumDirectorTypeFilter<$PrismaModel>
  }

  export type EnumProducerTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ProducerType | EnumProducerTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ProducerType[] | ListEnumProducerTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ProducerType[] | ListEnumProducerTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumProducerTypeFilter<$PrismaModel> | $Enums.ProducerType
  }

  export type MovieProducerPersonIdMovieIdCompoundUniqueInput = {
    personId: string
    movieId: string
  }

  export type MovieProducerCountOrderByAggregateInput = {
    personId?: SortOrder
    movieId?: SortOrder
    type?: SortOrder
  }

  export type MovieProducerMaxOrderByAggregateInput = {
    personId?: SortOrder
    movieId?: SortOrder
    type?: SortOrder
  }

  export type MovieProducerMinOrderByAggregateInput = {
    personId?: SortOrder
    movieId?: SortOrder
    type?: SortOrder
  }

  export type EnumProducerTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ProducerType | EnumProducerTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ProducerType[] | ListEnumProducerTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ProducerType[] | ListEnumProducerTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumProducerTypeWithAggregatesFilter<$PrismaModel> | $Enums.ProducerType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumProducerTypeFilter<$PrismaModel>
    _max?: NestedEnumProducerTypeFilter<$PrismaModel>
  }

  export type MovieCinemaOverrideMovieIdCinemaIdCompoundUniqueInput = {
    movieId: string
    cinemaId: string
  }

  export type MovieCinemaOverrideCountOrderByAggregateInput = {
    movieId?: SortOrder
    cinemaId?: SortOrder
    movieDataOverrides?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MovieCinemaOverrideMaxOrderByAggregateInput = {
    movieId?: SortOrder
    cinemaId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MovieCinemaOverrideMinOrderByAggregateInput = {
    movieId?: SortOrder
    cinemaId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LanguageNullableRelationFilter = {
    is?: LanguageWhereInput | null
    isNot?: LanguageWhereInput | null
  }

  export type ReservationListRelationFilter = {
    every?: ReservationWhereInput
    some?: ReservationWhereInput
    none?: ReservationWhereInput
  }

  export type ReservationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MovieProjectionCountOrderByAggregateInput = {
    id?: SortOrder
    movieId?: SortOrder
    cinemaTheaterId?: SortOrder
    projectionDateTime?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    dubbedLanguageId?: SortOrder
    options?: SortOrder
  }

  export type MovieProjectionMaxOrderByAggregateInput = {
    id?: SortOrder
    movieId?: SortOrder
    cinemaTheaterId?: SortOrder
    projectionDateTime?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    dubbedLanguageId?: SortOrder
  }

  export type MovieProjectionMinOrderByAggregateInput = {
    id?: SortOrder
    movieId?: SortOrder
    cinemaTheaterId?: SortOrder
    projectionDateTime?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    dubbedLanguageId?: SortOrder
  }

  export type EnumPriceTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.PriceType | EnumPriceTypeFieldRefInput<$PrismaModel>
    in?: $Enums.PriceType[] | ListEnumPriceTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.PriceType[] | ListEnumPriceTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumPriceTypeFilter<$PrismaModel> | $Enums.PriceType
  }

  export type DecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type EnumCurrencyCodeFilter<$PrismaModel = never> = {
    equals?: $Enums.CurrencyCode | EnumCurrencyCodeFieldRefInput<$PrismaModel>
    in?: $Enums.CurrencyCode[] | ListEnumCurrencyCodeFieldRefInput<$PrismaModel>
    notIn?: $Enums.CurrencyCode[] | ListEnumCurrencyCodeFieldRefInput<$PrismaModel>
    not?: NestedEnumCurrencyCodeFilter<$PrismaModel> | $Enums.CurrencyCode
  }

  export type MovieProjectionRelationFilter = {
    is?: MovieProjectionWhereInput
    isNot?: MovieProjectionWhereInput
  }

  export type ProjectionPriceProjectionIdGroupIdCompoundUniqueInput = {
    projectionId: string
    groupId: string
  }

  export type ProjectionPriceCountOrderByAggregateInput = {
    projectionId?: SortOrder
    groupId?: SortOrder
    type?: SortOrder
    price?: SortOrder
    currencyCode?: SortOrder
  }

  export type ProjectionPriceAvgOrderByAggregateInput = {
    price?: SortOrder
  }

  export type ProjectionPriceMaxOrderByAggregateInput = {
    projectionId?: SortOrder
    groupId?: SortOrder
    type?: SortOrder
    price?: SortOrder
    currencyCode?: SortOrder
  }

  export type ProjectionPriceMinOrderByAggregateInput = {
    projectionId?: SortOrder
    groupId?: SortOrder
    type?: SortOrder
    price?: SortOrder
    currencyCode?: SortOrder
  }

  export type ProjectionPriceSumOrderByAggregateInput = {
    price?: SortOrder
  }

  export type EnumPriceTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PriceType | EnumPriceTypeFieldRefInput<$PrismaModel>
    in?: $Enums.PriceType[] | ListEnumPriceTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.PriceType[] | ListEnumPriceTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumPriceTypeWithAggregatesFilter<$PrismaModel> | $Enums.PriceType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPriceTypeFilter<$PrismaModel>
    _max?: NestedEnumPriceTypeFilter<$PrismaModel>
  }

  export type DecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type EnumCurrencyCodeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CurrencyCode | EnumCurrencyCodeFieldRefInput<$PrismaModel>
    in?: $Enums.CurrencyCode[] | ListEnumCurrencyCodeFieldRefInput<$PrismaModel>
    notIn?: $Enums.CurrencyCode[] | ListEnumCurrencyCodeFieldRefInput<$PrismaModel>
    not?: NestedEnumCurrencyCodeWithAggregatesFilter<$PrismaModel> | $Enums.CurrencyCode
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCurrencyCodeFilter<$PrismaModel>
    _max?: NestedEnumCurrencyCodeFilter<$PrismaModel>
  }

  export type EnumAdminRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.AdminRole | EnumAdminRoleFieldRefInput<$PrismaModel>
    in?: $Enums.AdminRole[] | ListEnumAdminRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.AdminRole[] | ListEnumAdminRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumAdminRoleFilter<$PrismaModel> | $Enums.AdminRole
  }

  export type AdminUserCountOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    fullName?: SortOrder
    role?: SortOrder
    cinemaIds?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AdminUserMaxOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    fullName?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AdminUserMinOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    fullName?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumAdminRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AdminRole | EnumAdminRoleFieldRefInput<$PrismaModel>
    in?: $Enums.AdminRole[] | ListEnumAdminRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.AdminRole[] | ListEnumAdminRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumAdminRoleWithAggregatesFilter<$PrismaModel> | $Enums.AdminRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAdminRoleFilter<$PrismaModel>
    _max?: NestedEnumAdminRoleFilter<$PrismaModel>
  }

  export type ReservationCountOrderByAggregateInput = {
    id?: SortOrder
    eventId?: SortOrder
    customerInformation?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    options?: SortOrder
    deletedAt?: SortOrder
  }

  export type ReservationMaxOrderByAggregateInput = {
    id?: SortOrder
    eventId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type ReservationMinOrderByAggregateInput = {
    id?: SortOrder
    eventId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type UuidNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedUuidNullableFilter<$PrismaModel> | string | null
  }

  export type ReservationRelationFilter = {
    is?: ReservationWhereInput
    isNot?: ReservationWhereInput
  }

  export type CinemaSeatRelationFilter = {
    is?: CinemaSeatWhereInput
    isNot?: CinemaSeatWhereInput
  }

  export type AdminUserNullableRelationFilter = {
    is?: AdminUserWhereInput | null
    isNot?: AdminUserWhereInput | null
  }

  export type ReservationSeatsReservationIdSeatIdCompoundUniqueInput = {
    reservationId: string
    seatId: string
  }

  export type ReservationSeatsSeatIdEventIdDeletedAtCompoundUniqueInput = {
    seatId: string
    eventId: string
    deletedAt: Date | string
  }

  export type ReservationSeatsCountOrderByAggregateInput = {
    id?: SortOrder
    reservationId?: SortOrder
    eventId?: SortOrder
    seatId?: SortOrder
    options?: SortOrder
    deletedAt?: SortOrder
    validatedAt?: SortOrder
    validatedByAdminUserId?: SortOrder
  }

  export type ReservationSeatsMaxOrderByAggregateInput = {
    id?: SortOrder
    reservationId?: SortOrder
    eventId?: SortOrder
    seatId?: SortOrder
    deletedAt?: SortOrder
    validatedAt?: SortOrder
    validatedByAdminUserId?: SortOrder
  }

  export type ReservationSeatsMinOrderByAggregateInput = {
    id?: SortOrder
    reservationId?: SortOrder
    eventId?: SortOrder
    seatId?: SortOrder
    deletedAt?: SortOrder
    validatedAt?: SortOrder
    validatedByAdminUserId?: SortOrder
  }

  export type UuidNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedUuidNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type MovieCreateNestedManyWithoutGenresInput = {
    create?: XOR<MovieCreateWithoutGenresInput, MovieUncheckedCreateWithoutGenresInput> | MovieCreateWithoutGenresInput[] | MovieUncheckedCreateWithoutGenresInput[]
    connectOrCreate?: MovieCreateOrConnectWithoutGenresInput | MovieCreateOrConnectWithoutGenresInput[]
    connect?: MovieWhereUniqueInput | MovieWhereUniqueInput[]
  }

  export type MovieUncheckedCreateNestedManyWithoutGenresInput = {
    create?: XOR<MovieCreateWithoutGenresInput, MovieUncheckedCreateWithoutGenresInput> | MovieCreateWithoutGenresInput[] | MovieUncheckedCreateWithoutGenresInput[]
    connectOrCreate?: MovieCreateOrConnectWithoutGenresInput | MovieCreateOrConnectWithoutGenresInput[]
    connect?: MovieWhereUniqueInput | MovieWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type MovieUpdateManyWithoutGenresNestedInput = {
    create?: XOR<MovieCreateWithoutGenresInput, MovieUncheckedCreateWithoutGenresInput> | MovieCreateWithoutGenresInput[] | MovieUncheckedCreateWithoutGenresInput[]
    connectOrCreate?: MovieCreateOrConnectWithoutGenresInput | MovieCreateOrConnectWithoutGenresInput[]
    upsert?: MovieUpsertWithWhereUniqueWithoutGenresInput | MovieUpsertWithWhereUniqueWithoutGenresInput[]
    set?: MovieWhereUniqueInput | MovieWhereUniqueInput[]
    disconnect?: MovieWhereUniqueInput | MovieWhereUniqueInput[]
    delete?: MovieWhereUniqueInput | MovieWhereUniqueInput[]
    connect?: MovieWhereUniqueInput | MovieWhereUniqueInput[]
    update?: MovieUpdateWithWhereUniqueWithoutGenresInput | MovieUpdateWithWhereUniqueWithoutGenresInput[]
    updateMany?: MovieUpdateManyWithWhereWithoutGenresInput | MovieUpdateManyWithWhereWithoutGenresInput[]
    deleteMany?: MovieScalarWhereInput | MovieScalarWhereInput[]
  }

  export type MovieUncheckedUpdateManyWithoutGenresNestedInput = {
    create?: XOR<MovieCreateWithoutGenresInput, MovieUncheckedCreateWithoutGenresInput> | MovieCreateWithoutGenresInput[] | MovieUncheckedCreateWithoutGenresInput[]
    connectOrCreate?: MovieCreateOrConnectWithoutGenresInput | MovieCreateOrConnectWithoutGenresInput[]
    upsert?: MovieUpsertWithWhereUniqueWithoutGenresInput | MovieUpsertWithWhereUniqueWithoutGenresInput[]
    set?: MovieWhereUniqueInput | MovieWhereUniqueInput[]
    disconnect?: MovieWhereUniqueInput | MovieWhereUniqueInput[]
    delete?: MovieWhereUniqueInput | MovieWhereUniqueInput[]
    connect?: MovieWhereUniqueInput | MovieWhereUniqueInput[]
    update?: MovieUpdateWithWhereUniqueWithoutGenresInput | MovieUpdateWithWhereUniqueWithoutGenresInput[]
    updateMany?: MovieUpdateManyWithWhereWithoutGenresInput | MovieUpdateManyWithWhereWithoutGenresInput[]
    deleteMany?: MovieScalarWhereInput | MovieScalarWhereInput[]
  }

  export type MovieCreateNestedManyWithoutOriginalLanguageInput = {
    create?: XOR<MovieCreateWithoutOriginalLanguageInput, MovieUncheckedCreateWithoutOriginalLanguageInput> | MovieCreateWithoutOriginalLanguageInput[] | MovieUncheckedCreateWithoutOriginalLanguageInput[]
    connectOrCreate?: MovieCreateOrConnectWithoutOriginalLanguageInput | MovieCreateOrConnectWithoutOriginalLanguageInput[]
    createMany?: MovieCreateManyOriginalLanguageInputEnvelope
    connect?: MovieWhereUniqueInput | MovieWhereUniqueInput[]
  }

  export type MovieProjectionCreateNestedManyWithoutDubbedLanguageInput = {
    create?: XOR<MovieProjectionCreateWithoutDubbedLanguageInput, MovieProjectionUncheckedCreateWithoutDubbedLanguageInput> | MovieProjectionCreateWithoutDubbedLanguageInput[] | MovieProjectionUncheckedCreateWithoutDubbedLanguageInput[]
    connectOrCreate?: MovieProjectionCreateOrConnectWithoutDubbedLanguageInput | MovieProjectionCreateOrConnectWithoutDubbedLanguageInput[]
    createMany?: MovieProjectionCreateManyDubbedLanguageInputEnvelope
    connect?: MovieProjectionWhereUniqueInput | MovieProjectionWhereUniqueInput[]
  }

  export type MovieUncheckedCreateNestedManyWithoutOriginalLanguageInput = {
    create?: XOR<MovieCreateWithoutOriginalLanguageInput, MovieUncheckedCreateWithoutOriginalLanguageInput> | MovieCreateWithoutOriginalLanguageInput[] | MovieUncheckedCreateWithoutOriginalLanguageInput[]
    connectOrCreate?: MovieCreateOrConnectWithoutOriginalLanguageInput | MovieCreateOrConnectWithoutOriginalLanguageInput[]
    createMany?: MovieCreateManyOriginalLanguageInputEnvelope
    connect?: MovieWhereUniqueInput | MovieWhereUniqueInput[]
  }

  export type MovieProjectionUncheckedCreateNestedManyWithoutDubbedLanguageInput = {
    create?: XOR<MovieProjectionCreateWithoutDubbedLanguageInput, MovieProjectionUncheckedCreateWithoutDubbedLanguageInput> | MovieProjectionCreateWithoutDubbedLanguageInput[] | MovieProjectionUncheckedCreateWithoutDubbedLanguageInput[]
    connectOrCreate?: MovieProjectionCreateOrConnectWithoutDubbedLanguageInput | MovieProjectionCreateOrConnectWithoutDubbedLanguageInput[]
    createMany?: MovieProjectionCreateManyDubbedLanguageInputEnvelope
    connect?: MovieProjectionWhereUniqueInput | MovieProjectionWhereUniqueInput[]
  }

  export type MovieUpdateManyWithoutOriginalLanguageNestedInput = {
    create?: XOR<MovieCreateWithoutOriginalLanguageInput, MovieUncheckedCreateWithoutOriginalLanguageInput> | MovieCreateWithoutOriginalLanguageInput[] | MovieUncheckedCreateWithoutOriginalLanguageInput[]
    connectOrCreate?: MovieCreateOrConnectWithoutOriginalLanguageInput | MovieCreateOrConnectWithoutOriginalLanguageInput[]
    upsert?: MovieUpsertWithWhereUniqueWithoutOriginalLanguageInput | MovieUpsertWithWhereUniqueWithoutOriginalLanguageInput[]
    createMany?: MovieCreateManyOriginalLanguageInputEnvelope
    set?: MovieWhereUniqueInput | MovieWhereUniqueInput[]
    disconnect?: MovieWhereUniqueInput | MovieWhereUniqueInput[]
    delete?: MovieWhereUniqueInput | MovieWhereUniqueInput[]
    connect?: MovieWhereUniqueInput | MovieWhereUniqueInput[]
    update?: MovieUpdateWithWhereUniqueWithoutOriginalLanguageInput | MovieUpdateWithWhereUniqueWithoutOriginalLanguageInput[]
    updateMany?: MovieUpdateManyWithWhereWithoutOriginalLanguageInput | MovieUpdateManyWithWhereWithoutOriginalLanguageInput[]
    deleteMany?: MovieScalarWhereInput | MovieScalarWhereInput[]
  }

  export type MovieProjectionUpdateManyWithoutDubbedLanguageNestedInput = {
    create?: XOR<MovieProjectionCreateWithoutDubbedLanguageInput, MovieProjectionUncheckedCreateWithoutDubbedLanguageInput> | MovieProjectionCreateWithoutDubbedLanguageInput[] | MovieProjectionUncheckedCreateWithoutDubbedLanguageInput[]
    connectOrCreate?: MovieProjectionCreateOrConnectWithoutDubbedLanguageInput | MovieProjectionCreateOrConnectWithoutDubbedLanguageInput[]
    upsert?: MovieProjectionUpsertWithWhereUniqueWithoutDubbedLanguageInput | MovieProjectionUpsertWithWhereUniqueWithoutDubbedLanguageInput[]
    createMany?: MovieProjectionCreateManyDubbedLanguageInputEnvelope
    set?: MovieProjectionWhereUniqueInput | MovieProjectionWhereUniqueInput[]
    disconnect?: MovieProjectionWhereUniqueInput | MovieProjectionWhereUniqueInput[]
    delete?: MovieProjectionWhereUniqueInput | MovieProjectionWhereUniqueInput[]
    connect?: MovieProjectionWhereUniqueInput | MovieProjectionWhereUniqueInput[]
    update?: MovieProjectionUpdateWithWhereUniqueWithoutDubbedLanguageInput | MovieProjectionUpdateWithWhereUniqueWithoutDubbedLanguageInput[]
    updateMany?: MovieProjectionUpdateManyWithWhereWithoutDubbedLanguageInput | MovieProjectionUpdateManyWithWhereWithoutDubbedLanguageInput[]
    deleteMany?: MovieProjectionScalarWhereInput | MovieProjectionScalarWhereInput[]
  }

  export type MovieUncheckedUpdateManyWithoutOriginalLanguageNestedInput = {
    create?: XOR<MovieCreateWithoutOriginalLanguageInput, MovieUncheckedCreateWithoutOriginalLanguageInput> | MovieCreateWithoutOriginalLanguageInput[] | MovieUncheckedCreateWithoutOriginalLanguageInput[]
    connectOrCreate?: MovieCreateOrConnectWithoutOriginalLanguageInput | MovieCreateOrConnectWithoutOriginalLanguageInput[]
    upsert?: MovieUpsertWithWhereUniqueWithoutOriginalLanguageInput | MovieUpsertWithWhereUniqueWithoutOriginalLanguageInput[]
    createMany?: MovieCreateManyOriginalLanguageInputEnvelope
    set?: MovieWhereUniqueInput | MovieWhereUniqueInput[]
    disconnect?: MovieWhereUniqueInput | MovieWhereUniqueInput[]
    delete?: MovieWhereUniqueInput | MovieWhereUniqueInput[]
    connect?: MovieWhereUniqueInput | MovieWhereUniqueInput[]
    update?: MovieUpdateWithWhereUniqueWithoutOriginalLanguageInput | MovieUpdateWithWhereUniqueWithoutOriginalLanguageInput[]
    updateMany?: MovieUpdateManyWithWhereWithoutOriginalLanguageInput | MovieUpdateManyWithWhereWithoutOriginalLanguageInput[]
    deleteMany?: MovieScalarWhereInput | MovieScalarWhereInput[]
  }

  export type MovieProjectionUncheckedUpdateManyWithoutDubbedLanguageNestedInput = {
    create?: XOR<MovieProjectionCreateWithoutDubbedLanguageInput, MovieProjectionUncheckedCreateWithoutDubbedLanguageInput> | MovieProjectionCreateWithoutDubbedLanguageInput[] | MovieProjectionUncheckedCreateWithoutDubbedLanguageInput[]
    connectOrCreate?: MovieProjectionCreateOrConnectWithoutDubbedLanguageInput | MovieProjectionCreateOrConnectWithoutDubbedLanguageInput[]
    upsert?: MovieProjectionUpsertWithWhereUniqueWithoutDubbedLanguageInput | MovieProjectionUpsertWithWhereUniqueWithoutDubbedLanguageInput[]
    createMany?: MovieProjectionCreateManyDubbedLanguageInputEnvelope
    set?: MovieProjectionWhereUniqueInput | MovieProjectionWhereUniqueInput[]
    disconnect?: MovieProjectionWhereUniqueInput | MovieProjectionWhereUniqueInput[]
    delete?: MovieProjectionWhereUniqueInput | MovieProjectionWhereUniqueInput[]
    connect?: MovieProjectionWhereUniqueInput | MovieProjectionWhereUniqueInput[]
    update?: MovieProjectionUpdateWithWhereUniqueWithoutDubbedLanguageInput | MovieProjectionUpdateWithWhereUniqueWithoutDubbedLanguageInput[]
    updateMany?: MovieProjectionUpdateManyWithWhereWithoutDubbedLanguageInput | MovieProjectionUpdateManyWithWhereWithoutDubbedLanguageInput[]
    deleteMany?: MovieProjectionScalarWhereInput | MovieProjectionScalarWhereInput[]
  }

  export type CityCreateNestedManyWithoutCountryInput = {
    create?: XOR<CityCreateWithoutCountryInput, CityUncheckedCreateWithoutCountryInput> | CityCreateWithoutCountryInput[] | CityUncheckedCreateWithoutCountryInput[]
    connectOrCreate?: CityCreateOrConnectWithoutCountryInput | CityCreateOrConnectWithoutCountryInput[]
    createMany?: CityCreateManyCountryInputEnvelope
    connect?: CityWhereUniqueInput | CityWhereUniqueInput[]
  }

  export type MovieCreateNestedManyWithoutCountryOfOriginInput = {
    create?: XOR<MovieCreateWithoutCountryOfOriginInput, MovieUncheckedCreateWithoutCountryOfOriginInput> | MovieCreateWithoutCountryOfOriginInput[] | MovieUncheckedCreateWithoutCountryOfOriginInput[]
    connectOrCreate?: MovieCreateOrConnectWithoutCountryOfOriginInput | MovieCreateOrConnectWithoutCountryOfOriginInput[]
    createMany?: MovieCreateManyCountryOfOriginInputEnvelope
    connect?: MovieWhereUniqueInput | MovieWhereUniqueInput[]
  }

  export type CityUncheckedCreateNestedManyWithoutCountryInput = {
    create?: XOR<CityCreateWithoutCountryInput, CityUncheckedCreateWithoutCountryInput> | CityCreateWithoutCountryInput[] | CityUncheckedCreateWithoutCountryInput[]
    connectOrCreate?: CityCreateOrConnectWithoutCountryInput | CityCreateOrConnectWithoutCountryInput[]
    createMany?: CityCreateManyCountryInputEnvelope
    connect?: CityWhereUniqueInput | CityWhereUniqueInput[]
  }

  export type MovieUncheckedCreateNestedManyWithoutCountryOfOriginInput = {
    create?: XOR<MovieCreateWithoutCountryOfOriginInput, MovieUncheckedCreateWithoutCountryOfOriginInput> | MovieCreateWithoutCountryOfOriginInput[] | MovieUncheckedCreateWithoutCountryOfOriginInput[]
    connectOrCreate?: MovieCreateOrConnectWithoutCountryOfOriginInput | MovieCreateOrConnectWithoutCountryOfOriginInput[]
    createMany?: MovieCreateManyCountryOfOriginInputEnvelope
    connect?: MovieWhereUniqueInput | MovieWhereUniqueInput[]
  }

  export type CityUpdateManyWithoutCountryNestedInput = {
    create?: XOR<CityCreateWithoutCountryInput, CityUncheckedCreateWithoutCountryInput> | CityCreateWithoutCountryInput[] | CityUncheckedCreateWithoutCountryInput[]
    connectOrCreate?: CityCreateOrConnectWithoutCountryInput | CityCreateOrConnectWithoutCountryInput[]
    upsert?: CityUpsertWithWhereUniqueWithoutCountryInput | CityUpsertWithWhereUniqueWithoutCountryInput[]
    createMany?: CityCreateManyCountryInputEnvelope
    set?: CityWhereUniqueInput | CityWhereUniqueInput[]
    disconnect?: CityWhereUniqueInput | CityWhereUniqueInput[]
    delete?: CityWhereUniqueInput | CityWhereUniqueInput[]
    connect?: CityWhereUniqueInput | CityWhereUniqueInput[]
    update?: CityUpdateWithWhereUniqueWithoutCountryInput | CityUpdateWithWhereUniqueWithoutCountryInput[]
    updateMany?: CityUpdateManyWithWhereWithoutCountryInput | CityUpdateManyWithWhereWithoutCountryInput[]
    deleteMany?: CityScalarWhereInput | CityScalarWhereInput[]
  }

  export type MovieUpdateManyWithoutCountryOfOriginNestedInput = {
    create?: XOR<MovieCreateWithoutCountryOfOriginInput, MovieUncheckedCreateWithoutCountryOfOriginInput> | MovieCreateWithoutCountryOfOriginInput[] | MovieUncheckedCreateWithoutCountryOfOriginInput[]
    connectOrCreate?: MovieCreateOrConnectWithoutCountryOfOriginInput | MovieCreateOrConnectWithoutCountryOfOriginInput[]
    upsert?: MovieUpsertWithWhereUniqueWithoutCountryOfOriginInput | MovieUpsertWithWhereUniqueWithoutCountryOfOriginInput[]
    createMany?: MovieCreateManyCountryOfOriginInputEnvelope
    set?: MovieWhereUniqueInput | MovieWhereUniqueInput[]
    disconnect?: MovieWhereUniqueInput | MovieWhereUniqueInput[]
    delete?: MovieWhereUniqueInput | MovieWhereUniqueInput[]
    connect?: MovieWhereUniqueInput | MovieWhereUniqueInput[]
    update?: MovieUpdateWithWhereUniqueWithoutCountryOfOriginInput | MovieUpdateWithWhereUniqueWithoutCountryOfOriginInput[]
    updateMany?: MovieUpdateManyWithWhereWithoutCountryOfOriginInput | MovieUpdateManyWithWhereWithoutCountryOfOriginInput[]
    deleteMany?: MovieScalarWhereInput | MovieScalarWhereInput[]
  }

  export type CityUncheckedUpdateManyWithoutCountryNestedInput = {
    create?: XOR<CityCreateWithoutCountryInput, CityUncheckedCreateWithoutCountryInput> | CityCreateWithoutCountryInput[] | CityUncheckedCreateWithoutCountryInput[]
    connectOrCreate?: CityCreateOrConnectWithoutCountryInput | CityCreateOrConnectWithoutCountryInput[]
    upsert?: CityUpsertWithWhereUniqueWithoutCountryInput | CityUpsertWithWhereUniqueWithoutCountryInput[]
    createMany?: CityCreateManyCountryInputEnvelope
    set?: CityWhereUniqueInput | CityWhereUniqueInput[]
    disconnect?: CityWhereUniqueInput | CityWhereUniqueInput[]
    delete?: CityWhereUniqueInput | CityWhereUniqueInput[]
    connect?: CityWhereUniqueInput | CityWhereUniqueInput[]
    update?: CityUpdateWithWhereUniqueWithoutCountryInput | CityUpdateWithWhereUniqueWithoutCountryInput[]
    updateMany?: CityUpdateManyWithWhereWithoutCountryInput | CityUpdateManyWithWhereWithoutCountryInput[]
    deleteMany?: CityScalarWhereInput | CityScalarWhereInput[]
  }

  export type MovieUncheckedUpdateManyWithoutCountryOfOriginNestedInput = {
    create?: XOR<MovieCreateWithoutCountryOfOriginInput, MovieUncheckedCreateWithoutCountryOfOriginInput> | MovieCreateWithoutCountryOfOriginInput[] | MovieUncheckedCreateWithoutCountryOfOriginInput[]
    connectOrCreate?: MovieCreateOrConnectWithoutCountryOfOriginInput | MovieCreateOrConnectWithoutCountryOfOriginInput[]
    upsert?: MovieUpsertWithWhereUniqueWithoutCountryOfOriginInput | MovieUpsertWithWhereUniqueWithoutCountryOfOriginInput[]
    createMany?: MovieCreateManyCountryOfOriginInputEnvelope
    set?: MovieWhereUniqueInput | MovieWhereUniqueInput[]
    disconnect?: MovieWhereUniqueInput | MovieWhereUniqueInput[]
    delete?: MovieWhereUniqueInput | MovieWhereUniqueInput[]
    connect?: MovieWhereUniqueInput | MovieWhereUniqueInput[]
    update?: MovieUpdateWithWhereUniqueWithoutCountryOfOriginInput | MovieUpdateWithWhereUniqueWithoutCountryOfOriginInput[]
    updateMany?: MovieUpdateManyWithWhereWithoutCountryOfOriginInput | MovieUpdateManyWithWhereWithoutCountryOfOriginInput[]
    deleteMany?: MovieScalarWhereInput | MovieScalarWhereInput[]
  }

  export type CountryCreateNestedOneWithoutCitiesInput = {
    create?: XOR<CountryCreateWithoutCitiesInput, CountryUncheckedCreateWithoutCitiesInput>
    connectOrCreate?: CountryCreateOrConnectWithoutCitiesInput
    connect?: CountryWhereUniqueInput
  }

  export type CinemaCreateNestedManyWithoutCityInput = {
    create?: XOR<CinemaCreateWithoutCityInput, CinemaUncheckedCreateWithoutCityInput> | CinemaCreateWithoutCityInput[] | CinemaUncheckedCreateWithoutCityInput[]
    connectOrCreate?: CinemaCreateOrConnectWithoutCityInput | CinemaCreateOrConnectWithoutCityInput[]
    createMany?: CinemaCreateManyCityInputEnvelope
    connect?: CinemaWhereUniqueInput | CinemaWhereUniqueInput[]
  }

  export type CinemaUncheckedCreateNestedManyWithoutCityInput = {
    create?: XOR<CinemaCreateWithoutCityInput, CinemaUncheckedCreateWithoutCityInput> | CinemaCreateWithoutCityInput[] | CinemaUncheckedCreateWithoutCityInput[]
    connectOrCreate?: CinemaCreateOrConnectWithoutCityInput | CinemaCreateOrConnectWithoutCityInput[]
    createMany?: CinemaCreateManyCityInputEnvelope
    connect?: CinemaWhereUniqueInput | CinemaWhereUniqueInput[]
  }

  export type CountryUpdateOneRequiredWithoutCitiesNestedInput = {
    create?: XOR<CountryCreateWithoutCitiesInput, CountryUncheckedCreateWithoutCitiesInput>
    connectOrCreate?: CountryCreateOrConnectWithoutCitiesInput
    upsert?: CountryUpsertWithoutCitiesInput
    connect?: CountryWhereUniqueInput
    update?: XOR<XOR<CountryUpdateToOneWithWhereWithoutCitiesInput, CountryUpdateWithoutCitiesInput>, CountryUncheckedUpdateWithoutCitiesInput>
  }

  export type CinemaUpdateManyWithoutCityNestedInput = {
    create?: XOR<CinemaCreateWithoutCityInput, CinemaUncheckedCreateWithoutCityInput> | CinemaCreateWithoutCityInput[] | CinemaUncheckedCreateWithoutCityInput[]
    connectOrCreate?: CinemaCreateOrConnectWithoutCityInput | CinemaCreateOrConnectWithoutCityInput[]
    upsert?: CinemaUpsertWithWhereUniqueWithoutCityInput | CinemaUpsertWithWhereUniqueWithoutCityInput[]
    createMany?: CinemaCreateManyCityInputEnvelope
    set?: CinemaWhereUniqueInput | CinemaWhereUniqueInput[]
    disconnect?: CinemaWhereUniqueInput | CinemaWhereUniqueInput[]
    delete?: CinemaWhereUniqueInput | CinemaWhereUniqueInput[]
    connect?: CinemaWhereUniqueInput | CinemaWhereUniqueInput[]
    update?: CinemaUpdateWithWhereUniqueWithoutCityInput | CinemaUpdateWithWhereUniqueWithoutCityInput[]
    updateMany?: CinemaUpdateManyWithWhereWithoutCityInput | CinemaUpdateManyWithWhereWithoutCityInput[]
    deleteMany?: CinemaScalarWhereInput | CinemaScalarWhereInput[]
  }

  export type CinemaUncheckedUpdateManyWithoutCityNestedInput = {
    create?: XOR<CinemaCreateWithoutCityInput, CinemaUncheckedCreateWithoutCityInput> | CinemaCreateWithoutCityInput[] | CinemaUncheckedCreateWithoutCityInput[]
    connectOrCreate?: CinemaCreateOrConnectWithoutCityInput | CinemaCreateOrConnectWithoutCityInput[]
    upsert?: CinemaUpsertWithWhereUniqueWithoutCityInput | CinemaUpsertWithWhereUniqueWithoutCityInput[]
    createMany?: CinemaCreateManyCityInputEnvelope
    set?: CinemaWhereUniqueInput | CinemaWhereUniqueInput[]
    disconnect?: CinemaWhereUniqueInput | CinemaWhereUniqueInput[]
    delete?: CinemaWhereUniqueInput | CinemaWhereUniqueInput[]
    connect?: CinemaWhereUniqueInput | CinemaWhereUniqueInput[]
    update?: CinemaUpdateWithWhereUniqueWithoutCityInput | CinemaUpdateWithWhereUniqueWithoutCityInput[]
    updateMany?: CinemaUpdateManyWithWhereWithoutCityInput | CinemaUpdateManyWithWhereWithoutCityInput[]
    deleteMany?: CinemaScalarWhereInput | CinemaScalarWhereInput[]
  }

  export type CityCreateNestedOneWithoutCinemasInput = {
    create?: XOR<CityCreateWithoutCinemasInput, CityUncheckedCreateWithoutCinemasInput>
    connectOrCreate?: CityCreateOrConnectWithoutCinemasInput
    connect?: CityWhereUniqueInput
  }

  export type CinemaTheaterCreateNestedManyWithoutCinemaInput = {
    create?: XOR<CinemaTheaterCreateWithoutCinemaInput, CinemaTheaterUncheckedCreateWithoutCinemaInput> | CinemaTheaterCreateWithoutCinemaInput[] | CinemaTheaterUncheckedCreateWithoutCinemaInput[]
    connectOrCreate?: CinemaTheaterCreateOrConnectWithoutCinemaInput | CinemaTheaterCreateOrConnectWithoutCinemaInput[]
    createMany?: CinemaTheaterCreateManyCinemaInputEnvelope
    connect?: CinemaTheaterWhereUniqueInput | CinemaTheaterWhereUniqueInput[]
  }

  export type MovieCinemaOverrideCreateNestedManyWithoutCinemaInput = {
    create?: XOR<MovieCinemaOverrideCreateWithoutCinemaInput, MovieCinemaOverrideUncheckedCreateWithoutCinemaInput> | MovieCinemaOverrideCreateWithoutCinemaInput[] | MovieCinemaOverrideUncheckedCreateWithoutCinemaInput[]
    connectOrCreate?: MovieCinemaOverrideCreateOrConnectWithoutCinemaInput | MovieCinemaOverrideCreateOrConnectWithoutCinemaInput[]
    createMany?: MovieCinemaOverrideCreateManyCinemaInputEnvelope
    connect?: MovieCinemaOverrideWhereUniqueInput | MovieCinemaOverrideWhereUniqueInput[]
  }

  export type CinemaTheaterUncheckedCreateNestedManyWithoutCinemaInput = {
    create?: XOR<CinemaTheaterCreateWithoutCinemaInput, CinemaTheaterUncheckedCreateWithoutCinemaInput> | CinemaTheaterCreateWithoutCinemaInput[] | CinemaTheaterUncheckedCreateWithoutCinemaInput[]
    connectOrCreate?: CinemaTheaterCreateOrConnectWithoutCinemaInput | CinemaTheaterCreateOrConnectWithoutCinemaInput[]
    createMany?: CinemaTheaterCreateManyCinemaInputEnvelope
    connect?: CinemaTheaterWhereUniqueInput | CinemaTheaterWhereUniqueInput[]
  }

  export type MovieCinemaOverrideUncheckedCreateNestedManyWithoutCinemaInput = {
    create?: XOR<MovieCinemaOverrideCreateWithoutCinemaInput, MovieCinemaOverrideUncheckedCreateWithoutCinemaInput> | MovieCinemaOverrideCreateWithoutCinemaInput[] | MovieCinemaOverrideUncheckedCreateWithoutCinemaInput[]
    connectOrCreate?: MovieCinemaOverrideCreateOrConnectWithoutCinemaInput | MovieCinemaOverrideCreateOrConnectWithoutCinemaInput[]
    createMany?: MovieCinemaOverrideCreateManyCinemaInputEnvelope
    connect?: MovieCinemaOverrideWhereUniqueInput | MovieCinemaOverrideWhereUniqueInput[]
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NullableDecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string | null
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type CityUpdateOneRequiredWithoutCinemasNestedInput = {
    create?: XOR<CityCreateWithoutCinemasInput, CityUncheckedCreateWithoutCinemasInput>
    connectOrCreate?: CityCreateOrConnectWithoutCinemasInput
    upsert?: CityUpsertWithoutCinemasInput
    connect?: CityWhereUniqueInput
    update?: XOR<XOR<CityUpdateToOneWithWhereWithoutCinemasInput, CityUpdateWithoutCinemasInput>, CityUncheckedUpdateWithoutCinemasInput>
  }

  export type CinemaTheaterUpdateManyWithoutCinemaNestedInput = {
    create?: XOR<CinemaTheaterCreateWithoutCinemaInput, CinemaTheaterUncheckedCreateWithoutCinemaInput> | CinemaTheaterCreateWithoutCinemaInput[] | CinemaTheaterUncheckedCreateWithoutCinemaInput[]
    connectOrCreate?: CinemaTheaterCreateOrConnectWithoutCinemaInput | CinemaTheaterCreateOrConnectWithoutCinemaInput[]
    upsert?: CinemaTheaterUpsertWithWhereUniqueWithoutCinemaInput | CinemaTheaterUpsertWithWhereUniqueWithoutCinemaInput[]
    createMany?: CinemaTheaterCreateManyCinemaInputEnvelope
    set?: CinemaTheaterWhereUniqueInput | CinemaTheaterWhereUniqueInput[]
    disconnect?: CinemaTheaterWhereUniqueInput | CinemaTheaterWhereUniqueInput[]
    delete?: CinemaTheaterWhereUniqueInput | CinemaTheaterWhereUniqueInput[]
    connect?: CinemaTheaterWhereUniqueInput | CinemaTheaterWhereUniqueInput[]
    update?: CinemaTheaterUpdateWithWhereUniqueWithoutCinemaInput | CinemaTheaterUpdateWithWhereUniqueWithoutCinemaInput[]
    updateMany?: CinemaTheaterUpdateManyWithWhereWithoutCinemaInput | CinemaTheaterUpdateManyWithWhereWithoutCinemaInput[]
    deleteMany?: CinemaTheaterScalarWhereInput | CinemaTheaterScalarWhereInput[]
  }

  export type MovieCinemaOverrideUpdateManyWithoutCinemaNestedInput = {
    create?: XOR<MovieCinemaOverrideCreateWithoutCinemaInput, MovieCinemaOverrideUncheckedCreateWithoutCinemaInput> | MovieCinemaOverrideCreateWithoutCinemaInput[] | MovieCinemaOverrideUncheckedCreateWithoutCinemaInput[]
    connectOrCreate?: MovieCinemaOverrideCreateOrConnectWithoutCinemaInput | MovieCinemaOverrideCreateOrConnectWithoutCinemaInput[]
    upsert?: MovieCinemaOverrideUpsertWithWhereUniqueWithoutCinemaInput | MovieCinemaOverrideUpsertWithWhereUniqueWithoutCinemaInput[]
    createMany?: MovieCinemaOverrideCreateManyCinemaInputEnvelope
    set?: MovieCinemaOverrideWhereUniqueInput | MovieCinemaOverrideWhereUniqueInput[]
    disconnect?: MovieCinemaOverrideWhereUniqueInput | MovieCinemaOverrideWhereUniqueInput[]
    delete?: MovieCinemaOverrideWhereUniqueInput | MovieCinemaOverrideWhereUniqueInput[]
    connect?: MovieCinemaOverrideWhereUniqueInput | MovieCinemaOverrideWhereUniqueInput[]
    update?: MovieCinemaOverrideUpdateWithWhereUniqueWithoutCinemaInput | MovieCinemaOverrideUpdateWithWhereUniqueWithoutCinemaInput[]
    updateMany?: MovieCinemaOverrideUpdateManyWithWhereWithoutCinemaInput | MovieCinemaOverrideUpdateManyWithWhereWithoutCinemaInput[]
    deleteMany?: MovieCinemaOverrideScalarWhereInput | MovieCinemaOverrideScalarWhereInput[]
  }

  export type CinemaTheaterUncheckedUpdateManyWithoutCinemaNestedInput = {
    create?: XOR<CinemaTheaterCreateWithoutCinemaInput, CinemaTheaterUncheckedCreateWithoutCinemaInput> | CinemaTheaterCreateWithoutCinemaInput[] | CinemaTheaterUncheckedCreateWithoutCinemaInput[]
    connectOrCreate?: CinemaTheaterCreateOrConnectWithoutCinemaInput | CinemaTheaterCreateOrConnectWithoutCinemaInput[]
    upsert?: CinemaTheaterUpsertWithWhereUniqueWithoutCinemaInput | CinemaTheaterUpsertWithWhereUniqueWithoutCinemaInput[]
    createMany?: CinemaTheaterCreateManyCinemaInputEnvelope
    set?: CinemaTheaterWhereUniqueInput | CinemaTheaterWhereUniqueInput[]
    disconnect?: CinemaTheaterWhereUniqueInput | CinemaTheaterWhereUniqueInput[]
    delete?: CinemaTheaterWhereUniqueInput | CinemaTheaterWhereUniqueInput[]
    connect?: CinemaTheaterWhereUniqueInput | CinemaTheaterWhereUniqueInput[]
    update?: CinemaTheaterUpdateWithWhereUniqueWithoutCinemaInput | CinemaTheaterUpdateWithWhereUniqueWithoutCinemaInput[]
    updateMany?: CinemaTheaterUpdateManyWithWhereWithoutCinemaInput | CinemaTheaterUpdateManyWithWhereWithoutCinemaInput[]
    deleteMany?: CinemaTheaterScalarWhereInput | CinemaTheaterScalarWhereInput[]
  }

  export type MovieCinemaOverrideUncheckedUpdateManyWithoutCinemaNestedInput = {
    create?: XOR<MovieCinemaOverrideCreateWithoutCinemaInput, MovieCinemaOverrideUncheckedCreateWithoutCinemaInput> | MovieCinemaOverrideCreateWithoutCinemaInput[] | MovieCinemaOverrideUncheckedCreateWithoutCinemaInput[]
    connectOrCreate?: MovieCinemaOverrideCreateOrConnectWithoutCinemaInput | MovieCinemaOverrideCreateOrConnectWithoutCinemaInput[]
    upsert?: MovieCinemaOverrideUpsertWithWhereUniqueWithoutCinemaInput | MovieCinemaOverrideUpsertWithWhereUniqueWithoutCinemaInput[]
    createMany?: MovieCinemaOverrideCreateManyCinemaInputEnvelope
    set?: MovieCinemaOverrideWhereUniqueInput | MovieCinemaOverrideWhereUniqueInput[]
    disconnect?: MovieCinemaOverrideWhereUniqueInput | MovieCinemaOverrideWhereUniqueInput[]
    delete?: MovieCinemaOverrideWhereUniqueInput | MovieCinemaOverrideWhereUniqueInput[]
    connect?: MovieCinemaOverrideWhereUniqueInput | MovieCinemaOverrideWhereUniqueInput[]
    update?: MovieCinemaOverrideUpdateWithWhereUniqueWithoutCinemaInput | MovieCinemaOverrideUpdateWithWhereUniqueWithoutCinemaInput[]
    updateMany?: MovieCinemaOverrideUpdateManyWithWhereWithoutCinemaInput | MovieCinemaOverrideUpdateManyWithWhereWithoutCinemaInput[]
    deleteMany?: MovieCinemaOverrideScalarWhereInput | MovieCinemaOverrideScalarWhereInput[]
  }

  export type CinemaCreateNestedOneWithoutCinemaTheatersInput = {
    create?: XOR<CinemaCreateWithoutCinemaTheatersInput, CinemaUncheckedCreateWithoutCinemaTheatersInput>
    connectOrCreate?: CinemaCreateOrConnectWithoutCinemaTheatersInput
    connect?: CinemaWhereUniqueInput
  }

  export type CinemaSeatGroupCreateNestedManyWithoutCinemaTheaterInput = {
    create?: XOR<CinemaSeatGroupCreateWithoutCinemaTheaterInput, CinemaSeatGroupUncheckedCreateWithoutCinemaTheaterInput> | CinemaSeatGroupCreateWithoutCinemaTheaterInput[] | CinemaSeatGroupUncheckedCreateWithoutCinemaTheaterInput[]
    connectOrCreate?: CinemaSeatGroupCreateOrConnectWithoutCinemaTheaterInput | CinemaSeatGroupCreateOrConnectWithoutCinemaTheaterInput[]
    createMany?: CinemaSeatGroupCreateManyCinemaTheaterInputEnvelope
    connect?: CinemaSeatGroupWhereUniqueInput | CinemaSeatGroupWhereUniqueInput[]
  }

  export type MovieProjectionCreateNestedManyWithoutCinemaTheaterInput = {
    create?: XOR<MovieProjectionCreateWithoutCinemaTheaterInput, MovieProjectionUncheckedCreateWithoutCinemaTheaterInput> | MovieProjectionCreateWithoutCinemaTheaterInput[] | MovieProjectionUncheckedCreateWithoutCinemaTheaterInput[]
    connectOrCreate?: MovieProjectionCreateOrConnectWithoutCinemaTheaterInput | MovieProjectionCreateOrConnectWithoutCinemaTheaterInput[]
    createMany?: MovieProjectionCreateManyCinemaTheaterInputEnvelope
    connect?: MovieProjectionWhereUniqueInput | MovieProjectionWhereUniqueInput[]
  }

  export type CinemaSeatGroupUncheckedCreateNestedManyWithoutCinemaTheaterInput = {
    create?: XOR<CinemaSeatGroupCreateWithoutCinemaTheaterInput, CinemaSeatGroupUncheckedCreateWithoutCinemaTheaterInput> | CinemaSeatGroupCreateWithoutCinemaTheaterInput[] | CinemaSeatGroupUncheckedCreateWithoutCinemaTheaterInput[]
    connectOrCreate?: CinemaSeatGroupCreateOrConnectWithoutCinemaTheaterInput | CinemaSeatGroupCreateOrConnectWithoutCinemaTheaterInput[]
    createMany?: CinemaSeatGroupCreateManyCinemaTheaterInputEnvelope
    connect?: CinemaSeatGroupWhereUniqueInput | CinemaSeatGroupWhereUniqueInput[]
  }

  export type MovieProjectionUncheckedCreateNestedManyWithoutCinemaTheaterInput = {
    create?: XOR<MovieProjectionCreateWithoutCinemaTheaterInput, MovieProjectionUncheckedCreateWithoutCinemaTheaterInput> | MovieProjectionCreateWithoutCinemaTheaterInput[] | MovieProjectionUncheckedCreateWithoutCinemaTheaterInput[]
    connectOrCreate?: MovieProjectionCreateOrConnectWithoutCinemaTheaterInput | MovieProjectionCreateOrConnectWithoutCinemaTheaterInput[]
    createMany?: MovieProjectionCreateManyCinemaTheaterInputEnvelope
    connect?: MovieProjectionWhereUniqueInput | MovieProjectionWhereUniqueInput[]
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type CinemaUpdateOneRequiredWithoutCinemaTheatersNestedInput = {
    create?: XOR<CinemaCreateWithoutCinemaTheatersInput, CinemaUncheckedCreateWithoutCinemaTheatersInput>
    connectOrCreate?: CinemaCreateOrConnectWithoutCinemaTheatersInput
    upsert?: CinemaUpsertWithoutCinemaTheatersInput
    connect?: CinemaWhereUniqueInput
    update?: XOR<XOR<CinemaUpdateToOneWithWhereWithoutCinemaTheatersInput, CinemaUpdateWithoutCinemaTheatersInput>, CinemaUncheckedUpdateWithoutCinemaTheatersInput>
  }

  export type CinemaSeatGroupUpdateManyWithoutCinemaTheaterNestedInput = {
    create?: XOR<CinemaSeatGroupCreateWithoutCinemaTheaterInput, CinemaSeatGroupUncheckedCreateWithoutCinemaTheaterInput> | CinemaSeatGroupCreateWithoutCinemaTheaterInput[] | CinemaSeatGroupUncheckedCreateWithoutCinemaTheaterInput[]
    connectOrCreate?: CinemaSeatGroupCreateOrConnectWithoutCinemaTheaterInput | CinemaSeatGroupCreateOrConnectWithoutCinemaTheaterInput[]
    upsert?: CinemaSeatGroupUpsertWithWhereUniqueWithoutCinemaTheaterInput | CinemaSeatGroupUpsertWithWhereUniqueWithoutCinemaTheaterInput[]
    createMany?: CinemaSeatGroupCreateManyCinemaTheaterInputEnvelope
    set?: CinemaSeatGroupWhereUniqueInput | CinemaSeatGroupWhereUniqueInput[]
    disconnect?: CinemaSeatGroupWhereUniqueInput | CinemaSeatGroupWhereUniqueInput[]
    delete?: CinemaSeatGroupWhereUniqueInput | CinemaSeatGroupWhereUniqueInput[]
    connect?: CinemaSeatGroupWhereUniqueInput | CinemaSeatGroupWhereUniqueInput[]
    update?: CinemaSeatGroupUpdateWithWhereUniqueWithoutCinemaTheaterInput | CinemaSeatGroupUpdateWithWhereUniqueWithoutCinemaTheaterInput[]
    updateMany?: CinemaSeatGroupUpdateManyWithWhereWithoutCinemaTheaterInput | CinemaSeatGroupUpdateManyWithWhereWithoutCinemaTheaterInput[]
    deleteMany?: CinemaSeatGroupScalarWhereInput | CinemaSeatGroupScalarWhereInput[]
  }

  export type MovieProjectionUpdateManyWithoutCinemaTheaterNestedInput = {
    create?: XOR<MovieProjectionCreateWithoutCinemaTheaterInput, MovieProjectionUncheckedCreateWithoutCinemaTheaterInput> | MovieProjectionCreateWithoutCinemaTheaterInput[] | MovieProjectionUncheckedCreateWithoutCinemaTheaterInput[]
    connectOrCreate?: MovieProjectionCreateOrConnectWithoutCinemaTheaterInput | MovieProjectionCreateOrConnectWithoutCinemaTheaterInput[]
    upsert?: MovieProjectionUpsertWithWhereUniqueWithoutCinemaTheaterInput | MovieProjectionUpsertWithWhereUniqueWithoutCinemaTheaterInput[]
    createMany?: MovieProjectionCreateManyCinemaTheaterInputEnvelope
    set?: MovieProjectionWhereUniqueInput | MovieProjectionWhereUniqueInput[]
    disconnect?: MovieProjectionWhereUniqueInput | MovieProjectionWhereUniqueInput[]
    delete?: MovieProjectionWhereUniqueInput | MovieProjectionWhereUniqueInput[]
    connect?: MovieProjectionWhereUniqueInput | MovieProjectionWhereUniqueInput[]
    update?: MovieProjectionUpdateWithWhereUniqueWithoutCinemaTheaterInput | MovieProjectionUpdateWithWhereUniqueWithoutCinemaTheaterInput[]
    updateMany?: MovieProjectionUpdateManyWithWhereWithoutCinemaTheaterInput | MovieProjectionUpdateManyWithWhereWithoutCinemaTheaterInput[]
    deleteMany?: MovieProjectionScalarWhereInput | MovieProjectionScalarWhereInput[]
  }

  export type CinemaSeatGroupUncheckedUpdateManyWithoutCinemaTheaterNestedInput = {
    create?: XOR<CinemaSeatGroupCreateWithoutCinemaTheaterInput, CinemaSeatGroupUncheckedCreateWithoutCinemaTheaterInput> | CinemaSeatGroupCreateWithoutCinemaTheaterInput[] | CinemaSeatGroupUncheckedCreateWithoutCinemaTheaterInput[]
    connectOrCreate?: CinemaSeatGroupCreateOrConnectWithoutCinemaTheaterInput | CinemaSeatGroupCreateOrConnectWithoutCinemaTheaterInput[]
    upsert?: CinemaSeatGroupUpsertWithWhereUniqueWithoutCinemaTheaterInput | CinemaSeatGroupUpsertWithWhereUniqueWithoutCinemaTheaterInput[]
    createMany?: CinemaSeatGroupCreateManyCinemaTheaterInputEnvelope
    set?: CinemaSeatGroupWhereUniqueInput | CinemaSeatGroupWhereUniqueInput[]
    disconnect?: CinemaSeatGroupWhereUniqueInput | CinemaSeatGroupWhereUniqueInput[]
    delete?: CinemaSeatGroupWhereUniqueInput | CinemaSeatGroupWhereUniqueInput[]
    connect?: CinemaSeatGroupWhereUniqueInput | CinemaSeatGroupWhereUniqueInput[]
    update?: CinemaSeatGroupUpdateWithWhereUniqueWithoutCinemaTheaterInput | CinemaSeatGroupUpdateWithWhereUniqueWithoutCinemaTheaterInput[]
    updateMany?: CinemaSeatGroupUpdateManyWithWhereWithoutCinemaTheaterInput | CinemaSeatGroupUpdateManyWithWhereWithoutCinemaTheaterInput[]
    deleteMany?: CinemaSeatGroupScalarWhereInput | CinemaSeatGroupScalarWhereInput[]
  }

  export type MovieProjectionUncheckedUpdateManyWithoutCinemaTheaterNestedInput = {
    create?: XOR<MovieProjectionCreateWithoutCinemaTheaterInput, MovieProjectionUncheckedCreateWithoutCinemaTheaterInput> | MovieProjectionCreateWithoutCinemaTheaterInput[] | MovieProjectionUncheckedCreateWithoutCinemaTheaterInput[]
    connectOrCreate?: MovieProjectionCreateOrConnectWithoutCinemaTheaterInput | MovieProjectionCreateOrConnectWithoutCinemaTheaterInput[]
    upsert?: MovieProjectionUpsertWithWhereUniqueWithoutCinemaTheaterInput | MovieProjectionUpsertWithWhereUniqueWithoutCinemaTheaterInput[]
    createMany?: MovieProjectionCreateManyCinemaTheaterInputEnvelope
    set?: MovieProjectionWhereUniqueInput | MovieProjectionWhereUniqueInput[]
    disconnect?: MovieProjectionWhereUniqueInput | MovieProjectionWhereUniqueInput[]
    delete?: MovieProjectionWhereUniqueInput | MovieProjectionWhereUniqueInput[]
    connect?: MovieProjectionWhereUniqueInput | MovieProjectionWhereUniqueInput[]
    update?: MovieProjectionUpdateWithWhereUniqueWithoutCinemaTheaterInput | MovieProjectionUpdateWithWhereUniqueWithoutCinemaTheaterInput[]
    updateMany?: MovieProjectionUpdateManyWithWhereWithoutCinemaTheaterInput | MovieProjectionUpdateManyWithWhereWithoutCinemaTheaterInput[]
    deleteMany?: MovieProjectionScalarWhereInput | MovieProjectionScalarWhereInput[]
  }

  export type CinemaTheaterCreateNestedOneWithoutCinemaSeatGroupsInput = {
    create?: XOR<CinemaTheaterCreateWithoutCinemaSeatGroupsInput, CinemaTheaterUncheckedCreateWithoutCinemaSeatGroupsInput>
    connectOrCreate?: CinemaTheaterCreateOrConnectWithoutCinemaSeatGroupsInput
    connect?: CinemaTheaterWhereUniqueInput
  }

  export type CinemaSeatCreateNestedManyWithoutCinemaSeatGroupInput = {
    create?: XOR<CinemaSeatCreateWithoutCinemaSeatGroupInput, CinemaSeatUncheckedCreateWithoutCinemaSeatGroupInput> | CinemaSeatCreateWithoutCinemaSeatGroupInput[] | CinemaSeatUncheckedCreateWithoutCinemaSeatGroupInput[]
    connectOrCreate?: CinemaSeatCreateOrConnectWithoutCinemaSeatGroupInput | CinemaSeatCreateOrConnectWithoutCinemaSeatGroupInput[]
    createMany?: CinemaSeatCreateManyCinemaSeatGroupInputEnvelope
    connect?: CinemaSeatWhereUniqueInput | CinemaSeatWhereUniqueInput[]
  }

  export type ProjectionPriceCreateNestedManyWithoutCinemaSeatGroupInput = {
    create?: XOR<ProjectionPriceCreateWithoutCinemaSeatGroupInput, ProjectionPriceUncheckedCreateWithoutCinemaSeatGroupInput> | ProjectionPriceCreateWithoutCinemaSeatGroupInput[] | ProjectionPriceUncheckedCreateWithoutCinemaSeatGroupInput[]
    connectOrCreate?: ProjectionPriceCreateOrConnectWithoutCinemaSeatGroupInput | ProjectionPriceCreateOrConnectWithoutCinemaSeatGroupInput[]
    createMany?: ProjectionPriceCreateManyCinemaSeatGroupInputEnvelope
    connect?: ProjectionPriceWhereUniqueInput | ProjectionPriceWhereUniqueInput[]
  }

  export type CinemaSeatUncheckedCreateNestedManyWithoutCinemaSeatGroupInput = {
    create?: XOR<CinemaSeatCreateWithoutCinemaSeatGroupInput, CinemaSeatUncheckedCreateWithoutCinemaSeatGroupInput> | CinemaSeatCreateWithoutCinemaSeatGroupInput[] | CinemaSeatUncheckedCreateWithoutCinemaSeatGroupInput[]
    connectOrCreate?: CinemaSeatCreateOrConnectWithoutCinemaSeatGroupInput | CinemaSeatCreateOrConnectWithoutCinemaSeatGroupInput[]
    createMany?: CinemaSeatCreateManyCinemaSeatGroupInputEnvelope
    connect?: CinemaSeatWhereUniqueInput | CinemaSeatWhereUniqueInput[]
  }

  export type ProjectionPriceUncheckedCreateNestedManyWithoutCinemaSeatGroupInput = {
    create?: XOR<ProjectionPriceCreateWithoutCinemaSeatGroupInput, ProjectionPriceUncheckedCreateWithoutCinemaSeatGroupInput> | ProjectionPriceCreateWithoutCinemaSeatGroupInput[] | ProjectionPriceUncheckedCreateWithoutCinemaSeatGroupInput[]
    connectOrCreate?: ProjectionPriceCreateOrConnectWithoutCinemaSeatGroupInput | ProjectionPriceCreateOrConnectWithoutCinemaSeatGroupInput[]
    createMany?: ProjectionPriceCreateManyCinemaSeatGroupInputEnvelope
    connect?: ProjectionPriceWhereUniqueInput | ProjectionPriceWhereUniqueInput[]
  }

  export type EnumCinemaSeatGroupPositionEnumFieldUpdateOperationsInput = {
    set?: $Enums.CinemaSeatGroupPositionEnum
  }

  export type CinemaTheaterUpdateOneRequiredWithoutCinemaSeatGroupsNestedInput = {
    create?: XOR<CinemaTheaterCreateWithoutCinemaSeatGroupsInput, CinemaTheaterUncheckedCreateWithoutCinemaSeatGroupsInput>
    connectOrCreate?: CinemaTheaterCreateOrConnectWithoutCinemaSeatGroupsInput
    upsert?: CinemaTheaterUpsertWithoutCinemaSeatGroupsInput
    connect?: CinemaTheaterWhereUniqueInput
    update?: XOR<XOR<CinemaTheaterUpdateToOneWithWhereWithoutCinemaSeatGroupsInput, CinemaTheaterUpdateWithoutCinemaSeatGroupsInput>, CinemaTheaterUncheckedUpdateWithoutCinemaSeatGroupsInput>
  }

  export type CinemaSeatUpdateManyWithoutCinemaSeatGroupNestedInput = {
    create?: XOR<CinemaSeatCreateWithoutCinemaSeatGroupInput, CinemaSeatUncheckedCreateWithoutCinemaSeatGroupInput> | CinemaSeatCreateWithoutCinemaSeatGroupInput[] | CinemaSeatUncheckedCreateWithoutCinemaSeatGroupInput[]
    connectOrCreate?: CinemaSeatCreateOrConnectWithoutCinemaSeatGroupInput | CinemaSeatCreateOrConnectWithoutCinemaSeatGroupInput[]
    upsert?: CinemaSeatUpsertWithWhereUniqueWithoutCinemaSeatGroupInput | CinemaSeatUpsertWithWhereUniqueWithoutCinemaSeatGroupInput[]
    createMany?: CinemaSeatCreateManyCinemaSeatGroupInputEnvelope
    set?: CinemaSeatWhereUniqueInput | CinemaSeatWhereUniqueInput[]
    disconnect?: CinemaSeatWhereUniqueInput | CinemaSeatWhereUniqueInput[]
    delete?: CinemaSeatWhereUniqueInput | CinemaSeatWhereUniqueInput[]
    connect?: CinemaSeatWhereUniqueInput | CinemaSeatWhereUniqueInput[]
    update?: CinemaSeatUpdateWithWhereUniqueWithoutCinemaSeatGroupInput | CinemaSeatUpdateWithWhereUniqueWithoutCinemaSeatGroupInput[]
    updateMany?: CinemaSeatUpdateManyWithWhereWithoutCinemaSeatGroupInput | CinemaSeatUpdateManyWithWhereWithoutCinemaSeatGroupInput[]
    deleteMany?: CinemaSeatScalarWhereInput | CinemaSeatScalarWhereInput[]
  }

  export type ProjectionPriceUpdateManyWithoutCinemaSeatGroupNestedInput = {
    create?: XOR<ProjectionPriceCreateWithoutCinemaSeatGroupInput, ProjectionPriceUncheckedCreateWithoutCinemaSeatGroupInput> | ProjectionPriceCreateWithoutCinemaSeatGroupInput[] | ProjectionPriceUncheckedCreateWithoutCinemaSeatGroupInput[]
    connectOrCreate?: ProjectionPriceCreateOrConnectWithoutCinemaSeatGroupInput | ProjectionPriceCreateOrConnectWithoutCinemaSeatGroupInput[]
    upsert?: ProjectionPriceUpsertWithWhereUniqueWithoutCinemaSeatGroupInput | ProjectionPriceUpsertWithWhereUniqueWithoutCinemaSeatGroupInput[]
    createMany?: ProjectionPriceCreateManyCinemaSeatGroupInputEnvelope
    set?: ProjectionPriceWhereUniqueInput | ProjectionPriceWhereUniqueInput[]
    disconnect?: ProjectionPriceWhereUniqueInput | ProjectionPriceWhereUniqueInput[]
    delete?: ProjectionPriceWhereUniqueInput | ProjectionPriceWhereUniqueInput[]
    connect?: ProjectionPriceWhereUniqueInput | ProjectionPriceWhereUniqueInput[]
    update?: ProjectionPriceUpdateWithWhereUniqueWithoutCinemaSeatGroupInput | ProjectionPriceUpdateWithWhereUniqueWithoutCinemaSeatGroupInput[]
    updateMany?: ProjectionPriceUpdateManyWithWhereWithoutCinemaSeatGroupInput | ProjectionPriceUpdateManyWithWhereWithoutCinemaSeatGroupInput[]
    deleteMany?: ProjectionPriceScalarWhereInput | ProjectionPriceScalarWhereInput[]
  }

  export type CinemaSeatUncheckedUpdateManyWithoutCinemaSeatGroupNestedInput = {
    create?: XOR<CinemaSeatCreateWithoutCinemaSeatGroupInput, CinemaSeatUncheckedCreateWithoutCinemaSeatGroupInput> | CinemaSeatCreateWithoutCinemaSeatGroupInput[] | CinemaSeatUncheckedCreateWithoutCinemaSeatGroupInput[]
    connectOrCreate?: CinemaSeatCreateOrConnectWithoutCinemaSeatGroupInput | CinemaSeatCreateOrConnectWithoutCinemaSeatGroupInput[]
    upsert?: CinemaSeatUpsertWithWhereUniqueWithoutCinemaSeatGroupInput | CinemaSeatUpsertWithWhereUniqueWithoutCinemaSeatGroupInput[]
    createMany?: CinemaSeatCreateManyCinemaSeatGroupInputEnvelope
    set?: CinemaSeatWhereUniqueInput | CinemaSeatWhereUniqueInput[]
    disconnect?: CinemaSeatWhereUniqueInput | CinemaSeatWhereUniqueInput[]
    delete?: CinemaSeatWhereUniqueInput | CinemaSeatWhereUniqueInput[]
    connect?: CinemaSeatWhereUniqueInput | CinemaSeatWhereUniqueInput[]
    update?: CinemaSeatUpdateWithWhereUniqueWithoutCinemaSeatGroupInput | CinemaSeatUpdateWithWhereUniqueWithoutCinemaSeatGroupInput[]
    updateMany?: CinemaSeatUpdateManyWithWhereWithoutCinemaSeatGroupInput | CinemaSeatUpdateManyWithWhereWithoutCinemaSeatGroupInput[]
    deleteMany?: CinemaSeatScalarWhereInput | CinemaSeatScalarWhereInput[]
  }

  export type ProjectionPriceUncheckedUpdateManyWithoutCinemaSeatGroupNestedInput = {
    create?: XOR<ProjectionPriceCreateWithoutCinemaSeatGroupInput, ProjectionPriceUncheckedCreateWithoutCinemaSeatGroupInput> | ProjectionPriceCreateWithoutCinemaSeatGroupInput[] | ProjectionPriceUncheckedCreateWithoutCinemaSeatGroupInput[]
    connectOrCreate?: ProjectionPriceCreateOrConnectWithoutCinemaSeatGroupInput | ProjectionPriceCreateOrConnectWithoutCinemaSeatGroupInput[]
    upsert?: ProjectionPriceUpsertWithWhereUniqueWithoutCinemaSeatGroupInput | ProjectionPriceUpsertWithWhereUniqueWithoutCinemaSeatGroupInput[]
    createMany?: ProjectionPriceCreateManyCinemaSeatGroupInputEnvelope
    set?: ProjectionPriceWhereUniqueInput | ProjectionPriceWhereUniqueInput[]
    disconnect?: ProjectionPriceWhereUniqueInput | ProjectionPriceWhereUniqueInput[]
    delete?: ProjectionPriceWhereUniqueInput | ProjectionPriceWhereUniqueInput[]
    connect?: ProjectionPriceWhereUniqueInput | ProjectionPriceWhereUniqueInput[]
    update?: ProjectionPriceUpdateWithWhereUniqueWithoutCinemaSeatGroupInput | ProjectionPriceUpdateWithWhereUniqueWithoutCinemaSeatGroupInput[]
    updateMany?: ProjectionPriceUpdateManyWithWhereWithoutCinemaSeatGroupInput | ProjectionPriceUpdateManyWithWhereWithoutCinemaSeatGroupInput[]
    deleteMany?: ProjectionPriceScalarWhereInput | ProjectionPriceScalarWhereInput[]
  }

  export type CinemaSeatGroupCreateNestedOneWithoutCinemaSeatsInput = {
    create?: XOR<CinemaSeatGroupCreateWithoutCinemaSeatsInput, CinemaSeatGroupUncheckedCreateWithoutCinemaSeatsInput>
    connectOrCreate?: CinemaSeatGroupCreateOrConnectWithoutCinemaSeatsInput
    connect?: CinemaSeatGroupWhereUniqueInput
  }

  export type ReservationSeatsCreateNestedManyWithoutCinemaSeatInput = {
    create?: XOR<ReservationSeatsCreateWithoutCinemaSeatInput, ReservationSeatsUncheckedCreateWithoutCinemaSeatInput> | ReservationSeatsCreateWithoutCinemaSeatInput[] | ReservationSeatsUncheckedCreateWithoutCinemaSeatInput[]
    connectOrCreate?: ReservationSeatsCreateOrConnectWithoutCinemaSeatInput | ReservationSeatsCreateOrConnectWithoutCinemaSeatInput[]
    createMany?: ReservationSeatsCreateManyCinemaSeatInputEnvelope
    connect?: ReservationSeatsWhereUniqueInput | ReservationSeatsWhereUniqueInput[]
  }

  export type ReservationSeatsUncheckedCreateNestedManyWithoutCinemaSeatInput = {
    create?: XOR<ReservationSeatsCreateWithoutCinemaSeatInput, ReservationSeatsUncheckedCreateWithoutCinemaSeatInput> | ReservationSeatsCreateWithoutCinemaSeatInput[] | ReservationSeatsUncheckedCreateWithoutCinemaSeatInput[]
    connectOrCreate?: ReservationSeatsCreateOrConnectWithoutCinemaSeatInput | ReservationSeatsCreateOrConnectWithoutCinemaSeatInput[]
    createMany?: ReservationSeatsCreateManyCinemaSeatInputEnvelope
    connect?: ReservationSeatsWhereUniqueInput | ReservationSeatsWhereUniqueInput[]
  }

  export type CinemaSeatGroupUpdateOneRequiredWithoutCinemaSeatsNestedInput = {
    create?: XOR<CinemaSeatGroupCreateWithoutCinemaSeatsInput, CinemaSeatGroupUncheckedCreateWithoutCinemaSeatsInput>
    connectOrCreate?: CinemaSeatGroupCreateOrConnectWithoutCinemaSeatsInput
    upsert?: CinemaSeatGroupUpsertWithoutCinemaSeatsInput
    connect?: CinemaSeatGroupWhereUniqueInput
    update?: XOR<XOR<CinemaSeatGroupUpdateToOneWithWhereWithoutCinemaSeatsInput, CinemaSeatGroupUpdateWithoutCinemaSeatsInput>, CinemaSeatGroupUncheckedUpdateWithoutCinemaSeatsInput>
  }

  export type ReservationSeatsUpdateManyWithoutCinemaSeatNestedInput = {
    create?: XOR<ReservationSeatsCreateWithoutCinemaSeatInput, ReservationSeatsUncheckedCreateWithoutCinemaSeatInput> | ReservationSeatsCreateWithoutCinemaSeatInput[] | ReservationSeatsUncheckedCreateWithoutCinemaSeatInput[]
    connectOrCreate?: ReservationSeatsCreateOrConnectWithoutCinemaSeatInput | ReservationSeatsCreateOrConnectWithoutCinemaSeatInput[]
    upsert?: ReservationSeatsUpsertWithWhereUniqueWithoutCinemaSeatInput | ReservationSeatsUpsertWithWhereUniqueWithoutCinemaSeatInput[]
    createMany?: ReservationSeatsCreateManyCinemaSeatInputEnvelope
    set?: ReservationSeatsWhereUniqueInput | ReservationSeatsWhereUniqueInput[]
    disconnect?: ReservationSeatsWhereUniqueInput | ReservationSeatsWhereUniqueInput[]
    delete?: ReservationSeatsWhereUniqueInput | ReservationSeatsWhereUniqueInput[]
    connect?: ReservationSeatsWhereUniqueInput | ReservationSeatsWhereUniqueInput[]
    update?: ReservationSeatsUpdateWithWhereUniqueWithoutCinemaSeatInput | ReservationSeatsUpdateWithWhereUniqueWithoutCinemaSeatInput[]
    updateMany?: ReservationSeatsUpdateManyWithWhereWithoutCinemaSeatInput | ReservationSeatsUpdateManyWithWhereWithoutCinemaSeatInput[]
    deleteMany?: ReservationSeatsScalarWhereInput | ReservationSeatsScalarWhereInput[]
  }

  export type ReservationSeatsUncheckedUpdateManyWithoutCinemaSeatNestedInput = {
    create?: XOR<ReservationSeatsCreateWithoutCinemaSeatInput, ReservationSeatsUncheckedCreateWithoutCinemaSeatInput> | ReservationSeatsCreateWithoutCinemaSeatInput[] | ReservationSeatsUncheckedCreateWithoutCinemaSeatInput[]
    connectOrCreate?: ReservationSeatsCreateOrConnectWithoutCinemaSeatInput | ReservationSeatsCreateOrConnectWithoutCinemaSeatInput[]
    upsert?: ReservationSeatsUpsertWithWhereUniqueWithoutCinemaSeatInput | ReservationSeatsUpsertWithWhereUniqueWithoutCinemaSeatInput[]
    createMany?: ReservationSeatsCreateManyCinemaSeatInputEnvelope
    set?: ReservationSeatsWhereUniqueInput | ReservationSeatsWhereUniqueInput[]
    disconnect?: ReservationSeatsWhereUniqueInput | ReservationSeatsWhereUniqueInput[]
    delete?: ReservationSeatsWhereUniqueInput | ReservationSeatsWhereUniqueInput[]
    connect?: ReservationSeatsWhereUniqueInput | ReservationSeatsWhereUniqueInput[]
    update?: ReservationSeatsUpdateWithWhereUniqueWithoutCinemaSeatInput | ReservationSeatsUpdateWithWhereUniqueWithoutCinemaSeatInput[]
    updateMany?: ReservationSeatsUpdateManyWithWhereWithoutCinemaSeatInput | ReservationSeatsUpdateManyWithWhereWithoutCinemaSeatInput[]
    deleteMany?: ReservationSeatsScalarWhereInput | ReservationSeatsScalarWhereInput[]
  }

  export type GenreCreateNestedManyWithoutMoviesInput = {
    create?: XOR<GenreCreateWithoutMoviesInput, GenreUncheckedCreateWithoutMoviesInput> | GenreCreateWithoutMoviesInput[] | GenreUncheckedCreateWithoutMoviesInput[]
    connectOrCreate?: GenreCreateOrConnectWithoutMoviesInput | GenreCreateOrConnectWithoutMoviesInput[]
    connect?: GenreWhereUniqueInput | GenreWhereUniqueInput[]
  }

  export type LanguageCreateNestedOneWithoutOriginalLanguageMoviesInput = {
    create?: XOR<LanguageCreateWithoutOriginalLanguageMoviesInput, LanguageUncheckedCreateWithoutOriginalLanguageMoviesInput>
    connectOrCreate?: LanguageCreateOrConnectWithoutOriginalLanguageMoviesInput
    connect?: LanguageWhereUniqueInput
  }

  export type CountryCreateNestedOneWithoutMoviesInput = {
    create?: XOR<CountryCreateWithoutMoviesInput, CountryUncheckedCreateWithoutMoviesInput>
    connectOrCreate?: CountryCreateOrConnectWithoutMoviesInput
    connect?: CountryWhereUniqueInput
  }

  export type MovieActorCreateNestedManyWithoutMovieInput = {
    create?: XOR<MovieActorCreateWithoutMovieInput, MovieActorUncheckedCreateWithoutMovieInput> | MovieActorCreateWithoutMovieInput[] | MovieActorUncheckedCreateWithoutMovieInput[]
    connectOrCreate?: MovieActorCreateOrConnectWithoutMovieInput | MovieActorCreateOrConnectWithoutMovieInput[]
    createMany?: MovieActorCreateManyMovieInputEnvelope
    connect?: MovieActorWhereUniqueInput | MovieActorWhereUniqueInput[]
  }

  export type MovieDirectorCreateNestedManyWithoutMovieInput = {
    create?: XOR<MovieDirectorCreateWithoutMovieInput, MovieDirectorUncheckedCreateWithoutMovieInput> | MovieDirectorCreateWithoutMovieInput[] | MovieDirectorUncheckedCreateWithoutMovieInput[]
    connectOrCreate?: MovieDirectorCreateOrConnectWithoutMovieInput | MovieDirectorCreateOrConnectWithoutMovieInput[]
    createMany?: MovieDirectorCreateManyMovieInputEnvelope
    connect?: MovieDirectorWhereUniqueInput | MovieDirectorWhereUniqueInput[]
  }

  export type MovieProducerCreateNestedManyWithoutMovieInput = {
    create?: XOR<MovieProducerCreateWithoutMovieInput, MovieProducerUncheckedCreateWithoutMovieInput> | MovieProducerCreateWithoutMovieInput[] | MovieProducerUncheckedCreateWithoutMovieInput[]
    connectOrCreate?: MovieProducerCreateOrConnectWithoutMovieInput | MovieProducerCreateOrConnectWithoutMovieInput[]
    createMany?: MovieProducerCreateManyMovieInputEnvelope
    connect?: MovieProducerWhereUniqueInput | MovieProducerWhereUniqueInput[]
  }

  export type MovieCinemaOverrideCreateNestedManyWithoutMovieInput = {
    create?: XOR<MovieCinemaOverrideCreateWithoutMovieInput, MovieCinemaOverrideUncheckedCreateWithoutMovieInput> | MovieCinemaOverrideCreateWithoutMovieInput[] | MovieCinemaOverrideUncheckedCreateWithoutMovieInput[]
    connectOrCreate?: MovieCinemaOverrideCreateOrConnectWithoutMovieInput | MovieCinemaOverrideCreateOrConnectWithoutMovieInput[]
    createMany?: MovieCinemaOverrideCreateManyMovieInputEnvelope
    connect?: MovieCinemaOverrideWhereUniqueInput | MovieCinemaOverrideWhereUniqueInput[]
  }

  export type MovieProjectionCreateNestedManyWithoutMovieInput = {
    create?: XOR<MovieProjectionCreateWithoutMovieInput, MovieProjectionUncheckedCreateWithoutMovieInput> | MovieProjectionCreateWithoutMovieInput[] | MovieProjectionUncheckedCreateWithoutMovieInput[]
    connectOrCreate?: MovieProjectionCreateOrConnectWithoutMovieInput | MovieProjectionCreateOrConnectWithoutMovieInput[]
    createMany?: MovieProjectionCreateManyMovieInputEnvelope
    connect?: MovieProjectionWhereUniqueInput | MovieProjectionWhereUniqueInput[]
  }

  export type GenreUncheckedCreateNestedManyWithoutMoviesInput = {
    create?: XOR<GenreCreateWithoutMoviesInput, GenreUncheckedCreateWithoutMoviesInput> | GenreCreateWithoutMoviesInput[] | GenreUncheckedCreateWithoutMoviesInput[]
    connectOrCreate?: GenreCreateOrConnectWithoutMoviesInput | GenreCreateOrConnectWithoutMoviesInput[]
    connect?: GenreWhereUniqueInput | GenreWhereUniqueInput[]
  }

  export type MovieActorUncheckedCreateNestedManyWithoutMovieInput = {
    create?: XOR<MovieActorCreateWithoutMovieInput, MovieActorUncheckedCreateWithoutMovieInput> | MovieActorCreateWithoutMovieInput[] | MovieActorUncheckedCreateWithoutMovieInput[]
    connectOrCreate?: MovieActorCreateOrConnectWithoutMovieInput | MovieActorCreateOrConnectWithoutMovieInput[]
    createMany?: MovieActorCreateManyMovieInputEnvelope
    connect?: MovieActorWhereUniqueInput | MovieActorWhereUniqueInput[]
  }

  export type MovieDirectorUncheckedCreateNestedManyWithoutMovieInput = {
    create?: XOR<MovieDirectorCreateWithoutMovieInput, MovieDirectorUncheckedCreateWithoutMovieInput> | MovieDirectorCreateWithoutMovieInput[] | MovieDirectorUncheckedCreateWithoutMovieInput[]
    connectOrCreate?: MovieDirectorCreateOrConnectWithoutMovieInput | MovieDirectorCreateOrConnectWithoutMovieInput[]
    createMany?: MovieDirectorCreateManyMovieInputEnvelope
    connect?: MovieDirectorWhereUniqueInput | MovieDirectorWhereUniqueInput[]
  }

  export type MovieProducerUncheckedCreateNestedManyWithoutMovieInput = {
    create?: XOR<MovieProducerCreateWithoutMovieInput, MovieProducerUncheckedCreateWithoutMovieInput> | MovieProducerCreateWithoutMovieInput[] | MovieProducerUncheckedCreateWithoutMovieInput[]
    connectOrCreate?: MovieProducerCreateOrConnectWithoutMovieInput | MovieProducerCreateOrConnectWithoutMovieInput[]
    createMany?: MovieProducerCreateManyMovieInputEnvelope
    connect?: MovieProducerWhereUniqueInput | MovieProducerWhereUniqueInput[]
  }

  export type MovieCinemaOverrideUncheckedCreateNestedManyWithoutMovieInput = {
    create?: XOR<MovieCinemaOverrideCreateWithoutMovieInput, MovieCinemaOverrideUncheckedCreateWithoutMovieInput> | MovieCinemaOverrideCreateWithoutMovieInput[] | MovieCinemaOverrideUncheckedCreateWithoutMovieInput[]
    connectOrCreate?: MovieCinemaOverrideCreateOrConnectWithoutMovieInput | MovieCinemaOverrideCreateOrConnectWithoutMovieInput[]
    createMany?: MovieCinemaOverrideCreateManyMovieInputEnvelope
    connect?: MovieCinemaOverrideWhereUniqueInput | MovieCinemaOverrideWhereUniqueInput[]
  }

  export type MovieProjectionUncheckedCreateNestedManyWithoutMovieInput = {
    create?: XOR<MovieProjectionCreateWithoutMovieInput, MovieProjectionUncheckedCreateWithoutMovieInput> | MovieProjectionCreateWithoutMovieInput[] | MovieProjectionUncheckedCreateWithoutMovieInput[]
    connectOrCreate?: MovieProjectionCreateOrConnectWithoutMovieInput | MovieProjectionCreateOrConnectWithoutMovieInput[]
    createMany?: MovieProjectionCreateManyMovieInputEnvelope
    connect?: MovieProjectionWhereUniqueInput | MovieProjectionWhereUniqueInput[]
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type EnumInputProviderFieldUpdateOperationsInput = {
    set?: $Enums.InputProvider
  }

  export type GenreUpdateManyWithoutMoviesNestedInput = {
    create?: XOR<GenreCreateWithoutMoviesInput, GenreUncheckedCreateWithoutMoviesInput> | GenreCreateWithoutMoviesInput[] | GenreUncheckedCreateWithoutMoviesInput[]
    connectOrCreate?: GenreCreateOrConnectWithoutMoviesInput | GenreCreateOrConnectWithoutMoviesInput[]
    upsert?: GenreUpsertWithWhereUniqueWithoutMoviesInput | GenreUpsertWithWhereUniqueWithoutMoviesInput[]
    set?: GenreWhereUniqueInput | GenreWhereUniqueInput[]
    disconnect?: GenreWhereUniqueInput | GenreWhereUniqueInput[]
    delete?: GenreWhereUniqueInput | GenreWhereUniqueInput[]
    connect?: GenreWhereUniqueInput | GenreWhereUniqueInput[]
    update?: GenreUpdateWithWhereUniqueWithoutMoviesInput | GenreUpdateWithWhereUniqueWithoutMoviesInput[]
    updateMany?: GenreUpdateManyWithWhereWithoutMoviesInput | GenreUpdateManyWithWhereWithoutMoviesInput[]
    deleteMany?: GenreScalarWhereInput | GenreScalarWhereInput[]
  }

  export type LanguageUpdateOneRequiredWithoutOriginalLanguageMoviesNestedInput = {
    create?: XOR<LanguageCreateWithoutOriginalLanguageMoviesInput, LanguageUncheckedCreateWithoutOriginalLanguageMoviesInput>
    connectOrCreate?: LanguageCreateOrConnectWithoutOriginalLanguageMoviesInput
    upsert?: LanguageUpsertWithoutOriginalLanguageMoviesInput
    connect?: LanguageWhereUniqueInput
    update?: XOR<XOR<LanguageUpdateToOneWithWhereWithoutOriginalLanguageMoviesInput, LanguageUpdateWithoutOriginalLanguageMoviesInput>, LanguageUncheckedUpdateWithoutOriginalLanguageMoviesInput>
  }

  export type CountryUpdateOneRequiredWithoutMoviesNestedInput = {
    create?: XOR<CountryCreateWithoutMoviesInput, CountryUncheckedCreateWithoutMoviesInput>
    connectOrCreate?: CountryCreateOrConnectWithoutMoviesInput
    upsert?: CountryUpsertWithoutMoviesInput
    connect?: CountryWhereUniqueInput
    update?: XOR<XOR<CountryUpdateToOneWithWhereWithoutMoviesInput, CountryUpdateWithoutMoviesInput>, CountryUncheckedUpdateWithoutMoviesInput>
  }

  export type MovieActorUpdateManyWithoutMovieNestedInput = {
    create?: XOR<MovieActorCreateWithoutMovieInput, MovieActorUncheckedCreateWithoutMovieInput> | MovieActorCreateWithoutMovieInput[] | MovieActorUncheckedCreateWithoutMovieInput[]
    connectOrCreate?: MovieActorCreateOrConnectWithoutMovieInput | MovieActorCreateOrConnectWithoutMovieInput[]
    upsert?: MovieActorUpsertWithWhereUniqueWithoutMovieInput | MovieActorUpsertWithWhereUniqueWithoutMovieInput[]
    createMany?: MovieActorCreateManyMovieInputEnvelope
    set?: MovieActorWhereUniqueInput | MovieActorWhereUniqueInput[]
    disconnect?: MovieActorWhereUniqueInput | MovieActorWhereUniqueInput[]
    delete?: MovieActorWhereUniqueInput | MovieActorWhereUniqueInput[]
    connect?: MovieActorWhereUniqueInput | MovieActorWhereUniqueInput[]
    update?: MovieActorUpdateWithWhereUniqueWithoutMovieInput | MovieActorUpdateWithWhereUniqueWithoutMovieInput[]
    updateMany?: MovieActorUpdateManyWithWhereWithoutMovieInput | MovieActorUpdateManyWithWhereWithoutMovieInput[]
    deleteMany?: MovieActorScalarWhereInput | MovieActorScalarWhereInput[]
  }

  export type MovieDirectorUpdateManyWithoutMovieNestedInput = {
    create?: XOR<MovieDirectorCreateWithoutMovieInput, MovieDirectorUncheckedCreateWithoutMovieInput> | MovieDirectorCreateWithoutMovieInput[] | MovieDirectorUncheckedCreateWithoutMovieInput[]
    connectOrCreate?: MovieDirectorCreateOrConnectWithoutMovieInput | MovieDirectorCreateOrConnectWithoutMovieInput[]
    upsert?: MovieDirectorUpsertWithWhereUniqueWithoutMovieInput | MovieDirectorUpsertWithWhereUniqueWithoutMovieInput[]
    createMany?: MovieDirectorCreateManyMovieInputEnvelope
    set?: MovieDirectorWhereUniqueInput | MovieDirectorWhereUniqueInput[]
    disconnect?: MovieDirectorWhereUniqueInput | MovieDirectorWhereUniqueInput[]
    delete?: MovieDirectorWhereUniqueInput | MovieDirectorWhereUniqueInput[]
    connect?: MovieDirectorWhereUniqueInput | MovieDirectorWhereUniqueInput[]
    update?: MovieDirectorUpdateWithWhereUniqueWithoutMovieInput | MovieDirectorUpdateWithWhereUniqueWithoutMovieInput[]
    updateMany?: MovieDirectorUpdateManyWithWhereWithoutMovieInput | MovieDirectorUpdateManyWithWhereWithoutMovieInput[]
    deleteMany?: MovieDirectorScalarWhereInput | MovieDirectorScalarWhereInput[]
  }

  export type MovieProducerUpdateManyWithoutMovieNestedInput = {
    create?: XOR<MovieProducerCreateWithoutMovieInput, MovieProducerUncheckedCreateWithoutMovieInput> | MovieProducerCreateWithoutMovieInput[] | MovieProducerUncheckedCreateWithoutMovieInput[]
    connectOrCreate?: MovieProducerCreateOrConnectWithoutMovieInput | MovieProducerCreateOrConnectWithoutMovieInput[]
    upsert?: MovieProducerUpsertWithWhereUniqueWithoutMovieInput | MovieProducerUpsertWithWhereUniqueWithoutMovieInput[]
    createMany?: MovieProducerCreateManyMovieInputEnvelope
    set?: MovieProducerWhereUniqueInput | MovieProducerWhereUniqueInput[]
    disconnect?: MovieProducerWhereUniqueInput | MovieProducerWhereUniqueInput[]
    delete?: MovieProducerWhereUniqueInput | MovieProducerWhereUniqueInput[]
    connect?: MovieProducerWhereUniqueInput | MovieProducerWhereUniqueInput[]
    update?: MovieProducerUpdateWithWhereUniqueWithoutMovieInput | MovieProducerUpdateWithWhereUniqueWithoutMovieInput[]
    updateMany?: MovieProducerUpdateManyWithWhereWithoutMovieInput | MovieProducerUpdateManyWithWhereWithoutMovieInput[]
    deleteMany?: MovieProducerScalarWhereInput | MovieProducerScalarWhereInput[]
  }

  export type MovieCinemaOverrideUpdateManyWithoutMovieNestedInput = {
    create?: XOR<MovieCinemaOverrideCreateWithoutMovieInput, MovieCinemaOverrideUncheckedCreateWithoutMovieInput> | MovieCinemaOverrideCreateWithoutMovieInput[] | MovieCinemaOverrideUncheckedCreateWithoutMovieInput[]
    connectOrCreate?: MovieCinemaOverrideCreateOrConnectWithoutMovieInput | MovieCinemaOverrideCreateOrConnectWithoutMovieInput[]
    upsert?: MovieCinemaOverrideUpsertWithWhereUniqueWithoutMovieInput | MovieCinemaOverrideUpsertWithWhereUniqueWithoutMovieInput[]
    createMany?: MovieCinemaOverrideCreateManyMovieInputEnvelope
    set?: MovieCinemaOverrideWhereUniqueInput | MovieCinemaOverrideWhereUniqueInput[]
    disconnect?: MovieCinemaOverrideWhereUniqueInput | MovieCinemaOverrideWhereUniqueInput[]
    delete?: MovieCinemaOverrideWhereUniqueInput | MovieCinemaOverrideWhereUniqueInput[]
    connect?: MovieCinemaOverrideWhereUniqueInput | MovieCinemaOverrideWhereUniqueInput[]
    update?: MovieCinemaOverrideUpdateWithWhereUniqueWithoutMovieInput | MovieCinemaOverrideUpdateWithWhereUniqueWithoutMovieInput[]
    updateMany?: MovieCinemaOverrideUpdateManyWithWhereWithoutMovieInput | MovieCinemaOverrideUpdateManyWithWhereWithoutMovieInput[]
    deleteMany?: MovieCinemaOverrideScalarWhereInput | MovieCinemaOverrideScalarWhereInput[]
  }

  export type MovieProjectionUpdateManyWithoutMovieNestedInput = {
    create?: XOR<MovieProjectionCreateWithoutMovieInput, MovieProjectionUncheckedCreateWithoutMovieInput> | MovieProjectionCreateWithoutMovieInput[] | MovieProjectionUncheckedCreateWithoutMovieInput[]
    connectOrCreate?: MovieProjectionCreateOrConnectWithoutMovieInput | MovieProjectionCreateOrConnectWithoutMovieInput[]
    upsert?: MovieProjectionUpsertWithWhereUniqueWithoutMovieInput | MovieProjectionUpsertWithWhereUniqueWithoutMovieInput[]
    createMany?: MovieProjectionCreateManyMovieInputEnvelope
    set?: MovieProjectionWhereUniqueInput | MovieProjectionWhereUniqueInput[]
    disconnect?: MovieProjectionWhereUniqueInput | MovieProjectionWhereUniqueInput[]
    delete?: MovieProjectionWhereUniqueInput | MovieProjectionWhereUniqueInput[]
    connect?: MovieProjectionWhereUniqueInput | MovieProjectionWhereUniqueInput[]
    update?: MovieProjectionUpdateWithWhereUniqueWithoutMovieInput | MovieProjectionUpdateWithWhereUniqueWithoutMovieInput[]
    updateMany?: MovieProjectionUpdateManyWithWhereWithoutMovieInput | MovieProjectionUpdateManyWithWhereWithoutMovieInput[]
    deleteMany?: MovieProjectionScalarWhereInput | MovieProjectionScalarWhereInput[]
  }

  export type GenreUncheckedUpdateManyWithoutMoviesNestedInput = {
    create?: XOR<GenreCreateWithoutMoviesInput, GenreUncheckedCreateWithoutMoviesInput> | GenreCreateWithoutMoviesInput[] | GenreUncheckedCreateWithoutMoviesInput[]
    connectOrCreate?: GenreCreateOrConnectWithoutMoviesInput | GenreCreateOrConnectWithoutMoviesInput[]
    upsert?: GenreUpsertWithWhereUniqueWithoutMoviesInput | GenreUpsertWithWhereUniqueWithoutMoviesInput[]
    set?: GenreWhereUniqueInput | GenreWhereUniqueInput[]
    disconnect?: GenreWhereUniqueInput | GenreWhereUniqueInput[]
    delete?: GenreWhereUniqueInput | GenreWhereUniqueInput[]
    connect?: GenreWhereUniqueInput | GenreWhereUniqueInput[]
    update?: GenreUpdateWithWhereUniqueWithoutMoviesInput | GenreUpdateWithWhereUniqueWithoutMoviesInput[]
    updateMany?: GenreUpdateManyWithWhereWithoutMoviesInput | GenreUpdateManyWithWhereWithoutMoviesInput[]
    deleteMany?: GenreScalarWhereInput | GenreScalarWhereInput[]
  }

  export type MovieActorUncheckedUpdateManyWithoutMovieNestedInput = {
    create?: XOR<MovieActorCreateWithoutMovieInput, MovieActorUncheckedCreateWithoutMovieInput> | MovieActorCreateWithoutMovieInput[] | MovieActorUncheckedCreateWithoutMovieInput[]
    connectOrCreate?: MovieActorCreateOrConnectWithoutMovieInput | MovieActorCreateOrConnectWithoutMovieInput[]
    upsert?: MovieActorUpsertWithWhereUniqueWithoutMovieInput | MovieActorUpsertWithWhereUniqueWithoutMovieInput[]
    createMany?: MovieActorCreateManyMovieInputEnvelope
    set?: MovieActorWhereUniqueInput | MovieActorWhereUniqueInput[]
    disconnect?: MovieActorWhereUniqueInput | MovieActorWhereUniqueInput[]
    delete?: MovieActorWhereUniqueInput | MovieActorWhereUniqueInput[]
    connect?: MovieActorWhereUniqueInput | MovieActorWhereUniqueInput[]
    update?: MovieActorUpdateWithWhereUniqueWithoutMovieInput | MovieActorUpdateWithWhereUniqueWithoutMovieInput[]
    updateMany?: MovieActorUpdateManyWithWhereWithoutMovieInput | MovieActorUpdateManyWithWhereWithoutMovieInput[]
    deleteMany?: MovieActorScalarWhereInput | MovieActorScalarWhereInput[]
  }

  export type MovieDirectorUncheckedUpdateManyWithoutMovieNestedInput = {
    create?: XOR<MovieDirectorCreateWithoutMovieInput, MovieDirectorUncheckedCreateWithoutMovieInput> | MovieDirectorCreateWithoutMovieInput[] | MovieDirectorUncheckedCreateWithoutMovieInput[]
    connectOrCreate?: MovieDirectorCreateOrConnectWithoutMovieInput | MovieDirectorCreateOrConnectWithoutMovieInput[]
    upsert?: MovieDirectorUpsertWithWhereUniqueWithoutMovieInput | MovieDirectorUpsertWithWhereUniqueWithoutMovieInput[]
    createMany?: MovieDirectorCreateManyMovieInputEnvelope
    set?: MovieDirectorWhereUniqueInput | MovieDirectorWhereUniqueInput[]
    disconnect?: MovieDirectorWhereUniqueInput | MovieDirectorWhereUniqueInput[]
    delete?: MovieDirectorWhereUniqueInput | MovieDirectorWhereUniqueInput[]
    connect?: MovieDirectorWhereUniqueInput | MovieDirectorWhereUniqueInput[]
    update?: MovieDirectorUpdateWithWhereUniqueWithoutMovieInput | MovieDirectorUpdateWithWhereUniqueWithoutMovieInput[]
    updateMany?: MovieDirectorUpdateManyWithWhereWithoutMovieInput | MovieDirectorUpdateManyWithWhereWithoutMovieInput[]
    deleteMany?: MovieDirectorScalarWhereInput | MovieDirectorScalarWhereInput[]
  }

  export type MovieProducerUncheckedUpdateManyWithoutMovieNestedInput = {
    create?: XOR<MovieProducerCreateWithoutMovieInput, MovieProducerUncheckedCreateWithoutMovieInput> | MovieProducerCreateWithoutMovieInput[] | MovieProducerUncheckedCreateWithoutMovieInput[]
    connectOrCreate?: MovieProducerCreateOrConnectWithoutMovieInput | MovieProducerCreateOrConnectWithoutMovieInput[]
    upsert?: MovieProducerUpsertWithWhereUniqueWithoutMovieInput | MovieProducerUpsertWithWhereUniqueWithoutMovieInput[]
    createMany?: MovieProducerCreateManyMovieInputEnvelope
    set?: MovieProducerWhereUniqueInput | MovieProducerWhereUniqueInput[]
    disconnect?: MovieProducerWhereUniqueInput | MovieProducerWhereUniqueInput[]
    delete?: MovieProducerWhereUniqueInput | MovieProducerWhereUniqueInput[]
    connect?: MovieProducerWhereUniqueInput | MovieProducerWhereUniqueInput[]
    update?: MovieProducerUpdateWithWhereUniqueWithoutMovieInput | MovieProducerUpdateWithWhereUniqueWithoutMovieInput[]
    updateMany?: MovieProducerUpdateManyWithWhereWithoutMovieInput | MovieProducerUpdateManyWithWhereWithoutMovieInput[]
    deleteMany?: MovieProducerScalarWhereInput | MovieProducerScalarWhereInput[]
  }

  export type MovieCinemaOverrideUncheckedUpdateManyWithoutMovieNestedInput = {
    create?: XOR<MovieCinemaOverrideCreateWithoutMovieInput, MovieCinemaOverrideUncheckedCreateWithoutMovieInput> | MovieCinemaOverrideCreateWithoutMovieInput[] | MovieCinemaOverrideUncheckedCreateWithoutMovieInput[]
    connectOrCreate?: MovieCinemaOverrideCreateOrConnectWithoutMovieInput | MovieCinemaOverrideCreateOrConnectWithoutMovieInput[]
    upsert?: MovieCinemaOverrideUpsertWithWhereUniqueWithoutMovieInput | MovieCinemaOverrideUpsertWithWhereUniqueWithoutMovieInput[]
    createMany?: MovieCinemaOverrideCreateManyMovieInputEnvelope
    set?: MovieCinemaOverrideWhereUniqueInput | MovieCinemaOverrideWhereUniqueInput[]
    disconnect?: MovieCinemaOverrideWhereUniqueInput | MovieCinemaOverrideWhereUniqueInput[]
    delete?: MovieCinemaOverrideWhereUniqueInput | MovieCinemaOverrideWhereUniqueInput[]
    connect?: MovieCinemaOverrideWhereUniqueInput | MovieCinemaOverrideWhereUniqueInput[]
    update?: MovieCinemaOverrideUpdateWithWhereUniqueWithoutMovieInput | MovieCinemaOverrideUpdateWithWhereUniqueWithoutMovieInput[]
    updateMany?: MovieCinemaOverrideUpdateManyWithWhereWithoutMovieInput | MovieCinemaOverrideUpdateManyWithWhereWithoutMovieInput[]
    deleteMany?: MovieCinemaOverrideScalarWhereInput | MovieCinemaOverrideScalarWhereInput[]
  }

  export type MovieProjectionUncheckedUpdateManyWithoutMovieNestedInput = {
    create?: XOR<MovieProjectionCreateWithoutMovieInput, MovieProjectionUncheckedCreateWithoutMovieInput> | MovieProjectionCreateWithoutMovieInput[] | MovieProjectionUncheckedCreateWithoutMovieInput[]
    connectOrCreate?: MovieProjectionCreateOrConnectWithoutMovieInput | MovieProjectionCreateOrConnectWithoutMovieInput[]
    upsert?: MovieProjectionUpsertWithWhereUniqueWithoutMovieInput | MovieProjectionUpsertWithWhereUniqueWithoutMovieInput[]
    createMany?: MovieProjectionCreateManyMovieInputEnvelope
    set?: MovieProjectionWhereUniqueInput | MovieProjectionWhereUniqueInput[]
    disconnect?: MovieProjectionWhereUniqueInput | MovieProjectionWhereUniqueInput[]
    delete?: MovieProjectionWhereUniqueInput | MovieProjectionWhereUniqueInput[]
    connect?: MovieProjectionWhereUniqueInput | MovieProjectionWhereUniqueInput[]
    update?: MovieProjectionUpdateWithWhereUniqueWithoutMovieInput | MovieProjectionUpdateWithWhereUniqueWithoutMovieInput[]
    updateMany?: MovieProjectionUpdateManyWithWhereWithoutMovieInput | MovieProjectionUpdateManyWithWhereWithoutMovieInput[]
    deleteMany?: MovieProjectionScalarWhereInput | MovieProjectionScalarWhereInput[]
  }

  export type MovieActorCreateNestedManyWithoutPersonInput = {
    create?: XOR<MovieActorCreateWithoutPersonInput, MovieActorUncheckedCreateWithoutPersonInput> | MovieActorCreateWithoutPersonInput[] | MovieActorUncheckedCreateWithoutPersonInput[]
    connectOrCreate?: MovieActorCreateOrConnectWithoutPersonInput | MovieActorCreateOrConnectWithoutPersonInput[]
    createMany?: MovieActorCreateManyPersonInputEnvelope
    connect?: MovieActorWhereUniqueInput | MovieActorWhereUniqueInput[]
  }

  export type MovieDirectorCreateNestedManyWithoutPersonInput = {
    create?: XOR<MovieDirectorCreateWithoutPersonInput, MovieDirectorUncheckedCreateWithoutPersonInput> | MovieDirectorCreateWithoutPersonInput[] | MovieDirectorUncheckedCreateWithoutPersonInput[]
    connectOrCreate?: MovieDirectorCreateOrConnectWithoutPersonInput | MovieDirectorCreateOrConnectWithoutPersonInput[]
    createMany?: MovieDirectorCreateManyPersonInputEnvelope
    connect?: MovieDirectorWhereUniqueInput | MovieDirectorWhereUniqueInput[]
  }

  export type MovieProducerCreateNestedManyWithoutPersonInput = {
    create?: XOR<MovieProducerCreateWithoutPersonInput, MovieProducerUncheckedCreateWithoutPersonInput> | MovieProducerCreateWithoutPersonInput[] | MovieProducerUncheckedCreateWithoutPersonInput[]
    connectOrCreate?: MovieProducerCreateOrConnectWithoutPersonInput | MovieProducerCreateOrConnectWithoutPersonInput[]
    createMany?: MovieProducerCreateManyPersonInputEnvelope
    connect?: MovieProducerWhereUniqueInput | MovieProducerWhereUniqueInput[]
  }

  export type MovieActorUncheckedCreateNestedManyWithoutPersonInput = {
    create?: XOR<MovieActorCreateWithoutPersonInput, MovieActorUncheckedCreateWithoutPersonInput> | MovieActorCreateWithoutPersonInput[] | MovieActorUncheckedCreateWithoutPersonInput[]
    connectOrCreate?: MovieActorCreateOrConnectWithoutPersonInput | MovieActorCreateOrConnectWithoutPersonInput[]
    createMany?: MovieActorCreateManyPersonInputEnvelope
    connect?: MovieActorWhereUniqueInput | MovieActorWhereUniqueInput[]
  }

  export type MovieDirectorUncheckedCreateNestedManyWithoutPersonInput = {
    create?: XOR<MovieDirectorCreateWithoutPersonInput, MovieDirectorUncheckedCreateWithoutPersonInput> | MovieDirectorCreateWithoutPersonInput[] | MovieDirectorUncheckedCreateWithoutPersonInput[]
    connectOrCreate?: MovieDirectorCreateOrConnectWithoutPersonInput | MovieDirectorCreateOrConnectWithoutPersonInput[]
    createMany?: MovieDirectorCreateManyPersonInputEnvelope
    connect?: MovieDirectorWhereUniqueInput | MovieDirectorWhereUniqueInput[]
  }

  export type MovieProducerUncheckedCreateNestedManyWithoutPersonInput = {
    create?: XOR<MovieProducerCreateWithoutPersonInput, MovieProducerUncheckedCreateWithoutPersonInput> | MovieProducerCreateWithoutPersonInput[] | MovieProducerUncheckedCreateWithoutPersonInput[]
    connectOrCreate?: MovieProducerCreateOrConnectWithoutPersonInput | MovieProducerCreateOrConnectWithoutPersonInput[]
    createMany?: MovieProducerCreateManyPersonInputEnvelope
    connect?: MovieProducerWhereUniqueInput | MovieProducerWhereUniqueInput[]
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type EnumGenderFieldUpdateOperationsInput = {
    set?: $Enums.Gender
  }

  export type MovieActorUpdateManyWithoutPersonNestedInput = {
    create?: XOR<MovieActorCreateWithoutPersonInput, MovieActorUncheckedCreateWithoutPersonInput> | MovieActorCreateWithoutPersonInput[] | MovieActorUncheckedCreateWithoutPersonInput[]
    connectOrCreate?: MovieActorCreateOrConnectWithoutPersonInput | MovieActorCreateOrConnectWithoutPersonInput[]
    upsert?: MovieActorUpsertWithWhereUniqueWithoutPersonInput | MovieActorUpsertWithWhereUniqueWithoutPersonInput[]
    createMany?: MovieActorCreateManyPersonInputEnvelope
    set?: MovieActorWhereUniqueInput | MovieActorWhereUniqueInput[]
    disconnect?: MovieActorWhereUniqueInput | MovieActorWhereUniqueInput[]
    delete?: MovieActorWhereUniqueInput | MovieActorWhereUniqueInput[]
    connect?: MovieActorWhereUniqueInput | MovieActorWhereUniqueInput[]
    update?: MovieActorUpdateWithWhereUniqueWithoutPersonInput | MovieActorUpdateWithWhereUniqueWithoutPersonInput[]
    updateMany?: MovieActorUpdateManyWithWhereWithoutPersonInput | MovieActorUpdateManyWithWhereWithoutPersonInput[]
    deleteMany?: MovieActorScalarWhereInput | MovieActorScalarWhereInput[]
  }

  export type MovieDirectorUpdateManyWithoutPersonNestedInput = {
    create?: XOR<MovieDirectorCreateWithoutPersonInput, MovieDirectorUncheckedCreateWithoutPersonInput> | MovieDirectorCreateWithoutPersonInput[] | MovieDirectorUncheckedCreateWithoutPersonInput[]
    connectOrCreate?: MovieDirectorCreateOrConnectWithoutPersonInput | MovieDirectorCreateOrConnectWithoutPersonInput[]
    upsert?: MovieDirectorUpsertWithWhereUniqueWithoutPersonInput | MovieDirectorUpsertWithWhereUniqueWithoutPersonInput[]
    createMany?: MovieDirectorCreateManyPersonInputEnvelope
    set?: MovieDirectorWhereUniqueInput | MovieDirectorWhereUniqueInput[]
    disconnect?: MovieDirectorWhereUniqueInput | MovieDirectorWhereUniqueInput[]
    delete?: MovieDirectorWhereUniqueInput | MovieDirectorWhereUniqueInput[]
    connect?: MovieDirectorWhereUniqueInput | MovieDirectorWhereUniqueInput[]
    update?: MovieDirectorUpdateWithWhereUniqueWithoutPersonInput | MovieDirectorUpdateWithWhereUniqueWithoutPersonInput[]
    updateMany?: MovieDirectorUpdateManyWithWhereWithoutPersonInput | MovieDirectorUpdateManyWithWhereWithoutPersonInput[]
    deleteMany?: MovieDirectorScalarWhereInput | MovieDirectorScalarWhereInput[]
  }

  export type MovieProducerUpdateManyWithoutPersonNestedInput = {
    create?: XOR<MovieProducerCreateWithoutPersonInput, MovieProducerUncheckedCreateWithoutPersonInput> | MovieProducerCreateWithoutPersonInput[] | MovieProducerUncheckedCreateWithoutPersonInput[]
    connectOrCreate?: MovieProducerCreateOrConnectWithoutPersonInput | MovieProducerCreateOrConnectWithoutPersonInput[]
    upsert?: MovieProducerUpsertWithWhereUniqueWithoutPersonInput | MovieProducerUpsertWithWhereUniqueWithoutPersonInput[]
    createMany?: MovieProducerCreateManyPersonInputEnvelope
    set?: MovieProducerWhereUniqueInput | MovieProducerWhereUniqueInput[]
    disconnect?: MovieProducerWhereUniqueInput | MovieProducerWhereUniqueInput[]
    delete?: MovieProducerWhereUniqueInput | MovieProducerWhereUniqueInput[]
    connect?: MovieProducerWhereUniqueInput | MovieProducerWhereUniqueInput[]
    update?: MovieProducerUpdateWithWhereUniqueWithoutPersonInput | MovieProducerUpdateWithWhereUniqueWithoutPersonInput[]
    updateMany?: MovieProducerUpdateManyWithWhereWithoutPersonInput | MovieProducerUpdateManyWithWhereWithoutPersonInput[]
    deleteMany?: MovieProducerScalarWhereInput | MovieProducerScalarWhereInput[]
  }

  export type MovieActorUncheckedUpdateManyWithoutPersonNestedInput = {
    create?: XOR<MovieActorCreateWithoutPersonInput, MovieActorUncheckedCreateWithoutPersonInput> | MovieActorCreateWithoutPersonInput[] | MovieActorUncheckedCreateWithoutPersonInput[]
    connectOrCreate?: MovieActorCreateOrConnectWithoutPersonInput | MovieActorCreateOrConnectWithoutPersonInput[]
    upsert?: MovieActorUpsertWithWhereUniqueWithoutPersonInput | MovieActorUpsertWithWhereUniqueWithoutPersonInput[]
    createMany?: MovieActorCreateManyPersonInputEnvelope
    set?: MovieActorWhereUniqueInput | MovieActorWhereUniqueInput[]
    disconnect?: MovieActorWhereUniqueInput | MovieActorWhereUniqueInput[]
    delete?: MovieActorWhereUniqueInput | MovieActorWhereUniqueInput[]
    connect?: MovieActorWhereUniqueInput | MovieActorWhereUniqueInput[]
    update?: MovieActorUpdateWithWhereUniqueWithoutPersonInput | MovieActorUpdateWithWhereUniqueWithoutPersonInput[]
    updateMany?: MovieActorUpdateManyWithWhereWithoutPersonInput | MovieActorUpdateManyWithWhereWithoutPersonInput[]
    deleteMany?: MovieActorScalarWhereInput | MovieActorScalarWhereInput[]
  }

  export type MovieDirectorUncheckedUpdateManyWithoutPersonNestedInput = {
    create?: XOR<MovieDirectorCreateWithoutPersonInput, MovieDirectorUncheckedCreateWithoutPersonInput> | MovieDirectorCreateWithoutPersonInput[] | MovieDirectorUncheckedCreateWithoutPersonInput[]
    connectOrCreate?: MovieDirectorCreateOrConnectWithoutPersonInput | MovieDirectorCreateOrConnectWithoutPersonInput[]
    upsert?: MovieDirectorUpsertWithWhereUniqueWithoutPersonInput | MovieDirectorUpsertWithWhereUniqueWithoutPersonInput[]
    createMany?: MovieDirectorCreateManyPersonInputEnvelope
    set?: MovieDirectorWhereUniqueInput | MovieDirectorWhereUniqueInput[]
    disconnect?: MovieDirectorWhereUniqueInput | MovieDirectorWhereUniqueInput[]
    delete?: MovieDirectorWhereUniqueInput | MovieDirectorWhereUniqueInput[]
    connect?: MovieDirectorWhereUniqueInput | MovieDirectorWhereUniqueInput[]
    update?: MovieDirectorUpdateWithWhereUniqueWithoutPersonInput | MovieDirectorUpdateWithWhereUniqueWithoutPersonInput[]
    updateMany?: MovieDirectorUpdateManyWithWhereWithoutPersonInput | MovieDirectorUpdateManyWithWhereWithoutPersonInput[]
    deleteMany?: MovieDirectorScalarWhereInput | MovieDirectorScalarWhereInput[]
  }

  export type MovieProducerUncheckedUpdateManyWithoutPersonNestedInput = {
    create?: XOR<MovieProducerCreateWithoutPersonInput, MovieProducerUncheckedCreateWithoutPersonInput> | MovieProducerCreateWithoutPersonInput[] | MovieProducerUncheckedCreateWithoutPersonInput[]
    connectOrCreate?: MovieProducerCreateOrConnectWithoutPersonInput | MovieProducerCreateOrConnectWithoutPersonInput[]
    upsert?: MovieProducerUpsertWithWhereUniqueWithoutPersonInput | MovieProducerUpsertWithWhereUniqueWithoutPersonInput[]
    createMany?: MovieProducerCreateManyPersonInputEnvelope
    set?: MovieProducerWhereUniqueInput | MovieProducerWhereUniqueInput[]
    disconnect?: MovieProducerWhereUniqueInput | MovieProducerWhereUniqueInput[]
    delete?: MovieProducerWhereUniqueInput | MovieProducerWhereUniqueInput[]
    connect?: MovieProducerWhereUniqueInput | MovieProducerWhereUniqueInput[]
    update?: MovieProducerUpdateWithWhereUniqueWithoutPersonInput | MovieProducerUpdateWithWhereUniqueWithoutPersonInput[]
    updateMany?: MovieProducerUpdateManyWithWhereWithoutPersonInput | MovieProducerUpdateManyWithWhereWithoutPersonInput[]
    deleteMany?: MovieProducerScalarWhereInput | MovieProducerScalarWhereInput[]
  }

  export type PersonCreateNestedOneWithoutActorInMoviesInput = {
    create?: XOR<PersonCreateWithoutActorInMoviesInput, PersonUncheckedCreateWithoutActorInMoviesInput>
    connectOrCreate?: PersonCreateOrConnectWithoutActorInMoviesInput
    connect?: PersonWhereUniqueInput
  }

  export type MovieCreateNestedOneWithoutActorsInput = {
    create?: XOR<MovieCreateWithoutActorsInput, MovieUncheckedCreateWithoutActorsInput>
    connectOrCreate?: MovieCreateOrConnectWithoutActorsInput
    connect?: MovieWhereUniqueInput
  }

  export type PersonUpdateOneRequiredWithoutActorInMoviesNestedInput = {
    create?: XOR<PersonCreateWithoutActorInMoviesInput, PersonUncheckedCreateWithoutActorInMoviesInput>
    connectOrCreate?: PersonCreateOrConnectWithoutActorInMoviesInput
    upsert?: PersonUpsertWithoutActorInMoviesInput
    connect?: PersonWhereUniqueInput
    update?: XOR<XOR<PersonUpdateToOneWithWhereWithoutActorInMoviesInput, PersonUpdateWithoutActorInMoviesInput>, PersonUncheckedUpdateWithoutActorInMoviesInput>
  }

  export type MovieUpdateOneRequiredWithoutActorsNestedInput = {
    create?: XOR<MovieCreateWithoutActorsInput, MovieUncheckedCreateWithoutActorsInput>
    connectOrCreate?: MovieCreateOrConnectWithoutActorsInput
    upsert?: MovieUpsertWithoutActorsInput
    connect?: MovieWhereUniqueInput
    update?: XOR<XOR<MovieUpdateToOneWithWhereWithoutActorsInput, MovieUpdateWithoutActorsInput>, MovieUncheckedUpdateWithoutActorsInput>
  }

  export type PersonCreateNestedOneWithoutDirectorInMoviesInput = {
    create?: XOR<PersonCreateWithoutDirectorInMoviesInput, PersonUncheckedCreateWithoutDirectorInMoviesInput>
    connectOrCreate?: PersonCreateOrConnectWithoutDirectorInMoviesInput
    connect?: PersonWhereUniqueInput
  }

  export type MovieCreateNestedOneWithoutDirectorsInput = {
    create?: XOR<MovieCreateWithoutDirectorsInput, MovieUncheckedCreateWithoutDirectorsInput>
    connectOrCreate?: MovieCreateOrConnectWithoutDirectorsInput
    connect?: MovieWhereUniqueInput
  }

  export type EnumDirectorTypeFieldUpdateOperationsInput = {
    set?: $Enums.DirectorType
  }

  export type PersonUpdateOneRequiredWithoutDirectorInMoviesNestedInput = {
    create?: XOR<PersonCreateWithoutDirectorInMoviesInput, PersonUncheckedCreateWithoutDirectorInMoviesInput>
    connectOrCreate?: PersonCreateOrConnectWithoutDirectorInMoviesInput
    upsert?: PersonUpsertWithoutDirectorInMoviesInput
    connect?: PersonWhereUniqueInput
    update?: XOR<XOR<PersonUpdateToOneWithWhereWithoutDirectorInMoviesInput, PersonUpdateWithoutDirectorInMoviesInput>, PersonUncheckedUpdateWithoutDirectorInMoviesInput>
  }

  export type MovieUpdateOneRequiredWithoutDirectorsNestedInput = {
    create?: XOR<MovieCreateWithoutDirectorsInput, MovieUncheckedCreateWithoutDirectorsInput>
    connectOrCreate?: MovieCreateOrConnectWithoutDirectorsInput
    upsert?: MovieUpsertWithoutDirectorsInput
    connect?: MovieWhereUniqueInput
    update?: XOR<XOR<MovieUpdateToOneWithWhereWithoutDirectorsInput, MovieUpdateWithoutDirectorsInput>, MovieUncheckedUpdateWithoutDirectorsInput>
  }

  export type PersonCreateNestedOneWithoutProducerInMoviesInput = {
    create?: XOR<PersonCreateWithoutProducerInMoviesInput, PersonUncheckedCreateWithoutProducerInMoviesInput>
    connectOrCreate?: PersonCreateOrConnectWithoutProducerInMoviesInput
    connect?: PersonWhereUniqueInput
  }

  export type MovieCreateNestedOneWithoutProducersInput = {
    create?: XOR<MovieCreateWithoutProducersInput, MovieUncheckedCreateWithoutProducersInput>
    connectOrCreate?: MovieCreateOrConnectWithoutProducersInput
    connect?: MovieWhereUniqueInput
  }

  export type EnumProducerTypeFieldUpdateOperationsInput = {
    set?: $Enums.ProducerType
  }

  export type PersonUpdateOneRequiredWithoutProducerInMoviesNestedInput = {
    create?: XOR<PersonCreateWithoutProducerInMoviesInput, PersonUncheckedCreateWithoutProducerInMoviesInput>
    connectOrCreate?: PersonCreateOrConnectWithoutProducerInMoviesInput
    upsert?: PersonUpsertWithoutProducerInMoviesInput
    connect?: PersonWhereUniqueInput
    update?: XOR<XOR<PersonUpdateToOneWithWhereWithoutProducerInMoviesInput, PersonUpdateWithoutProducerInMoviesInput>, PersonUncheckedUpdateWithoutProducerInMoviesInput>
  }

  export type MovieUpdateOneRequiredWithoutProducersNestedInput = {
    create?: XOR<MovieCreateWithoutProducersInput, MovieUncheckedCreateWithoutProducersInput>
    connectOrCreate?: MovieCreateOrConnectWithoutProducersInput
    upsert?: MovieUpsertWithoutProducersInput
    connect?: MovieWhereUniqueInput
    update?: XOR<XOR<MovieUpdateToOneWithWhereWithoutProducersInput, MovieUpdateWithoutProducersInput>, MovieUncheckedUpdateWithoutProducersInput>
  }

  export type MovieCreateNestedOneWithoutMovieCinemaOverridesInput = {
    create?: XOR<MovieCreateWithoutMovieCinemaOverridesInput, MovieUncheckedCreateWithoutMovieCinemaOverridesInput>
    connectOrCreate?: MovieCreateOrConnectWithoutMovieCinemaOverridesInput
    connect?: MovieWhereUniqueInput
  }

  export type CinemaCreateNestedOneWithoutMovieCinemaOverridesInput = {
    create?: XOR<CinemaCreateWithoutMovieCinemaOverridesInput, CinemaUncheckedCreateWithoutMovieCinemaOverridesInput>
    connectOrCreate?: CinemaCreateOrConnectWithoutMovieCinemaOverridesInput
    connect?: CinemaWhereUniqueInput
  }

  export type MovieUpdateOneRequiredWithoutMovieCinemaOverridesNestedInput = {
    create?: XOR<MovieCreateWithoutMovieCinemaOverridesInput, MovieUncheckedCreateWithoutMovieCinemaOverridesInput>
    connectOrCreate?: MovieCreateOrConnectWithoutMovieCinemaOverridesInput
    upsert?: MovieUpsertWithoutMovieCinemaOverridesInput
    connect?: MovieWhereUniqueInput
    update?: XOR<XOR<MovieUpdateToOneWithWhereWithoutMovieCinemaOverridesInput, MovieUpdateWithoutMovieCinemaOverridesInput>, MovieUncheckedUpdateWithoutMovieCinemaOverridesInput>
  }

  export type CinemaUpdateOneRequiredWithoutMovieCinemaOverridesNestedInput = {
    create?: XOR<CinemaCreateWithoutMovieCinemaOverridesInput, CinemaUncheckedCreateWithoutMovieCinemaOverridesInput>
    connectOrCreate?: CinemaCreateOrConnectWithoutMovieCinemaOverridesInput
    upsert?: CinemaUpsertWithoutMovieCinemaOverridesInput
    connect?: CinemaWhereUniqueInput
    update?: XOR<XOR<CinemaUpdateToOneWithWhereWithoutMovieCinemaOverridesInput, CinemaUpdateWithoutMovieCinemaOverridesInput>, CinemaUncheckedUpdateWithoutMovieCinemaOverridesInput>
  }

  export type MovieCreateNestedOneWithoutMovieProjectionsInput = {
    create?: XOR<MovieCreateWithoutMovieProjectionsInput, MovieUncheckedCreateWithoutMovieProjectionsInput>
    connectOrCreate?: MovieCreateOrConnectWithoutMovieProjectionsInput
    connect?: MovieWhereUniqueInput
  }

  export type CinemaTheaterCreateNestedOneWithoutMovieProjectionsInput = {
    create?: XOR<CinemaTheaterCreateWithoutMovieProjectionsInput, CinemaTheaterUncheckedCreateWithoutMovieProjectionsInput>
    connectOrCreate?: CinemaTheaterCreateOrConnectWithoutMovieProjectionsInput
    connect?: CinemaTheaterWhereUniqueInput
  }

  export type LanguageCreateNestedOneWithoutDubbedLanguageMovieProjectionsInput = {
    create?: XOR<LanguageCreateWithoutDubbedLanguageMovieProjectionsInput, LanguageUncheckedCreateWithoutDubbedLanguageMovieProjectionsInput>
    connectOrCreate?: LanguageCreateOrConnectWithoutDubbedLanguageMovieProjectionsInput
    connect?: LanguageWhereUniqueInput
  }

  export type ProjectionPriceCreateNestedManyWithoutMovieProjectionInput = {
    create?: XOR<ProjectionPriceCreateWithoutMovieProjectionInput, ProjectionPriceUncheckedCreateWithoutMovieProjectionInput> | ProjectionPriceCreateWithoutMovieProjectionInput[] | ProjectionPriceUncheckedCreateWithoutMovieProjectionInput[]
    connectOrCreate?: ProjectionPriceCreateOrConnectWithoutMovieProjectionInput | ProjectionPriceCreateOrConnectWithoutMovieProjectionInput[]
    createMany?: ProjectionPriceCreateManyMovieProjectionInputEnvelope
    connect?: ProjectionPriceWhereUniqueInput | ProjectionPriceWhereUniqueInput[]
  }

  export type ReservationCreateNestedManyWithoutMovieProjectionInput = {
    create?: XOR<ReservationCreateWithoutMovieProjectionInput, ReservationUncheckedCreateWithoutMovieProjectionInput> | ReservationCreateWithoutMovieProjectionInput[] | ReservationUncheckedCreateWithoutMovieProjectionInput[]
    connectOrCreate?: ReservationCreateOrConnectWithoutMovieProjectionInput | ReservationCreateOrConnectWithoutMovieProjectionInput[]
    createMany?: ReservationCreateManyMovieProjectionInputEnvelope
    connect?: ReservationWhereUniqueInput | ReservationWhereUniqueInput[]
  }

  export type ProjectionPriceUncheckedCreateNestedManyWithoutMovieProjectionInput = {
    create?: XOR<ProjectionPriceCreateWithoutMovieProjectionInput, ProjectionPriceUncheckedCreateWithoutMovieProjectionInput> | ProjectionPriceCreateWithoutMovieProjectionInput[] | ProjectionPriceUncheckedCreateWithoutMovieProjectionInput[]
    connectOrCreate?: ProjectionPriceCreateOrConnectWithoutMovieProjectionInput | ProjectionPriceCreateOrConnectWithoutMovieProjectionInput[]
    createMany?: ProjectionPriceCreateManyMovieProjectionInputEnvelope
    connect?: ProjectionPriceWhereUniqueInput | ProjectionPriceWhereUniqueInput[]
  }

  export type ReservationUncheckedCreateNestedManyWithoutMovieProjectionInput = {
    create?: XOR<ReservationCreateWithoutMovieProjectionInput, ReservationUncheckedCreateWithoutMovieProjectionInput> | ReservationCreateWithoutMovieProjectionInput[] | ReservationUncheckedCreateWithoutMovieProjectionInput[]
    connectOrCreate?: ReservationCreateOrConnectWithoutMovieProjectionInput | ReservationCreateOrConnectWithoutMovieProjectionInput[]
    createMany?: ReservationCreateManyMovieProjectionInputEnvelope
    connect?: ReservationWhereUniqueInput | ReservationWhereUniqueInput[]
  }

  export type MovieUpdateOneRequiredWithoutMovieProjectionsNestedInput = {
    create?: XOR<MovieCreateWithoutMovieProjectionsInput, MovieUncheckedCreateWithoutMovieProjectionsInput>
    connectOrCreate?: MovieCreateOrConnectWithoutMovieProjectionsInput
    upsert?: MovieUpsertWithoutMovieProjectionsInput
    connect?: MovieWhereUniqueInput
    update?: XOR<XOR<MovieUpdateToOneWithWhereWithoutMovieProjectionsInput, MovieUpdateWithoutMovieProjectionsInput>, MovieUncheckedUpdateWithoutMovieProjectionsInput>
  }

  export type CinemaTheaterUpdateOneRequiredWithoutMovieProjectionsNestedInput = {
    create?: XOR<CinemaTheaterCreateWithoutMovieProjectionsInput, CinemaTheaterUncheckedCreateWithoutMovieProjectionsInput>
    connectOrCreate?: CinemaTheaterCreateOrConnectWithoutMovieProjectionsInput
    upsert?: CinemaTheaterUpsertWithoutMovieProjectionsInput
    connect?: CinemaTheaterWhereUniqueInput
    update?: XOR<XOR<CinemaTheaterUpdateToOneWithWhereWithoutMovieProjectionsInput, CinemaTheaterUpdateWithoutMovieProjectionsInput>, CinemaTheaterUncheckedUpdateWithoutMovieProjectionsInput>
  }

  export type LanguageUpdateOneWithoutDubbedLanguageMovieProjectionsNestedInput = {
    create?: XOR<LanguageCreateWithoutDubbedLanguageMovieProjectionsInput, LanguageUncheckedCreateWithoutDubbedLanguageMovieProjectionsInput>
    connectOrCreate?: LanguageCreateOrConnectWithoutDubbedLanguageMovieProjectionsInput
    upsert?: LanguageUpsertWithoutDubbedLanguageMovieProjectionsInput
    disconnect?: LanguageWhereInput | boolean
    delete?: LanguageWhereInput | boolean
    connect?: LanguageWhereUniqueInput
    update?: XOR<XOR<LanguageUpdateToOneWithWhereWithoutDubbedLanguageMovieProjectionsInput, LanguageUpdateWithoutDubbedLanguageMovieProjectionsInput>, LanguageUncheckedUpdateWithoutDubbedLanguageMovieProjectionsInput>
  }

  export type ProjectionPriceUpdateManyWithoutMovieProjectionNestedInput = {
    create?: XOR<ProjectionPriceCreateWithoutMovieProjectionInput, ProjectionPriceUncheckedCreateWithoutMovieProjectionInput> | ProjectionPriceCreateWithoutMovieProjectionInput[] | ProjectionPriceUncheckedCreateWithoutMovieProjectionInput[]
    connectOrCreate?: ProjectionPriceCreateOrConnectWithoutMovieProjectionInput | ProjectionPriceCreateOrConnectWithoutMovieProjectionInput[]
    upsert?: ProjectionPriceUpsertWithWhereUniqueWithoutMovieProjectionInput | ProjectionPriceUpsertWithWhereUniqueWithoutMovieProjectionInput[]
    createMany?: ProjectionPriceCreateManyMovieProjectionInputEnvelope
    set?: ProjectionPriceWhereUniqueInput | ProjectionPriceWhereUniqueInput[]
    disconnect?: ProjectionPriceWhereUniqueInput | ProjectionPriceWhereUniqueInput[]
    delete?: ProjectionPriceWhereUniqueInput | ProjectionPriceWhereUniqueInput[]
    connect?: ProjectionPriceWhereUniqueInput | ProjectionPriceWhereUniqueInput[]
    update?: ProjectionPriceUpdateWithWhereUniqueWithoutMovieProjectionInput | ProjectionPriceUpdateWithWhereUniqueWithoutMovieProjectionInput[]
    updateMany?: ProjectionPriceUpdateManyWithWhereWithoutMovieProjectionInput | ProjectionPriceUpdateManyWithWhereWithoutMovieProjectionInput[]
    deleteMany?: ProjectionPriceScalarWhereInput | ProjectionPriceScalarWhereInput[]
  }

  export type ReservationUpdateManyWithoutMovieProjectionNestedInput = {
    create?: XOR<ReservationCreateWithoutMovieProjectionInput, ReservationUncheckedCreateWithoutMovieProjectionInput> | ReservationCreateWithoutMovieProjectionInput[] | ReservationUncheckedCreateWithoutMovieProjectionInput[]
    connectOrCreate?: ReservationCreateOrConnectWithoutMovieProjectionInput | ReservationCreateOrConnectWithoutMovieProjectionInput[]
    upsert?: ReservationUpsertWithWhereUniqueWithoutMovieProjectionInput | ReservationUpsertWithWhereUniqueWithoutMovieProjectionInput[]
    createMany?: ReservationCreateManyMovieProjectionInputEnvelope
    set?: ReservationWhereUniqueInput | ReservationWhereUniqueInput[]
    disconnect?: ReservationWhereUniqueInput | ReservationWhereUniqueInput[]
    delete?: ReservationWhereUniqueInput | ReservationWhereUniqueInput[]
    connect?: ReservationWhereUniqueInput | ReservationWhereUniqueInput[]
    update?: ReservationUpdateWithWhereUniqueWithoutMovieProjectionInput | ReservationUpdateWithWhereUniqueWithoutMovieProjectionInput[]
    updateMany?: ReservationUpdateManyWithWhereWithoutMovieProjectionInput | ReservationUpdateManyWithWhereWithoutMovieProjectionInput[]
    deleteMany?: ReservationScalarWhereInput | ReservationScalarWhereInput[]
  }

  export type ProjectionPriceUncheckedUpdateManyWithoutMovieProjectionNestedInput = {
    create?: XOR<ProjectionPriceCreateWithoutMovieProjectionInput, ProjectionPriceUncheckedCreateWithoutMovieProjectionInput> | ProjectionPriceCreateWithoutMovieProjectionInput[] | ProjectionPriceUncheckedCreateWithoutMovieProjectionInput[]
    connectOrCreate?: ProjectionPriceCreateOrConnectWithoutMovieProjectionInput | ProjectionPriceCreateOrConnectWithoutMovieProjectionInput[]
    upsert?: ProjectionPriceUpsertWithWhereUniqueWithoutMovieProjectionInput | ProjectionPriceUpsertWithWhereUniqueWithoutMovieProjectionInput[]
    createMany?: ProjectionPriceCreateManyMovieProjectionInputEnvelope
    set?: ProjectionPriceWhereUniqueInput | ProjectionPriceWhereUniqueInput[]
    disconnect?: ProjectionPriceWhereUniqueInput | ProjectionPriceWhereUniqueInput[]
    delete?: ProjectionPriceWhereUniqueInput | ProjectionPriceWhereUniqueInput[]
    connect?: ProjectionPriceWhereUniqueInput | ProjectionPriceWhereUniqueInput[]
    update?: ProjectionPriceUpdateWithWhereUniqueWithoutMovieProjectionInput | ProjectionPriceUpdateWithWhereUniqueWithoutMovieProjectionInput[]
    updateMany?: ProjectionPriceUpdateManyWithWhereWithoutMovieProjectionInput | ProjectionPriceUpdateManyWithWhereWithoutMovieProjectionInput[]
    deleteMany?: ProjectionPriceScalarWhereInput | ProjectionPriceScalarWhereInput[]
  }

  export type ReservationUncheckedUpdateManyWithoutMovieProjectionNestedInput = {
    create?: XOR<ReservationCreateWithoutMovieProjectionInput, ReservationUncheckedCreateWithoutMovieProjectionInput> | ReservationCreateWithoutMovieProjectionInput[] | ReservationUncheckedCreateWithoutMovieProjectionInput[]
    connectOrCreate?: ReservationCreateOrConnectWithoutMovieProjectionInput | ReservationCreateOrConnectWithoutMovieProjectionInput[]
    upsert?: ReservationUpsertWithWhereUniqueWithoutMovieProjectionInput | ReservationUpsertWithWhereUniqueWithoutMovieProjectionInput[]
    createMany?: ReservationCreateManyMovieProjectionInputEnvelope
    set?: ReservationWhereUniqueInput | ReservationWhereUniqueInput[]
    disconnect?: ReservationWhereUniqueInput | ReservationWhereUniqueInput[]
    delete?: ReservationWhereUniqueInput | ReservationWhereUniqueInput[]
    connect?: ReservationWhereUniqueInput | ReservationWhereUniqueInput[]
    update?: ReservationUpdateWithWhereUniqueWithoutMovieProjectionInput | ReservationUpdateWithWhereUniqueWithoutMovieProjectionInput[]
    updateMany?: ReservationUpdateManyWithWhereWithoutMovieProjectionInput | ReservationUpdateManyWithWhereWithoutMovieProjectionInput[]
    deleteMany?: ReservationScalarWhereInput | ReservationScalarWhereInput[]
  }

  export type CinemaSeatGroupCreateNestedOneWithoutProjectionPricesInput = {
    create?: XOR<CinemaSeatGroupCreateWithoutProjectionPricesInput, CinemaSeatGroupUncheckedCreateWithoutProjectionPricesInput>
    connectOrCreate?: CinemaSeatGroupCreateOrConnectWithoutProjectionPricesInput
    connect?: CinemaSeatGroupWhereUniqueInput
  }

  export type MovieProjectionCreateNestedOneWithoutProjectionPricesInput = {
    create?: XOR<MovieProjectionCreateWithoutProjectionPricesInput, MovieProjectionUncheckedCreateWithoutProjectionPricesInput>
    connectOrCreate?: MovieProjectionCreateOrConnectWithoutProjectionPricesInput
    connect?: MovieProjectionWhereUniqueInput
  }

  export type EnumPriceTypeFieldUpdateOperationsInput = {
    set?: $Enums.PriceType
  }

  export type DecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type EnumCurrencyCodeFieldUpdateOperationsInput = {
    set?: $Enums.CurrencyCode
  }

  export type CinemaSeatGroupUpdateOneRequiredWithoutProjectionPricesNestedInput = {
    create?: XOR<CinemaSeatGroupCreateWithoutProjectionPricesInput, CinemaSeatGroupUncheckedCreateWithoutProjectionPricesInput>
    connectOrCreate?: CinemaSeatGroupCreateOrConnectWithoutProjectionPricesInput
    upsert?: CinemaSeatGroupUpsertWithoutProjectionPricesInput
    connect?: CinemaSeatGroupWhereUniqueInput
    update?: XOR<XOR<CinemaSeatGroupUpdateToOneWithWhereWithoutProjectionPricesInput, CinemaSeatGroupUpdateWithoutProjectionPricesInput>, CinemaSeatGroupUncheckedUpdateWithoutProjectionPricesInput>
  }

  export type MovieProjectionUpdateOneRequiredWithoutProjectionPricesNestedInput = {
    create?: XOR<MovieProjectionCreateWithoutProjectionPricesInput, MovieProjectionUncheckedCreateWithoutProjectionPricesInput>
    connectOrCreate?: MovieProjectionCreateOrConnectWithoutProjectionPricesInput
    upsert?: MovieProjectionUpsertWithoutProjectionPricesInput
    connect?: MovieProjectionWhereUniqueInput
    update?: XOR<XOR<MovieProjectionUpdateToOneWithWhereWithoutProjectionPricesInput, MovieProjectionUpdateWithoutProjectionPricesInput>, MovieProjectionUncheckedUpdateWithoutProjectionPricesInput>
  }

  export type ReservationSeatsCreateNestedManyWithoutValidatedByAdminUserInput = {
    create?: XOR<ReservationSeatsCreateWithoutValidatedByAdminUserInput, ReservationSeatsUncheckedCreateWithoutValidatedByAdminUserInput> | ReservationSeatsCreateWithoutValidatedByAdminUserInput[] | ReservationSeatsUncheckedCreateWithoutValidatedByAdminUserInput[]
    connectOrCreate?: ReservationSeatsCreateOrConnectWithoutValidatedByAdminUserInput | ReservationSeatsCreateOrConnectWithoutValidatedByAdminUserInput[]
    createMany?: ReservationSeatsCreateManyValidatedByAdminUserInputEnvelope
    connect?: ReservationSeatsWhereUniqueInput | ReservationSeatsWhereUniqueInput[]
  }

  export type ReservationSeatsUncheckedCreateNestedManyWithoutValidatedByAdminUserInput = {
    create?: XOR<ReservationSeatsCreateWithoutValidatedByAdminUserInput, ReservationSeatsUncheckedCreateWithoutValidatedByAdminUserInput> | ReservationSeatsCreateWithoutValidatedByAdminUserInput[] | ReservationSeatsUncheckedCreateWithoutValidatedByAdminUserInput[]
    connectOrCreate?: ReservationSeatsCreateOrConnectWithoutValidatedByAdminUserInput | ReservationSeatsCreateOrConnectWithoutValidatedByAdminUserInput[]
    createMany?: ReservationSeatsCreateManyValidatedByAdminUserInputEnvelope
    connect?: ReservationSeatsWhereUniqueInput | ReservationSeatsWhereUniqueInput[]
  }

  export type EnumAdminRoleFieldUpdateOperationsInput = {
    set?: $Enums.AdminRole
  }

  export type ReservationSeatsUpdateManyWithoutValidatedByAdminUserNestedInput = {
    create?: XOR<ReservationSeatsCreateWithoutValidatedByAdminUserInput, ReservationSeatsUncheckedCreateWithoutValidatedByAdminUserInput> | ReservationSeatsCreateWithoutValidatedByAdminUserInput[] | ReservationSeatsUncheckedCreateWithoutValidatedByAdminUserInput[]
    connectOrCreate?: ReservationSeatsCreateOrConnectWithoutValidatedByAdminUserInput | ReservationSeatsCreateOrConnectWithoutValidatedByAdminUserInput[]
    upsert?: ReservationSeatsUpsertWithWhereUniqueWithoutValidatedByAdminUserInput | ReservationSeatsUpsertWithWhereUniqueWithoutValidatedByAdminUserInput[]
    createMany?: ReservationSeatsCreateManyValidatedByAdminUserInputEnvelope
    set?: ReservationSeatsWhereUniqueInput | ReservationSeatsWhereUniqueInput[]
    disconnect?: ReservationSeatsWhereUniqueInput | ReservationSeatsWhereUniqueInput[]
    delete?: ReservationSeatsWhereUniqueInput | ReservationSeatsWhereUniqueInput[]
    connect?: ReservationSeatsWhereUniqueInput | ReservationSeatsWhereUniqueInput[]
    update?: ReservationSeatsUpdateWithWhereUniqueWithoutValidatedByAdminUserInput | ReservationSeatsUpdateWithWhereUniqueWithoutValidatedByAdminUserInput[]
    updateMany?: ReservationSeatsUpdateManyWithWhereWithoutValidatedByAdminUserInput | ReservationSeatsUpdateManyWithWhereWithoutValidatedByAdminUserInput[]
    deleteMany?: ReservationSeatsScalarWhereInput | ReservationSeatsScalarWhereInput[]
  }

  export type ReservationSeatsUncheckedUpdateManyWithoutValidatedByAdminUserNestedInput = {
    create?: XOR<ReservationSeatsCreateWithoutValidatedByAdminUserInput, ReservationSeatsUncheckedCreateWithoutValidatedByAdminUserInput> | ReservationSeatsCreateWithoutValidatedByAdminUserInput[] | ReservationSeatsUncheckedCreateWithoutValidatedByAdminUserInput[]
    connectOrCreate?: ReservationSeatsCreateOrConnectWithoutValidatedByAdminUserInput | ReservationSeatsCreateOrConnectWithoutValidatedByAdminUserInput[]
    upsert?: ReservationSeatsUpsertWithWhereUniqueWithoutValidatedByAdminUserInput | ReservationSeatsUpsertWithWhereUniqueWithoutValidatedByAdminUserInput[]
    createMany?: ReservationSeatsCreateManyValidatedByAdminUserInputEnvelope
    set?: ReservationSeatsWhereUniqueInput | ReservationSeatsWhereUniqueInput[]
    disconnect?: ReservationSeatsWhereUniqueInput | ReservationSeatsWhereUniqueInput[]
    delete?: ReservationSeatsWhereUniqueInput | ReservationSeatsWhereUniqueInput[]
    connect?: ReservationSeatsWhereUniqueInput | ReservationSeatsWhereUniqueInput[]
    update?: ReservationSeatsUpdateWithWhereUniqueWithoutValidatedByAdminUserInput | ReservationSeatsUpdateWithWhereUniqueWithoutValidatedByAdminUserInput[]
    updateMany?: ReservationSeatsUpdateManyWithWhereWithoutValidatedByAdminUserInput | ReservationSeatsUpdateManyWithWhereWithoutValidatedByAdminUserInput[]
    deleteMany?: ReservationSeatsScalarWhereInput | ReservationSeatsScalarWhereInput[]
  }

  export type MovieProjectionCreateNestedOneWithoutReservationsInput = {
    create?: XOR<MovieProjectionCreateWithoutReservationsInput, MovieProjectionUncheckedCreateWithoutReservationsInput>
    connectOrCreate?: MovieProjectionCreateOrConnectWithoutReservationsInput
    connect?: MovieProjectionWhereUniqueInput
  }

  export type ReservationSeatsCreateNestedManyWithoutReservationInput = {
    create?: XOR<ReservationSeatsCreateWithoutReservationInput, ReservationSeatsUncheckedCreateWithoutReservationInput> | ReservationSeatsCreateWithoutReservationInput[] | ReservationSeatsUncheckedCreateWithoutReservationInput[]
    connectOrCreate?: ReservationSeatsCreateOrConnectWithoutReservationInput | ReservationSeatsCreateOrConnectWithoutReservationInput[]
    createMany?: ReservationSeatsCreateManyReservationInputEnvelope
    connect?: ReservationSeatsWhereUniqueInput | ReservationSeatsWhereUniqueInput[]
  }

  export type ReservationSeatsUncheckedCreateNestedManyWithoutReservationInput = {
    create?: XOR<ReservationSeatsCreateWithoutReservationInput, ReservationSeatsUncheckedCreateWithoutReservationInput> | ReservationSeatsCreateWithoutReservationInput[] | ReservationSeatsUncheckedCreateWithoutReservationInput[]
    connectOrCreate?: ReservationSeatsCreateOrConnectWithoutReservationInput | ReservationSeatsCreateOrConnectWithoutReservationInput[]
    createMany?: ReservationSeatsCreateManyReservationInputEnvelope
    connect?: ReservationSeatsWhereUniqueInput | ReservationSeatsWhereUniqueInput[]
  }

  export type MovieProjectionUpdateOneRequiredWithoutReservationsNestedInput = {
    create?: XOR<MovieProjectionCreateWithoutReservationsInput, MovieProjectionUncheckedCreateWithoutReservationsInput>
    connectOrCreate?: MovieProjectionCreateOrConnectWithoutReservationsInput
    upsert?: MovieProjectionUpsertWithoutReservationsInput
    connect?: MovieProjectionWhereUniqueInput
    update?: XOR<XOR<MovieProjectionUpdateToOneWithWhereWithoutReservationsInput, MovieProjectionUpdateWithoutReservationsInput>, MovieProjectionUncheckedUpdateWithoutReservationsInput>
  }

  export type ReservationSeatsUpdateManyWithoutReservationNestedInput = {
    create?: XOR<ReservationSeatsCreateWithoutReservationInput, ReservationSeatsUncheckedCreateWithoutReservationInput> | ReservationSeatsCreateWithoutReservationInput[] | ReservationSeatsUncheckedCreateWithoutReservationInput[]
    connectOrCreate?: ReservationSeatsCreateOrConnectWithoutReservationInput | ReservationSeatsCreateOrConnectWithoutReservationInput[]
    upsert?: ReservationSeatsUpsertWithWhereUniqueWithoutReservationInput | ReservationSeatsUpsertWithWhereUniqueWithoutReservationInput[]
    createMany?: ReservationSeatsCreateManyReservationInputEnvelope
    set?: ReservationSeatsWhereUniqueInput | ReservationSeatsWhereUniqueInput[]
    disconnect?: ReservationSeatsWhereUniqueInput | ReservationSeatsWhereUniqueInput[]
    delete?: ReservationSeatsWhereUniqueInput | ReservationSeatsWhereUniqueInput[]
    connect?: ReservationSeatsWhereUniqueInput | ReservationSeatsWhereUniqueInput[]
    update?: ReservationSeatsUpdateWithWhereUniqueWithoutReservationInput | ReservationSeatsUpdateWithWhereUniqueWithoutReservationInput[]
    updateMany?: ReservationSeatsUpdateManyWithWhereWithoutReservationInput | ReservationSeatsUpdateManyWithWhereWithoutReservationInput[]
    deleteMany?: ReservationSeatsScalarWhereInput | ReservationSeatsScalarWhereInput[]
  }

  export type ReservationSeatsUncheckedUpdateManyWithoutReservationNestedInput = {
    create?: XOR<ReservationSeatsCreateWithoutReservationInput, ReservationSeatsUncheckedCreateWithoutReservationInput> | ReservationSeatsCreateWithoutReservationInput[] | ReservationSeatsUncheckedCreateWithoutReservationInput[]
    connectOrCreate?: ReservationSeatsCreateOrConnectWithoutReservationInput | ReservationSeatsCreateOrConnectWithoutReservationInput[]
    upsert?: ReservationSeatsUpsertWithWhereUniqueWithoutReservationInput | ReservationSeatsUpsertWithWhereUniqueWithoutReservationInput[]
    createMany?: ReservationSeatsCreateManyReservationInputEnvelope
    set?: ReservationSeatsWhereUniqueInput | ReservationSeatsWhereUniqueInput[]
    disconnect?: ReservationSeatsWhereUniqueInput | ReservationSeatsWhereUniqueInput[]
    delete?: ReservationSeatsWhereUniqueInput | ReservationSeatsWhereUniqueInput[]
    connect?: ReservationSeatsWhereUniqueInput | ReservationSeatsWhereUniqueInput[]
    update?: ReservationSeatsUpdateWithWhereUniqueWithoutReservationInput | ReservationSeatsUpdateWithWhereUniqueWithoutReservationInput[]
    updateMany?: ReservationSeatsUpdateManyWithWhereWithoutReservationInput | ReservationSeatsUpdateManyWithWhereWithoutReservationInput[]
    deleteMany?: ReservationSeatsScalarWhereInput | ReservationSeatsScalarWhereInput[]
  }

  export type ReservationCreateNestedOneWithoutReservationSeatsInput = {
    create?: XOR<ReservationCreateWithoutReservationSeatsInput, ReservationUncheckedCreateWithoutReservationSeatsInput>
    connectOrCreate?: ReservationCreateOrConnectWithoutReservationSeatsInput
    connect?: ReservationWhereUniqueInput
  }

  export type CinemaSeatCreateNestedOneWithoutReservationInput = {
    create?: XOR<CinemaSeatCreateWithoutReservationInput, CinemaSeatUncheckedCreateWithoutReservationInput>
    connectOrCreate?: CinemaSeatCreateOrConnectWithoutReservationInput
    connect?: CinemaSeatWhereUniqueInput
  }

  export type AdminUserCreateNestedOneWithoutValidatedReservationSeatsInput = {
    create?: XOR<AdminUserCreateWithoutValidatedReservationSeatsInput, AdminUserUncheckedCreateWithoutValidatedReservationSeatsInput>
    connectOrCreate?: AdminUserCreateOrConnectWithoutValidatedReservationSeatsInput
    connect?: AdminUserWhereUniqueInput
  }

  export type ReservationUpdateOneRequiredWithoutReservationSeatsNestedInput = {
    create?: XOR<ReservationCreateWithoutReservationSeatsInput, ReservationUncheckedCreateWithoutReservationSeatsInput>
    connectOrCreate?: ReservationCreateOrConnectWithoutReservationSeatsInput
    upsert?: ReservationUpsertWithoutReservationSeatsInput
    connect?: ReservationWhereUniqueInput
    update?: XOR<XOR<ReservationUpdateToOneWithWhereWithoutReservationSeatsInput, ReservationUpdateWithoutReservationSeatsInput>, ReservationUncheckedUpdateWithoutReservationSeatsInput>
  }

  export type CinemaSeatUpdateOneRequiredWithoutReservationNestedInput = {
    create?: XOR<CinemaSeatCreateWithoutReservationInput, CinemaSeatUncheckedCreateWithoutReservationInput>
    connectOrCreate?: CinemaSeatCreateOrConnectWithoutReservationInput
    upsert?: CinemaSeatUpsertWithoutReservationInput
    connect?: CinemaSeatWhereUniqueInput
    update?: XOR<XOR<CinemaSeatUpdateToOneWithWhereWithoutReservationInput, CinemaSeatUpdateWithoutReservationInput>, CinemaSeatUncheckedUpdateWithoutReservationInput>
  }

  export type AdminUserUpdateOneWithoutValidatedReservationSeatsNestedInput = {
    create?: XOR<AdminUserCreateWithoutValidatedReservationSeatsInput, AdminUserUncheckedCreateWithoutValidatedReservationSeatsInput>
    connectOrCreate?: AdminUserCreateOrConnectWithoutValidatedReservationSeatsInput
    upsert?: AdminUserUpsertWithoutValidatedReservationSeatsInput
    disconnect?: AdminUserWhereInput | boolean
    delete?: AdminUserWhereInput | boolean
    connect?: AdminUserWhereUniqueInput
    update?: XOR<XOR<AdminUserUpdateToOneWithWhereWithoutValidatedReservationSeatsInput, AdminUserUpdateWithoutValidatedReservationSeatsInput>, AdminUserUncheckedUpdateWithoutValidatedReservationSeatsInput>
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedUuidFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedUuidFilter<$PrismaModel> | string
  }

  export type NestedUuidWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedUuidWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedDecimalNullableFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }
  export type NestedJsonFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<NestedJsonFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedDecimalNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedDecimalNullableFilter<$PrismaModel>
    _sum?: NestedDecimalNullableFilter<$PrismaModel>
    _min?: NestedDecimalNullableFilter<$PrismaModel>
    _max?: NestedDecimalNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedEnumCinemaSeatGroupPositionEnumFilter<$PrismaModel = never> = {
    equals?: $Enums.CinemaSeatGroupPositionEnum | EnumCinemaSeatGroupPositionEnumFieldRefInput<$PrismaModel>
    in?: $Enums.CinemaSeatGroupPositionEnum[] | ListEnumCinemaSeatGroupPositionEnumFieldRefInput<$PrismaModel>
    notIn?: $Enums.CinemaSeatGroupPositionEnum[] | ListEnumCinemaSeatGroupPositionEnumFieldRefInput<$PrismaModel>
    not?: NestedEnumCinemaSeatGroupPositionEnumFilter<$PrismaModel> | $Enums.CinemaSeatGroupPositionEnum
  }

  export type NestedEnumCinemaSeatGroupPositionEnumWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CinemaSeatGroupPositionEnum | EnumCinemaSeatGroupPositionEnumFieldRefInput<$PrismaModel>
    in?: $Enums.CinemaSeatGroupPositionEnum[] | ListEnumCinemaSeatGroupPositionEnumFieldRefInput<$PrismaModel>
    notIn?: $Enums.CinemaSeatGroupPositionEnum[] | ListEnumCinemaSeatGroupPositionEnumFieldRefInput<$PrismaModel>
    not?: NestedEnumCinemaSeatGroupPositionEnumWithAggregatesFilter<$PrismaModel> | $Enums.CinemaSeatGroupPositionEnum
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCinemaSeatGroupPositionEnumFilter<$PrismaModel>
    _max?: NestedEnumCinemaSeatGroupPositionEnumFilter<$PrismaModel>
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedEnumInputProviderFilter<$PrismaModel = never> = {
    equals?: $Enums.InputProvider | EnumInputProviderFieldRefInput<$PrismaModel>
    in?: $Enums.InputProvider[] | ListEnumInputProviderFieldRefInput<$PrismaModel>
    notIn?: $Enums.InputProvider[] | ListEnumInputProviderFieldRefInput<$PrismaModel>
    not?: NestedEnumInputProviderFilter<$PrismaModel> | $Enums.InputProvider
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedEnumInputProviderWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.InputProvider | EnumInputProviderFieldRefInput<$PrismaModel>
    in?: $Enums.InputProvider[] | ListEnumInputProviderFieldRefInput<$PrismaModel>
    notIn?: $Enums.InputProvider[] | ListEnumInputProviderFieldRefInput<$PrismaModel>
    not?: NestedEnumInputProviderWithAggregatesFilter<$PrismaModel> | $Enums.InputProvider
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumInputProviderFilter<$PrismaModel>
    _max?: NestedEnumInputProviderFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedEnumGenderFilter<$PrismaModel = never> = {
    equals?: $Enums.Gender | EnumGenderFieldRefInput<$PrismaModel>
    in?: $Enums.Gender[] | ListEnumGenderFieldRefInput<$PrismaModel>
    notIn?: $Enums.Gender[] | ListEnumGenderFieldRefInput<$PrismaModel>
    not?: NestedEnumGenderFilter<$PrismaModel> | $Enums.Gender
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedEnumGenderWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Gender | EnumGenderFieldRefInput<$PrismaModel>
    in?: $Enums.Gender[] | ListEnumGenderFieldRefInput<$PrismaModel>
    notIn?: $Enums.Gender[] | ListEnumGenderFieldRefInput<$PrismaModel>
    not?: NestedEnumGenderWithAggregatesFilter<$PrismaModel> | $Enums.Gender
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumGenderFilter<$PrismaModel>
    _max?: NestedEnumGenderFilter<$PrismaModel>
  }

  export type NestedEnumDirectorTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.DirectorType | EnumDirectorTypeFieldRefInput<$PrismaModel>
    in?: $Enums.DirectorType[] | ListEnumDirectorTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.DirectorType[] | ListEnumDirectorTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumDirectorTypeFilter<$PrismaModel> | $Enums.DirectorType
  }

  export type NestedEnumDirectorTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.DirectorType | EnumDirectorTypeFieldRefInput<$PrismaModel>
    in?: $Enums.DirectorType[] | ListEnumDirectorTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.DirectorType[] | ListEnumDirectorTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumDirectorTypeWithAggregatesFilter<$PrismaModel> | $Enums.DirectorType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumDirectorTypeFilter<$PrismaModel>
    _max?: NestedEnumDirectorTypeFilter<$PrismaModel>
  }

  export type NestedEnumProducerTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ProducerType | EnumProducerTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ProducerType[] | ListEnumProducerTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ProducerType[] | ListEnumProducerTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumProducerTypeFilter<$PrismaModel> | $Enums.ProducerType
  }

  export type NestedEnumProducerTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ProducerType | EnumProducerTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ProducerType[] | ListEnumProducerTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ProducerType[] | ListEnumProducerTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumProducerTypeWithAggregatesFilter<$PrismaModel> | $Enums.ProducerType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumProducerTypeFilter<$PrismaModel>
    _max?: NestedEnumProducerTypeFilter<$PrismaModel>
  }

  export type NestedEnumPriceTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.PriceType | EnumPriceTypeFieldRefInput<$PrismaModel>
    in?: $Enums.PriceType[] | ListEnumPriceTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.PriceType[] | ListEnumPriceTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumPriceTypeFilter<$PrismaModel> | $Enums.PriceType
  }

  export type NestedDecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type NestedEnumCurrencyCodeFilter<$PrismaModel = never> = {
    equals?: $Enums.CurrencyCode | EnumCurrencyCodeFieldRefInput<$PrismaModel>
    in?: $Enums.CurrencyCode[] | ListEnumCurrencyCodeFieldRefInput<$PrismaModel>
    notIn?: $Enums.CurrencyCode[] | ListEnumCurrencyCodeFieldRefInput<$PrismaModel>
    not?: NestedEnumCurrencyCodeFilter<$PrismaModel> | $Enums.CurrencyCode
  }

  export type NestedEnumPriceTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PriceType | EnumPriceTypeFieldRefInput<$PrismaModel>
    in?: $Enums.PriceType[] | ListEnumPriceTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.PriceType[] | ListEnumPriceTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumPriceTypeWithAggregatesFilter<$PrismaModel> | $Enums.PriceType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPriceTypeFilter<$PrismaModel>
    _max?: NestedEnumPriceTypeFilter<$PrismaModel>
  }

  export type NestedDecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type NestedEnumCurrencyCodeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CurrencyCode | EnumCurrencyCodeFieldRefInput<$PrismaModel>
    in?: $Enums.CurrencyCode[] | ListEnumCurrencyCodeFieldRefInput<$PrismaModel>
    notIn?: $Enums.CurrencyCode[] | ListEnumCurrencyCodeFieldRefInput<$PrismaModel>
    not?: NestedEnumCurrencyCodeWithAggregatesFilter<$PrismaModel> | $Enums.CurrencyCode
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCurrencyCodeFilter<$PrismaModel>
    _max?: NestedEnumCurrencyCodeFilter<$PrismaModel>
  }

  export type NestedEnumAdminRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.AdminRole | EnumAdminRoleFieldRefInput<$PrismaModel>
    in?: $Enums.AdminRole[] | ListEnumAdminRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.AdminRole[] | ListEnumAdminRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumAdminRoleFilter<$PrismaModel> | $Enums.AdminRole
  }

  export type NestedEnumAdminRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AdminRole | EnumAdminRoleFieldRefInput<$PrismaModel>
    in?: $Enums.AdminRole[] | ListEnumAdminRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.AdminRole[] | ListEnumAdminRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumAdminRoleWithAggregatesFilter<$PrismaModel> | $Enums.AdminRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAdminRoleFilter<$PrismaModel>
    _max?: NestedEnumAdminRoleFilter<$PrismaModel>
  }

  export type NestedUuidNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedUuidNullableFilter<$PrismaModel> | string | null
  }

  export type NestedUuidNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedUuidNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type MovieCreateWithoutGenresInput = {
    id?: string
    title?: string | null
    originalTitle: string
    localizedTitle?: string | null
    plot: string
    localizedPlot?: string | null
    runtimeMinutes: number
    posterImages?: JsonNullValueInput | InputJsonValue
    videos?: JsonNullValueInput | InputJsonValue
    rating: number
    releaseDate: Date | string
    createdAt?: Date | string
    updatedAt: Date | string
    externalId: string
    externalType: $Enums.InputProvider
    additionalData?: JsonNullValueInput | InputJsonValue
    originalLanguage: LanguageCreateNestedOneWithoutOriginalLanguageMoviesInput
    countryOfOrigin: CountryCreateNestedOneWithoutMoviesInput
    actors?: MovieActorCreateNestedManyWithoutMovieInput
    directors?: MovieDirectorCreateNestedManyWithoutMovieInput
    producers?: MovieProducerCreateNestedManyWithoutMovieInput
    movieCinemaOverrides?: MovieCinemaOverrideCreateNestedManyWithoutMovieInput
    movieProjections?: MovieProjectionCreateNestedManyWithoutMovieInput
  }

  export type MovieUncheckedCreateWithoutGenresInput = {
    id?: string
    title?: string | null
    originalTitle: string
    localizedTitle?: string | null
    plot: string
    localizedPlot?: string | null
    runtimeMinutes: number
    originalLanguageId: string
    countryOfOriginId: string
    posterImages?: JsonNullValueInput | InputJsonValue
    videos?: JsonNullValueInput | InputJsonValue
    rating: number
    releaseDate: Date | string
    createdAt?: Date | string
    updatedAt: Date | string
    externalId: string
    externalType: $Enums.InputProvider
    additionalData?: JsonNullValueInput | InputJsonValue
    actors?: MovieActorUncheckedCreateNestedManyWithoutMovieInput
    directors?: MovieDirectorUncheckedCreateNestedManyWithoutMovieInput
    producers?: MovieProducerUncheckedCreateNestedManyWithoutMovieInput
    movieCinemaOverrides?: MovieCinemaOverrideUncheckedCreateNestedManyWithoutMovieInput
    movieProjections?: MovieProjectionUncheckedCreateNestedManyWithoutMovieInput
  }

  export type MovieCreateOrConnectWithoutGenresInput = {
    where: MovieWhereUniqueInput
    create: XOR<MovieCreateWithoutGenresInput, MovieUncheckedCreateWithoutGenresInput>
  }

  export type MovieUpsertWithWhereUniqueWithoutGenresInput = {
    where: MovieWhereUniqueInput
    update: XOR<MovieUpdateWithoutGenresInput, MovieUncheckedUpdateWithoutGenresInput>
    create: XOR<MovieCreateWithoutGenresInput, MovieUncheckedCreateWithoutGenresInput>
  }

  export type MovieUpdateWithWhereUniqueWithoutGenresInput = {
    where: MovieWhereUniqueInput
    data: XOR<MovieUpdateWithoutGenresInput, MovieUncheckedUpdateWithoutGenresInput>
  }

  export type MovieUpdateManyWithWhereWithoutGenresInput = {
    where: MovieScalarWhereInput
    data: XOR<MovieUpdateManyMutationInput, MovieUncheckedUpdateManyWithoutGenresInput>
  }

  export type MovieScalarWhereInput = {
    AND?: MovieScalarWhereInput | MovieScalarWhereInput[]
    OR?: MovieScalarWhereInput[]
    NOT?: MovieScalarWhereInput | MovieScalarWhereInput[]
    id?: UuidFilter<"Movie"> | string
    title?: StringNullableFilter<"Movie"> | string | null
    originalTitle?: StringFilter<"Movie"> | string
    localizedTitle?: StringNullableFilter<"Movie"> | string | null
    plot?: StringFilter<"Movie"> | string
    localizedPlot?: StringNullableFilter<"Movie"> | string | null
    runtimeMinutes?: IntFilter<"Movie"> | number
    originalLanguageId?: StringFilter<"Movie"> | string
    countryOfOriginId?: StringFilter<"Movie"> | string
    posterImages?: JsonFilter<"Movie">
    videos?: JsonFilter<"Movie">
    rating?: IntFilter<"Movie"> | number
    releaseDate?: DateTimeFilter<"Movie"> | Date | string
    createdAt?: DateTimeFilter<"Movie"> | Date | string
    updatedAt?: DateTimeFilter<"Movie"> | Date | string
    externalId?: StringFilter<"Movie"> | string
    externalType?: EnumInputProviderFilter<"Movie"> | $Enums.InputProvider
    additionalData?: JsonFilter<"Movie">
  }

  export type MovieCreateWithoutOriginalLanguageInput = {
    id?: string
    title?: string | null
    originalTitle: string
    localizedTitle?: string | null
    plot: string
    localizedPlot?: string | null
    runtimeMinutes: number
    posterImages?: JsonNullValueInput | InputJsonValue
    videos?: JsonNullValueInput | InputJsonValue
    rating: number
    releaseDate: Date | string
    createdAt?: Date | string
    updatedAt: Date | string
    externalId: string
    externalType: $Enums.InputProvider
    additionalData?: JsonNullValueInput | InputJsonValue
    genres?: GenreCreateNestedManyWithoutMoviesInput
    countryOfOrigin: CountryCreateNestedOneWithoutMoviesInput
    actors?: MovieActorCreateNestedManyWithoutMovieInput
    directors?: MovieDirectorCreateNestedManyWithoutMovieInput
    producers?: MovieProducerCreateNestedManyWithoutMovieInput
    movieCinemaOverrides?: MovieCinemaOverrideCreateNestedManyWithoutMovieInput
    movieProjections?: MovieProjectionCreateNestedManyWithoutMovieInput
  }

  export type MovieUncheckedCreateWithoutOriginalLanguageInput = {
    id?: string
    title?: string | null
    originalTitle: string
    localizedTitle?: string | null
    plot: string
    localizedPlot?: string | null
    runtimeMinutes: number
    countryOfOriginId: string
    posterImages?: JsonNullValueInput | InputJsonValue
    videos?: JsonNullValueInput | InputJsonValue
    rating: number
    releaseDate: Date | string
    createdAt?: Date | string
    updatedAt: Date | string
    externalId: string
    externalType: $Enums.InputProvider
    additionalData?: JsonNullValueInput | InputJsonValue
    genres?: GenreUncheckedCreateNestedManyWithoutMoviesInput
    actors?: MovieActorUncheckedCreateNestedManyWithoutMovieInput
    directors?: MovieDirectorUncheckedCreateNestedManyWithoutMovieInput
    producers?: MovieProducerUncheckedCreateNestedManyWithoutMovieInput
    movieCinemaOverrides?: MovieCinemaOverrideUncheckedCreateNestedManyWithoutMovieInput
    movieProjections?: MovieProjectionUncheckedCreateNestedManyWithoutMovieInput
  }

  export type MovieCreateOrConnectWithoutOriginalLanguageInput = {
    where: MovieWhereUniqueInput
    create: XOR<MovieCreateWithoutOriginalLanguageInput, MovieUncheckedCreateWithoutOriginalLanguageInput>
  }

  export type MovieCreateManyOriginalLanguageInputEnvelope = {
    data: MovieCreateManyOriginalLanguageInput | MovieCreateManyOriginalLanguageInput[]
    skipDuplicates?: boolean
  }

  export type MovieProjectionCreateWithoutDubbedLanguageInput = {
    id?: string
    projectionDateTime: Date | string
    createdAt?: Date | string
    updatedAt: Date | string
    options?: JsonNullValueInput | InputJsonValue
    movie: MovieCreateNestedOneWithoutMovieProjectionsInput
    cinemaTheater: CinemaTheaterCreateNestedOneWithoutMovieProjectionsInput
    projectionPrices?: ProjectionPriceCreateNestedManyWithoutMovieProjectionInput
    reservations?: ReservationCreateNestedManyWithoutMovieProjectionInput
  }

  export type MovieProjectionUncheckedCreateWithoutDubbedLanguageInput = {
    id?: string
    movieId: string
    cinemaTheaterId: string
    projectionDateTime: Date | string
    createdAt?: Date | string
    updatedAt: Date | string
    options?: JsonNullValueInput | InputJsonValue
    projectionPrices?: ProjectionPriceUncheckedCreateNestedManyWithoutMovieProjectionInput
    reservations?: ReservationUncheckedCreateNestedManyWithoutMovieProjectionInput
  }

  export type MovieProjectionCreateOrConnectWithoutDubbedLanguageInput = {
    where: MovieProjectionWhereUniqueInput
    create: XOR<MovieProjectionCreateWithoutDubbedLanguageInput, MovieProjectionUncheckedCreateWithoutDubbedLanguageInput>
  }

  export type MovieProjectionCreateManyDubbedLanguageInputEnvelope = {
    data: MovieProjectionCreateManyDubbedLanguageInput | MovieProjectionCreateManyDubbedLanguageInput[]
    skipDuplicates?: boolean
  }

  export type MovieUpsertWithWhereUniqueWithoutOriginalLanguageInput = {
    where: MovieWhereUniqueInput
    update: XOR<MovieUpdateWithoutOriginalLanguageInput, MovieUncheckedUpdateWithoutOriginalLanguageInput>
    create: XOR<MovieCreateWithoutOriginalLanguageInput, MovieUncheckedCreateWithoutOriginalLanguageInput>
  }

  export type MovieUpdateWithWhereUniqueWithoutOriginalLanguageInput = {
    where: MovieWhereUniqueInput
    data: XOR<MovieUpdateWithoutOriginalLanguageInput, MovieUncheckedUpdateWithoutOriginalLanguageInput>
  }

  export type MovieUpdateManyWithWhereWithoutOriginalLanguageInput = {
    where: MovieScalarWhereInput
    data: XOR<MovieUpdateManyMutationInput, MovieUncheckedUpdateManyWithoutOriginalLanguageInput>
  }

  export type MovieProjectionUpsertWithWhereUniqueWithoutDubbedLanguageInput = {
    where: MovieProjectionWhereUniqueInput
    update: XOR<MovieProjectionUpdateWithoutDubbedLanguageInput, MovieProjectionUncheckedUpdateWithoutDubbedLanguageInput>
    create: XOR<MovieProjectionCreateWithoutDubbedLanguageInput, MovieProjectionUncheckedCreateWithoutDubbedLanguageInput>
  }

  export type MovieProjectionUpdateWithWhereUniqueWithoutDubbedLanguageInput = {
    where: MovieProjectionWhereUniqueInput
    data: XOR<MovieProjectionUpdateWithoutDubbedLanguageInput, MovieProjectionUncheckedUpdateWithoutDubbedLanguageInput>
  }

  export type MovieProjectionUpdateManyWithWhereWithoutDubbedLanguageInput = {
    where: MovieProjectionScalarWhereInput
    data: XOR<MovieProjectionUpdateManyMutationInput, MovieProjectionUncheckedUpdateManyWithoutDubbedLanguageInput>
  }

  export type MovieProjectionScalarWhereInput = {
    AND?: MovieProjectionScalarWhereInput | MovieProjectionScalarWhereInput[]
    OR?: MovieProjectionScalarWhereInput[]
    NOT?: MovieProjectionScalarWhereInput | MovieProjectionScalarWhereInput[]
    id?: UuidFilter<"MovieProjection"> | string
    movieId?: UuidFilter<"MovieProjection"> | string
    cinemaTheaterId?: UuidFilter<"MovieProjection"> | string
    projectionDateTime?: DateTimeFilter<"MovieProjection"> | Date | string
    createdAt?: DateTimeFilter<"MovieProjection"> | Date | string
    updatedAt?: DateTimeFilter<"MovieProjection"> | Date | string
    dubbedLanguageId?: StringNullableFilter<"MovieProjection"> | string | null
    options?: JsonFilter<"MovieProjection">
  }

  export type CityCreateWithoutCountryInput = {
    id?: string
    cityCode: string
    name: string
    postalCode: string
    cinemas?: CinemaCreateNestedManyWithoutCityInput
  }

  export type CityUncheckedCreateWithoutCountryInput = {
    id?: string
    cityCode: string
    name: string
    postalCode: string
    cinemas?: CinemaUncheckedCreateNestedManyWithoutCityInput
  }

  export type CityCreateOrConnectWithoutCountryInput = {
    where: CityWhereUniqueInput
    create: XOR<CityCreateWithoutCountryInput, CityUncheckedCreateWithoutCountryInput>
  }

  export type CityCreateManyCountryInputEnvelope = {
    data: CityCreateManyCountryInput | CityCreateManyCountryInput[]
    skipDuplicates?: boolean
  }

  export type MovieCreateWithoutCountryOfOriginInput = {
    id?: string
    title?: string | null
    originalTitle: string
    localizedTitle?: string | null
    plot: string
    localizedPlot?: string | null
    runtimeMinutes: number
    posterImages?: JsonNullValueInput | InputJsonValue
    videos?: JsonNullValueInput | InputJsonValue
    rating: number
    releaseDate: Date | string
    createdAt?: Date | string
    updatedAt: Date | string
    externalId: string
    externalType: $Enums.InputProvider
    additionalData?: JsonNullValueInput | InputJsonValue
    genres?: GenreCreateNestedManyWithoutMoviesInput
    originalLanguage: LanguageCreateNestedOneWithoutOriginalLanguageMoviesInput
    actors?: MovieActorCreateNestedManyWithoutMovieInput
    directors?: MovieDirectorCreateNestedManyWithoutMovieInput
    producers?: MovieProducerCreateNestedManyWithoutMovieInput
    movieCinemaOverrides?: MovieCinemaOverrideCreateNestedManyWithoutMovieInput
    movieProjections?: MovieProjectionCreateNestedManyWithoutMovieInput
  }

  export type MovieUncheckedCreateWithoutCountryOfOriginInput = {
    id?: string
    title?: string | null
    originalTitle: string
    localizedTitle?: string | null
    plot: string
    localizedPlot?: string | null
    runtimeMinutes: number
    originalLanguageId: string
    posterImages?: JsonNullValueInput | InputJsonValue
    videos?: JsonNullValueInput | InputJsonValue
    rating: number
    releaseDate: Date | string
    createdAt?: Date | string
    updatedAt: Date | string
    externalId: string
    externalType: $Enums.InputProvider
    additionalData?: JsonNullValueInput | InputJsonValue
    genres?: GenreUncheckedCreateNestedManyWithoutMoviesInput
    actors?: MovieActorUncheckedCreateNestedManyWithoutMovieInput
    directors?: MovieDirectorUncheckedCreateNestedManyWithoutMovieInput
    producers?: MovieProducerUncheckedCreateNestedManyWithoutMovieInput
    movieCinemaOverrides?: MovieCinemaOverrideUncheckedCreateNestedManyWithoutMovieInput
    movieProjections?: MovieProjectionUncheckedCreateNestedManyWithoutMovieInput
  }

  export type MovieCreateOrConnectWithoutCountryOfOriginInput = {
    where: MovieWhereUniqueInput
    create: XOR<MovieCreateWithoutCountryOfOriginInput, MovieUncheckedCreateWithoutCountryOfOriginInput>
  }

  export type MovieCreateManyCountryOfOriginInputEnvelope = {
    data: MovieCreateManyCountryOfOriginInput | MovieCreateManyCountryOfOriginInput[]
    skipDuplicates?: boolean
  }

  export type CityUpsertWithWhereUniqueWithoutCountryInput = {
    where: CityWhereUniqueInput
    update: XOR<CityUpdateWithoutCountryInput, CityUncheckedUpdateWithoutCountryInput>
    create: XOR<CityCreateWithoutCountryInput, CityUncheckedCreateWithoutCountryInput>
  }

  export type CityUpdateWithWhereUniqueWithoutCountryInput = {
    where: CityWhereUniqueInput
    data: XOR<CityUpdateWithoutCountryInput, CityUncheckedUpdateWithoutCountryInput>
  }

  export type CityUpdateManyWithWhereWithoutCountryInput = {
    where: CityScalarWhereInput
    data: XOR<CityUpdateManyMutationInput, CityUncheckedUpdateManyWithoutCountryInput>
  }

  export type CityScalarWhereInput = {
    AND?: CityScalarWhereInput | CityScalarWhereInput[]
    OR?: CityScalarWhereInput[]
    NOT?: CityScalarWhereInput | CityScalarWhereInput[]
    id?: UuidFilter<"City"> | string
    cityCode?: StringFilter<"City"> | string
    name?: StringFilter<"City"> | string
    postalCode?: StringFilter<"City"> | string
    countryCode?: StringFilter<"City"> | string
  }

  export type MovieUpsertWithWhereUniqueWithoutCountryOfOriginInput = {
    where: MovieWhereUniqueInput
    update: XOR<MovieUpdateWithoutCountryOfOriginInput, MovieUncheckedUpdateWithoutCountryOfOriginInput>
    create: XOR<MovieCreateWithoutCountryOfOriginInput, MovieUncheckedCreateWithoutCountryOfOriginInput>
  }

  export type MovieUpdateWithWhereUniqueWithoutCountryOfOriginInput = {
    where: MovieWhereUniqueInput
    data: XOR<MovieUpdateWithoutCountryOfOriginInput, MovieUncheckedUpdateWithoutCountryOfOriginInput>
  }

  export type MovieUpdateManyWithWhereWithoutCountryOfOriginInput = {
    where: MovieScalarWhereInput
    data: XOR<MovieUpdateManyMutationInput, MovieUncheckedUpdateManyWithoutCountryOfOriginInput>
  }

  export type CountryCreateWithoutCitiesInput = {
    code: string
    name: string
    movies?: MovieCreateNestedManyWithoutCountryOfOriginInput
  }

  export type CountryUncheckedCreateWithoutCitiesInput = {
    code: string
    name: string
    movies?: MovieUncheckedCreateNestedManyWithoutCountryOfOriginInput
  }

  export type CountryCreateOrConnectWithoutCitiesInput = {
    where: CountryWhereUniqueInput
    create: XOR<CountryCreateWithoutCitiesInput, CountryUncheckedCreateWithoutCitiesInput>
  }

  export type CinemaCreateWithoutCityInput = {
    id?: string
    name: string
    description: string
    address: string
    rating: number
    phone?: JsonNullValueInput | InputJsonValue
    posterImages?: JsonNullValueInput | InputJsonValue
    geoLatitude?: Decimal | DecimalJsLike | number | string | null
    geoLongitude?: Decimal | DecimalJsLike | number | string | null
    cinemaTheaters?: CinemaTheaterCreateNestedManyWithoutCinemaInput
    movieCinemaOverrides?: MovieCinemaOverrideCreateNestedManyWithoutCinemaInput
  }

  export type CinemaUncheckedCreateWithoutCityInput = {
    id?: string
    name: string
    description: string
    address: string
    rating: number
    phone?: JsonNullValueInput | InputJsonValue
    posterImages?: JsonNullValueInput | InputJsonValue
    geoLatitude?: Decimal | DecimalJsLike | number | string | null
    geoLongitude?: Decimal | DecimalJsLike | number | string | null
    cinemaTheaters?: CinemaTheaterUncheckedCreateNestedManyWithoutCinemaInput
    movieCinemaOverrides?: MovieCinemaOverrideUncheckedCreateNestedManyWithoutCinemaInput
  }

  export type CinemaCreateOrConnectWithoutCityInput = {
    where: CinemaWhereUniqueInput
    create: XOR<CinemaCreateWithoutCityInput, CinemaUncheckedCreateWithoutCityInput>
  }

  export type CinemaCreateManyCityInputEnvelope = {
    data: CinemaCreateManyCityInput | CinemaCreateManyCityInput[]
    skipDuplicates?: boolean
  }

  export type CountryUpsertWithoutCitiesInput = {
    update: XOR<CountryUpdateWithoutCitiesInput, CountryUncheckedUpdateWithoutCitiesInput>
    create: XOR<CountryCreateWithoutCitiesInput, CountryUncheckedCreateWithoutCitiesInput>
    where?: CountryWhereInput
  }

  export type CountryUpdateToOneWithWhereWithoutCitiesInput = {
    where?: CountryWhereInput
    data: XOR<CountryUpdateWithoutCitiesInput, CountryUncheckedUpdateWithoutCitiesInput>
  }

  export type CountryUpdateWithoutCitiesInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    movies?: MovieUpdateManyWithoutCountryOfOriginNestedInput
  }

  export type CountryUncheckedUpdateWithoutCitiesInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    movies?: MovieUncheckedUpdateManyWithoutCountryOfOriginNestedInput
  }

  export type CinemaUpsertWithWhereUniqueWithoutCityInput = {
    where: CinemaWhereUniqueInput
    update: XOR<CinemaUpdateWithoutCityInput, CinemaUncheckedUpdateWithoutCityInput>
    create: XOR<CinemaCreateWithoutCityInput, CinemaUncheckedCreateWithoutCityInput>
  }

  export type CinemaUpdateWithWhereUniqueWithoutCityInput = {
    where: CinemaWhereUniqueInput
    data: XOR<CinemaUpdateWithoutCityInput, CinemaUncheckedUpdateWithoutCityInput>
  }

  export type CinemaUpdateManyWithWhereWithoutCityInput = {
    where: CinemaScalarWhereInput
    data: XOR<CinemaUpdateManyMutationInput, CinemaUncheckedUpdateManyWithoutCityInput>
  }

  export type CinemaScalarWhereInput = {
    AND?: CinemaScalarWhereInput | CinemaScalarWhereInput[]
    OR?: CinemaScalarWhereInput[]
    NOT?: CinemaScalarWhereInput | CinemaScalarWhereInput[]
    id?: UuidFilter<"Cinema"> | string
    name?: StringFilter<"Cinema"> | string
    description?: StringFilter<"Cinema"> | string
    cityId?: UuidFilter<"Cinema"> | string
    address?: StringFilter<"Cinema"> | string
    rating?: IntFilter<"Cinema"> | number
    phone?: JsonFilter<"Cinema">
    posterImages?: JsonFilter<"Cinema">
    geoLatitude?: DecimalNullableFilter<"Cinema"> | Decimal | DecimalJsLike | number | string | null
    geoLongitude?: DecimalNullableFilter<"Cinema"> | Decimal | DecimalJsLike | number | string | null
  }

  export type CityCreateWithoutCinemasInput = {
    id?: string
    cityCode: string
    name: string
    postalCode: string
    country: CountryCreateNestedOneWithoutCitiesInput
  }

  export type CityUncheckedCreateWithoutCinemasInput = {
    id?: string
    cityCode: string
    name: string
    postalCode: string
    countryCode: string
  }

  export type CityCreateOrConnectWithoutCinemasInput = {
    where: CityWhereUniqueInput
    create: XOR<CityCreateWithoutCinemasInput, CityUncheckedCreateWithoutCinemasInput>
  }

  export type CinemaTheaterCreateWithoutCinemaInput = {
    id?: string
    name: string
    supports3D?: boolean
    posterImages?: JsonNullValueInput | InputJsonValue
    cinemaSeatGroups?: CinemaSeatGroupCreateNestedManyWithoutCinemaTheaterInput
    movieProjections?: MovieProjectionCreateNestedManyWithoutCinemaTheaterInput
  }

  export type CinemaTheaterUncheckedCreateWithoutCinemaInput = {
    id?: string
    name: string
    supports3D?: boolean
    posterImages?: JsonNullValueInput | InputJsonValue
    cinemaSeatGroups?: CinemaSeatGroupUncheckedCreateNestedManyWithoutCinemaTheaterInput
    movieProjections?: MovieProjectionUncheckedCreateNestedManyWithoutCinemaTheaterInput
  }

  export type CinemaTheaterCreateOrConnectWithoutCinemaInput = {
    where: CinemaTheaterWhereUniqueInput
    create: XOR<CinemaTheaterCreateWithoutCinemaInput, CinemaTheaterUncheckedCreateWithoutCinemaInput>
  }

  export type CinemaTheaterCreateManyCinemaInputEnvelope = {
    data: CinemaTheaterCreateManyCinemaInput | CinemaTheaterCreateManyCinemaInput[]
    skipDuplicates?: boolean
  }

  export type MovieCinemaOverrideCreateWithoutCinemaInput = {
    movieDataOverrides?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt: Date | string
    movie: MovieCreateNestedOneWithoutMovieCinemaOverridesInput
  }

  export type MovieCinemaOverrideUncheckedCreateWithoutCinemaInput = {
    movieId: string
    movieDataOverrides?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type MovieCinemaOverrideCreateOrConnectWithoutCinemaInput = {
    where: MovieCinemaOverrideWhereUniqueInput
    create: XOR<MovieCinemaOverrideCreateWithoutCinemaInput, MovieCinemaOverrideUncheckedCreateWithoutCinemaInput>
  }

  export type MovieCinemaOverrideCreateManyCinemaInputEnvelope = {
    data: MovieCinemaOverrideCreateManyCinemaInput | MovieCinemaOverrideCreateManyCinemaInput[]
    skipDuplicates?: boolean
  }

  export type CityUpsertWithoutCinemasInput = {
    update: XOR<CityUpdateWithoutCinemasInput, CityUncheckedUpdateWithoutCinemasInput>
    create: XOR<CityCreateWithoutCinemasInput, CityUncheckedCreateWithoutCinemasInput>
    where?: CityWhereInput
  }

  export type CityUpdateToOneWithWhereWithoutCinemasInput = {
    where?: CityWhereInput
    data: XOR<CityUpdateWithoutCinemasInput, CityUncheckedUpdateWithoutCinemasInput>
  }

  export type CityUpdateWithoutCinemasInput = {
    id?: StringFieldUpdateOperationsInput | string
    cityCode?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    postalCode?: StringFieldUpdateOperationsInput | string
    country?: CountryUpdateOneRequiredWithoutCitiesNestedInput
  }

  export type CityUncheckedUpdateWithoutCinemasInput = {
    id?: StringFieldUpdateOperationsInput | string
    cityCode?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    postalCode?: StringFieldUpdateOperationsInput | string
    countryCode?: StringFieldUpdateOperationsInput | string
  }

  export type CinemaTheaterUpsertWithWhereUniqueWithoutCinemaInput = {
    where: CinemaTheaterWhereUniqueInput
    update: XOR<CinemaTheaterUpdateWithoutCinemaInput, CinemaTheaterUncheckedUpdateWithoutCinemaInput>
    create: XOR<CinemaTheaterCreateWithoutCinemaInput, CinemaTheaterUncheckedCreateWithoutCinemaInput>
  }

  export type CinemaTheaterUpdateWithWhereUniqueWithoutCinemaInput = {
    where: CinemaTheaterWhereUniqueInput
    data: XOR<CinemaTheaterUpdateWithoutCinemaInput, CinemaTheaterUncheckedUpdateWithoutCinemaInput>
  }

  export type CinemaTheaterUpdateManyWithWhereWithoutCinemaInput = {
    where: CinemaTheaterScalarWhereInput
    data: XOR<CinemaTheaterUpdateManyMutationInput, CinemaTheaterUncheckedUpdateManyWithoutCinemaInput>
  }

  export type CinemaTheaterScalarWhereInput = {
    AND?: CinemaTheaterScalarWhereInput | CinemaTheaterScalarWhereInput[]
    OR?: CinemaTheaterScalarWhereInput[]
    NOT?: CinemaTheaterScalarWhereInput | CinemaTheaterScalarWhereInput[]
    id?: UuidFilter<"CinemaTheater"> | string
    name?: StringFilter<"CinemaTheater"> | string
    cinemaId?: UuidFilter<"CinemaTheater"> | string
    supports3D?: BoolFilter<"CinemaTheater"> | boolean
    posterImages?: JsonFilter<"CinemaTheater">
  }

  export type MovieCinemaOverrideUpsertWithWhereUniqueWithoutCinemaInput = {
    where: MovieCinemaOverrideWhereUniqueInput
    update: XOR<MovieCinemaOverrideUpdateWithoutCinemaInput, MovieCinemaOverrideUncheckedUpdateWithoutCinemaInput>
    create: XOR<MovieCinemaOverrideCreateWithoutCinemaInput, MovieCinemaOverrideUncheckedCreateWithoutCinemaInput>
  }

  export type MovieCinemaOverrideUpdateWithWhereUniqueWithoutCinemaInput = {
    where: MovieCinemaOverrideWhereUniqueInput
    data: XOR<MovieCinemaOverrideUpdateWithoutCinemaInput, MovieCinemaOverrideUncheckedUpdateWithoutCinemaInput>
  }

  export type MovieCinemaOverrideUpdateManyWithWhereWithoutCinemaInput = {
    where: MovieCinemaOverrideScalarWhereInput
    data: XOR<MovieCinemaOverrideUpdateManyMutationInput, MovieCinemaOverrideUncheckedUpdateManyWithoutCinemaInput>
  }

  export type MovieCinemaOverrideScalarWhereInput = {
    AND?: MovieCinemaOverrideScalarWhereInput | MovieCinemaOverrideScalarWhereInput[]
    OR?: MovieCinemaOverrideScalarWhereInput[]
    NOT?: MovieCinemaOverrideScalarWhereInput | MovieCinemaOverrideScalarWhereInput[]
    movieId?: UuidFilter<"MovieCinemaOverride"> | string
    cinemaId?: UuidFilter<"MovieCinemaOverride"> | string
    movieDataOverrides?: JsonFilter<"MovieCinemaOverride">
    createdAt?: DateTimeFilter<"MovieCinemaOverride"> | Date | string
    updatedAt?: DateTimeFilter<"MovieCinemaOverride"> | Date | string
  }

  export type CinemaCreateWithoutCinemaTheatersInput = {
    id?: string
    name: string
    description: string
    address: string
    rating: number
    phone?: JsonNullValueInput | InputJsonValue
    posterImages?: JsonNullValueInput | InputJsonValue
    geoLatitude?: Decimal | DecimalJsLike | number | string | null
    geoLongitude?: Decimal | DecimalJsLike | number | string | null
    city: CityCreateNestedOneWithoutCinemasInput
    movieCinemaOverrides?: MovieCinemaOverrideCreateNestedManyWithoutCinemaInput
  }

  export type CinemaUncheckedCreateWithoutCinemaTheatersInput = {
    id?: string
    name: string
    description: string
    cityId: string
    address: string
    rating: number
    phone?: JsonNullValueInput | InputJsonValue
    posterImages?: JsonNullValueInput | InputJsonValue
    geoLatitude?: Decimal | DecimalJsLike | number | string | null
    geoLongitude?: Decimal | DecimalJsLike | number | string | null
    movieCinemaOverrides?: MovieCinemaOverrideUncheckedCreateNestedManyWithoutCinemaInput
  }

  export type CinemaCreateOrConnectWithoutCinemaTheatersInput = {
    where: CinemaWhereUniqueInput
    create: XOR<CinemaCreateWithoutCinemaTheatersInput, CinemaUncheckedCreateWithoutCinemaTheatersInput>
  }

  export type CinemaSeatGroupCreateWithoutCinemaTheaterInput = {
    id?: string
    name: string
    rowCount: number
    columnCount: number
    position?: $Enums.CinemaSeatGroupPositionEnum
    options?: JsonNullValueInput | InputJsonValue
    cinemaSeats?: CinemaSeatCreateNestedManyWithoutCinemaSeatGroupInput
    projectionPrices?: ProjectionPriceCreateNestedManyWithoutCinemaSeatGroupInput
  }

  export type CinemaSeatGroupUncheckedCreateWithoutCinemaTheaterInput = {
    id?: string
    name: string
    rowCount: number
    columnCount: number
    position?: $Enums.CinemaSeatGroupPositionEnum
    options?: JsonNullValueInput | InputJsonValue
    cinemaSeats?: CinemaSeatUncheckedCreateNestedManyWithoutCinemaSeatGroupInput
    projectionPrices?: ProjectionPriceUncheckedCreateNestedManyWithoutCinemaSeatGroupInput
  }

  export type CinemaSeatGroupCreateOrConnectWithoutCinemaTheaterInput = {
    where: CinemaSeatGroupWhereUniqueInput
    create: XOR<CinemaSeatGroupCreateWithoutCinemaTheaterInput, CinemaSeatGroupUncheckedCreateWithoutCinemaTheaterInput>
  }

  export type CinemaSeatGroupCreateManyCinemaTheaterInputEnvelope = {
    data: CinemaSeatGroupCreateManyCinemaTheaterInput | CinemaSeatGroupCreateManyCinemaTheaterInput[]
    skipDuplicates?: boolean
  }

  export type MovieProjectionCreateWithoutCinemaTheaterInput = {
    id?: string
    projectionDateTime: Date | string
    createdAt?: Date | string
    updatedAt: Date | string
    options?: JsonNullValueInput | InputJsonValue
    movie: MovieCreateNestedOneWithoutMovieProjectionsInput
    dubbedLanguage?: LanguageCreateNestedOneWithoutDubbedLanguageMovieProjectionsInput
    projectionPrices?: ProjectionPriceCreateNestedManyWithoutMovieProjectionInput
    reservations?: ReservationCreateNestedManyWithoutMovieProjectionInput
  }

  export type MovieProjectionUncheckedCreateWithoutCinemaTheaterInput = {
    id?: string
    movieId: string
    projectionDateTime: Date | string
    createdAt?: Date | string
    updatedAt: Date | string
    dubbedLanguageId?: string | null
    options?: JsonNullValueInput | InputJsonValue
    projectionPrices?: ProjectionPriceUncheckedCreateNestedManyWithoutMovieProjectionInput
    reservations?: ReservationUncheckedCreateNestedManyWithoutMovieProjectionInput
  }

  export type MovieProjectionCreateOrConnectWithoutCinemaTheaterInput = {
    where: MovieProjectionWhereUniqueInput
    create: XOR<MovieProjectionCreateWithoutCinemaTheaterInput, MovieProjectionUncheckedCreateWithoutCinemaTheaterInput>
  }

  export type MovieProjectionCreateManyCinemaTheaterInputEnvelope = {
    data: MovieProjectionCreateManyCinemaTheaterInput | MovieProjectionCreateManyCinemaTheaterInput[]
    skipDuplicates?: boolean
  }

  export type CinemaUpsertWithoutCinemaTheatersInput = {
    update: XOR<CinemaUpdateWithoutCinemaTheatersInput, CinemaUncheckedUpdateWithoutCinemaTheatersInput>
    create: XOR<CinemaCreateWithoutCinemaTheatersInput, CinemaUncheckedCreateWithoutCinemaTheatersInput>
    where?: CinemaWhereInput
  }

  export type CinemaUpdateToOneWithWhereWithoutCinemaTheatersInput = {
    where?: CinemaWhereInput
    data: XOR<CinemaUpdateWithoutCinemaTheatersInput, CinemaUncheckedUpdateWithoutCinemaTheatersInput>
  }

  export type CinemaUpdateWithoutCinemaTheatersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    phone?: JsonNullValueInput | InputJsonValue
    posterImages?: JsonNullValueInput | InputJsonValue
    geoLatitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    geoLongitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    city?: CityUpdateOneRequiredWithoutCinemasNestedInput
    movieCinemaOverrides?: MovieCinemaOverrideUpdateManyWithoutCinemaNestedInput
  }

  export type CinemaUncheckedUpdateWithoutCinemaTheatersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    cityId?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    phone?: JsonNullValueInput | InputJsonValue
    posterImages?: JsonNullValueInput | InputJsonValue
    geoLatitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    geoLongitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    movieCinemaOverrides?: MovieCinemaOverrideUncheckedUpdateManyWithoutCinemaNestedInput
  }

  export type CinemaSeatGroupUpsertWithWhereUniqueWithoutCinemaTheaterInput = {
    where: CinemaSeatGroupWhereUniqueInput
    update: XOR<CinemaSeatGroupUpdateWithoutCinemaTheaterInput, CinemaSeatGroupUncheckedUpdateWithoutCinemaTheaterInput>
    create: XOR<CinemaSeatGroupCreateWithoutCinemaTheaterInput, CinemaSeatGroupUncheckedCreateWithoutCinemaTheaterInput>
  }

  export type CinemaSeatGroupUpdateWithWhereUniqueWithoutCinemaTheaterInput = {
    where: CinemaSeatGroupWhereUniqueInput
    data: XOR<CinemaSeatGroupUpdateWithoutCinemaTheaterInput, CinemaSeatGroupUncheckedUpdateWithoutCinemaTheaterInput>
  }

  export type CinemaSeatGroupUpdateManyWithWhereWithoutCinemaTheaterInput = {
    where: CinemaSeatGroupScalarWhereInput
    data: XOR<CinemaSeatGroupUpdateManyMutationInput, CinemaSeatGroupUncheckedUpdateManyWithoutCinemaTheaterInput>
  }

  export type CinemaSeatGroupScalarWhereInput = {
    AND?: CinemaSeatGroupScalarWhereInput | CinemaSeatGroupScalarWhereInput[]
    OR?: CinemaSeatGroupScalarWhereInput[]
    NOT?: CinemaSeatGroupScalarWhereInput | CinemaSeatGroupScalarWhereInput[]
    id?: UuidFilter<"CinemaSeatGroup"> | string
    cinemaTheaterId?: UuidFilter<"CinemaSeatGroup"> | string
    name?: StringFilter<"CinemaSeatGroup"> | string
    rowCount?: IntFilter<"CinemaSeatGroup"> | number
    columnCount?: IntFilter<"CinemaSeatGroup"> | number
    position?: EnumCinemaSeatGroupPositionEnumFilter<"CinemaSeatGroup"> | $Enums.CinemaSeatGroupPositionEnum
    options?: JsonFilter<"CinemaSeatGroup">
  }

  export type MovieProjectionUpsertWithWhereUniqueWithoutCinemaTheaterInput = {
    where: MovieProjectionWhereUniqueInput
    update: XOR<MovieProjectionUpdateWithoutCinemaTheaterInput, MovieProjectionUncheckedUpdateWithoutCinemaTheaterInput>
    create: XOR<MovieProjectionCreateWithoutCinemaTheaterInput, MovieProjectionUncheckedCreateWithoutCinemaTheaterInput>
  }

  export type MovieProjectionUpdateWithWhereUniqueWithoutCinemaTheaterInput = {
    where: MovieProjectionWhereUniqueInput
    data: XOR<MovieProjectionUpdateWithoutCinemaTheaterInput, MovieProjectionUncheckedUpdateWithoutCinemaTheaterInput>
  }

  export type MovieProjectionUpdateManyWithWhereWithoutCinemaTheaterInput = {
    where: MovieProjectionScalarWhereInput
    data: XOR<MovieProjectionUpdateManyMutationInput, MovieProjectionUncheckedUpdateManyWithoutCinemaTheaterInput>
  }

  export type CinemaTheaterCreateWithoutCinemaSeatGroupsInput = {
    id?: string
    name: string
    supports3D?: boolean
    posterImages?: JsonNullValueInput | InputJsonValue
    cinema: CinemaCreateNestedOneWithoutCinemaTheatersInput
    movieProjections?: MovieProjectionCreateNestedManyWithoutCinemaTheaterInput
  }

  export type CinemaTheaterUncheckedCreateWithoutCinemaSeatGroupsInput = {
    id?: string
    name: string
    cinemaId: string
    supports3D?: boolean
    posterImages?: JsonNullValueInput | InputJsonValue
    movieProjections?: MovieProjectionUncheckedCreateNestedManyWithoutCinemaTheaterInput
  }

  export type CinemaTheaterCreateOrConnectWithoutCinemaSeatGroupsInput = {
    where: CinemaTheaterWhereUniqueInput
    create: XOR<CinemaTheaterCreateWithoutCinemaSeatGroupsInput, CinemaTheaterUncheckedCreateWithoutCinemaSeatGroupsInput>
  }

  export type CinemaSeatCreateWithoutCinemaSeatGroupInput = {
    id?: string
    seatRow: string
    seatColumn: string
    options?: JsonNullValueInput | InputJsonValue
    reservation?: ReservationSeatsCreateNestedManyWithoutCinemaSeatInput
  }

  export type CinemaSeatUncheckedCreateWithoutCinemaSeatGroupInput = {
    id?: string
    seatRow: string
    seatColumn: string
    options?: JsonNullValueInput | InputJsonValue
    reservation?: ReservationSeatsUncheckedCreateNestedManyWithoutCinemaSeatInput
  }

  export type CinemaSeatCreateOrConnectWithoutCinemaSeatGroupInput = {
    where: CinemaSeatWhereUniqueInput
    create: XOR<CinemaSeatCreateWithoutCinemaSeatGroupInput, CinemaSeatUncheckedCreateWithoutCinemaSeatGroupInput>
  }

  export type CinemaSeatCreateManyCinemaSeatGroupInputEnvelope = {
    data: CinemaSeatCreateManyCinemaSeatGroupInput | CinemaSeatCreateManyCinemaSeatGroupInput[]
    skipDuplicates?: boolean
  }

  export type ProjectionPriceCreateWithoutCinemaSeatGroupInput = {
    type?: $Enums.PriceType
    price: Decimal | DecimalJsLike | number | string
    currencyCode: $Enums.CurrencyCode
    movieProjection: MovieProjectionCreateNestedOneWithoutProjectionPricesInput
  }

  export type ProjectionPriceUncheckedCreateWithoutCinemaSeatGroupInput = {
    projectionId: string
    type?: $Enums.PriceType
    price: Decimal | DecimalJsLike | number | string
    currencyCode: $Enums.CurrencyCode
  }

  export type ProjectionPriceCreateOrConnectWithoutCinemaSeatGroupInput = {
    where: ProjectionPriceWhereUniqueInput
    create: XOR<ProjectionPriceCreateWithoutCinemaSeatGroupInput, ProjectionPriceUncheckedCreateWithoutCinemaSeatGroupInput>
  }

  export type ProjectionPriceCreateManyCinemaSeatGroupInputEnvelope = {
    data: ProjectionPriceCreateManyCinemaSeatGroupInput | ProjectionPriceCreateManyCinemaSeatGroupInput[]
    skipDuplicates?: boolean
  }

  export type CinemaTheaterUpsertWithoutCinemaSeatGroupsInput = {
    update: XOR<CinemaTheaterUpdateWithoutCinemaSeatGroupsInput, CinemaTheaterUncheckedUpdateWithoutCinemaSeatGroupsInput>
    create: XOR<CinemaTheaterCreateWithoutCinemaSeatGroupsInput, CinemaTheaterUncheckedCreateWithoutCinemaSeatGroupsInput>
    where?: CinemaTheaterWhereInput
  }

  export type CinemaTheaterUpdateToOneWithWhereWithoutCinemaSeatGroupsInput = {
    where?: CinemaTheaterWhereInput
    data: XOR<CinemaTheaterUpdateWithoutCinemaSeatGroupsInput, CinemaTheaterUncheckedUpdateWithoutCinemaSeatGroupsInput>
  }

  export type CinemaTheaterUpdateWithoutCinemaSeatGroupsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    supports3D?: BoolFieldUpdateOperationsInput | boolean
    posterImages?: JsonNullValueInput | InputJsonValue
    cinema?: CinemaUpdateOneRequiredWithoutCinemaTheatersNestedInput
    movieProjections?: MovieProjectionUpdateManyWithoutCinemaTheaterNestedInput
  }

  export type CinemaTheaterUncheckedUpdateWithoutCinemaSeatGroupsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    cinemaId?: StringFieldUpdateOperationsInput | string
    supports3D?: BoolFieldUpdateOperationsInput | boolean
    posterImages?: JsonNullValueInput | InputJsonValue
    movieProjections?: MovieProjectionUncheckedUpdateManyWithoutCinemaTheaterNestedInput
  }

  export type CinemaSeatUpsertWithWhereUniqueWithoutCinemaSeatGroupInput = {
    where: CinemaSeatWhereUniqueInput
    update: XOR<CinemaSeatUpdateWithoutCinemaSeatGroupInput, CinemaSeatUncheckedUpdateWithoutCinemaSeatGroupInput>
    create: XOR<CinemaSeatCreateWithoutCinemaSeatGroupInput, CinemaSeatUncheckedCreateWithoutCinemaSeatGroupInput>
  }

  export type CinemaSeatUpdateWithWhereUniqueWithoutCinemaSeatGroupInput = {
    where: CinemaSeatWhereUniqueInput
    data: XOR<CinemaSeatUpdateWithoutCinemaSeatGroupInput, CinemaSeatUncheckedUpdateWithoutCinemaSeatGroupInput>
  }

  export type CinemaSeatUpdateManyWithWhereWithoutCinemaSeatGroupInput = {
    where: CinemaSeatScalarWhereInput
    data: XOR<CinemaSeatUpdateManyMutationInput, CinemaSeatUncheckedUpdateManyWithoutCinemaSeatGroupInput>
  }

  export type CinemaSeatScalarWhereInput = {
    AND?: CinemaSeatScalarWhereInput | CinemaSeatScalarWhereInput[]
    OR?: CinemaSeatScalarWhereInput[]
    NOT?: CinemaSeatScalarWhereInput | CinemaSeatScalarWhereInput[]
    id?: UuidFilter<"CinemaSeat"> | string
    cinemaSeatGroupId?: UuidFilter<"CinemaSeat"> | string
    seatRow?: StringFilter<"CinemaSeat"> | string
    seatColumn?: StringFilter<"CinemaSeat"> | string
    options?: JsonFilter<"CinemaSeat">
  }

  export type ProjectionPriceUpsertWithWhereUniqueWithoutCinemaSeatGroupInput = {
    where: ProjectionPriceWhereUniqueInput
    update: XOR<ProjectionPriceUpdateWithoutCinemaSeatGroupInput, ProjectionPriceUncheckedUpdateWithoutCinemaSeatGroupInput>
    create: XOR<ProjectionPriceCreateWithoutCinemaSeatGroupInput, ProjectionPriceUncheckedCreateWithoutCinemaSeatGroupInput>
  }

  export type ProjectionPriceUpdateWithWhereUniqueWithoutCinemaSeatGroupInput = {
    where: ProjectionPriceWhereUniqueInput
    data: XOR<ProjectionPriceUpdateWithoutCinemaSeatGroupInput, ProjectionPriceUncheckedUpdateWithoutCinemaSeatGroupInput>
  }

  export type ProjectionPriceUpdateManyWithWhereWithoutCinemaSeatGroupInput = {
    where: ProjectionPriceScalarWhereInput
    data: XOR<ProjectionPriceUpdateManyMutationInput, ProjectionPriceUncheckedUpdateManyWithoutCinemaSeatGroupInput>
  }

  export type ProjectionPriceScalarWhereInput = {
    AND?: ProjectionPriceScalarWhereInput | ProjectionPriceScalarWhereInput[]
    OR?: ProjectionPriceScalarWhereInput[]
    NOT?: ProjectionPriceScalarWhereInput | ProjectionPriceScalarWhereInput[]
    projectionId?: UuidFilter<"ProjectionPrice"> | string
    groupId?: UuidFilter<"ProjectionPrice"> | string
    type?: EnumPriceTypeFilter<"ProjectionPrice"> | $Enums.PriceType
    price?: DecimalFilter<"ProjectionPrice"> | Decimal | DecimalJsLike | number | string
    currencyCode?: EnumCurrencyCodeFilter<"ProjectionPrice"> | $Enums.CurrencyCode
  }

  export type CinemaSeatGroupCreateWithoutCinemaSeatsInput = {
    id?: string
    name: string
    rowCount: number
    columnCount: number
    position?: $Enums.CinemaSeatGroupPositionEnum
    options?: JsonNullValueInput | InputJsonValue
    cinemaTheater: CinemaTheaterCreateNestedOneWithoutCinemaSeatGroupsInput
    projectionPrices?: ProjectionPriceCreateNestedManyWithoutCinemaSeatGroupInput
  }

  export type CinemaSeatGroupUncheckedCreateWithoutCinemaSeatsInput = {
    id?: string
    cinemaTheaterId: string
    name: string
    rowCount: number
    columnCount: number
    position?: $Enums.CinemaSeatGroupPositionEnum
    options?: JsonNullValueInput | InputJsonValue
    projectionPrices?: ProjectionPriceUncheckedCreateNestedManyWithoutCinemaSeatGroupInput
  }

  export type CinemaSeatGroupCreateOrConnectWithoutCinemaSeatsInput = {
    where: CinemaSeatGroupWhereUniqueInput
    create: XOR<CinemaSeatGroupCreateWithoutCinemaSeatsInput, CinemaSeatGroupUncheckedCreateWithoutCinemaSeatsInput>
  }

  export type ReservationSeatsCreateWithoutCinemaSeatInput = {
    id?: string
    eventId: string
    options?: JsonNullValueInput | InputJsonValue
    deletedAt?: Date | string | null
    validatedAt?: Date | string | null
    reservation: ReservationCreateNestedOneWithoutReservationSeatsInput
    validatedByAdminUser?: AdminUserCreateNestedOneWithoutValidatedReservationSeatsInput
  }

  export type ReservationSeatsUncheckedCreateWithoutCinemaSeatInput = {
    id?: string
    reservationId: string
    eventId: string
    options?: JsonNullValueInput | InputJsonValue
    deletedAt?: Date | string | null
    validatedAt?: Date | string | null
    validatedByAdminUserId?: string | null
  }

  export type ReservationSeatsCreateOrConnectWithoutCinemaSeatInput = {
    where: ReservationSeatsWhereUniqueInput
    create: XOR<ReservationSeatsCreateWithoutCinemaSeatInput, ReservationSeatsUncheckedCreateWithoutCinemaSeatInput>
  }

  export type ReservationSeatsCreateManyCinemaSeatInputEnvelope = {
    data: ReservationSeatsCreateManyCinemaSeatInput | ReservationSeatsCreateManyCinemaSeatInput[]
    skipDuplicates?: boolean
  }

  export type CinemaSeatGroupUpsertWithoutCinemaSeatsInput = {
    update: XOR<CinemaSeatGroupUpdateWithoutCinemaSeatsInput, CinemaSeatGroupUncheckedUpdateWithoutCinemaSeatsInput>
    create: XOR<CinemaSeatGroupCreateWithoutCinemaSeatsInput, CinemaSeatGroupUncheckedCreateWithoutCinemaSeatsInput>
    where?: CinemaSeatGroupWhereInput
  }

  export type CinemaSeatGroupUpdateToOneWithWhereWithoutCinemaSeatsInput = {
    where?: CinemaSeatGroupWhereInput
    data: XOR<CinemaSeatGroupUpdateWithoutCinemaSeatsInput, CinemaSeatGroupUncheckedUpdateWithoutCinemaSeatsInput>
  }

  export type CinemaSeatGroupUpdateWithoutCinemaSeatsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    rowCount?: IntFieldUpdateOperationsInput | number
    columnCount?: IntFieldUpdateOperationsInput | number
    position?: EnumCinemaSeatGroupPositionEnumFieldUpdateOperationsInput | $Enums.CinemaSeatGroupPositionEnum
    options?: JsonNullValueInput | InputJsonValue
    cinemaTheater?: CinemaTheaterUpdateOneRequiredWithoutCinemaSeatGroupsNestedInput
    projectionPrices?: ProjectionPriceUpdateManyWithoutCinemaSeatGroupNestedInput
  }

  export type CinemaSeatGroupUncheckedUpdateWithoutCinemaSeatsInput = {
    id?: StringFieldUpdateOperationsInput | string
    cinemaTheaterId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    rowCount?: IntFieldUpdateOperationsInput | number
    columnCount?: IntFieldUpdateOperationsInput | number
    position?: EnumCinemaSeatGroupPositionEnumFieldUpdateOperationsInput | $Enums.CinemaSeatGroupPositionEnum
    options?: JsonNullValueInput | InputJsonValue
    projectionPrices?: ProjectionPriceUncheckedUpdateManyWithoutCinemaSeatGroupNestedInput
  }

  export type ReservationSeatsUpsertWithWhereUniqueWithoutCinemaSeatInput = {
    where: ReservationSeatsWhereUniqueInput
    update: XOR<ReservationSeatsUpdateWithoutCinemaSeatInput, ReservationSeatsUncheckedUpdateWithoutCinemaSeatInput>
    create: XOR<ReservationSeatsCreateWithoutCinemaSeatInput, ReservationSeatsUncheckedCreateWithoutCinemaSeatInput>
  }

  export type ReservationSeatsUpdateWithWhereUniqueWithoutCinemaSeatInput = {
    where: ReservationSeatsWhereUniqueInput
    data: XOR<ReservationSeatsUpdateWithoutCinemaSeatInput, ReservationSeatsUncheckedUpdateWithoutCinemaSeatInput>
  }

  export type ReservationSeatsUpdateManyWithWhereWithoutCinemaSeatInput = {
    where: ReservationSeatsScalarWhereInput
    data: XOR<ReservationSeatsUpdateManyMutationInput, ReservationSeatsUncheckedUpdateManyWithoutCinemaSeatInput>
  }

  export type ReservationSeatsScalarWhereInput = {
    AND?: ReservationSeatsScalarWhereInput | ReservationSeatsScalarWhereInput[]
    OR?: ReservationSeatsScalarWhereInput[]
    NOT?: ReservationSeatsScalarWhereInput | ReservationSeatsScalarWhereInput[]
    id?: UuidFilter<"ReservationSeats"> | string
    reservationId?: UuidFilter<"ReservationSeats"> | string
    eventId?: UuidFilter<"ReservationSeats"> | string
    seatId?: UuidFilter<"ReservationSeats"> | string
    options?: JsonFilter<"ReservationSeats">
    deletedAt?: DateTimeNullableFilter<"ReservationSeats"> | Date | string | null
    validatedAt?: DateTimeNullableFilter<"ReservationSeats"> | Date | string | null
    validatedByAdminUserId?: UuidNullableFilter<"ReservationSeats"> | string | null
  }

  export type GenreCreateWithoutMoviesInput = {
    systemName: string
    localizedName: string
  }

  export type GenreUncheckedCreateWithoutMoviesInput = {
    systemName: string
    localizedName: string
  }

  export type GenreCreateOrConnectWithoutMoviesInput = {
    where: GenreWhereUniqueInput
    create: XOR<GenreCreateWithoutMoviesInput, GenreUncheckedCreateWithoutMoviesInput>
  }

  export type LanguageCreateWithoutOriginalLanguageMoviesInput = {
    code: string
    name: string
    dubbedLanguageMovieProjections?: MovieProjectionCreateNestedManyWithoutDubbedLanguageInput
  }

  export type LanguageUncheckedCreateWithoutOriginalLanguageMoviesInput = {
    code: string
    name: string
    dubbedLanguageMovieProjections?: MovieProjectionUncheckedCreateNestedManyWithoutDubbedLanguageInput
  }

  export type LanguageCreateOrConnectWithoutOriginalLanguageMoviesInput = {
    where: LanguageWhereUniqueInput
    create: XOR<LanguageCreateWithoutOriginalLanguageMoviesInput, LanguageUncheckedCreateWithoutOriginalLanguageMoviesInput>
  }

  export type CountryCreateWithoutMoviesInput = {
    code: string
    name: string
    cities?: CityCreateNestedManyWithoutCountryInput
  }

  export type CountryUncheckedCreateWithoutMoviesInput = {
    code: string
    name: string
    cities?: CityUncheckedCreateNestedManyWithoutCountryInput
  }

  export type CountryCreateOrConnectWithoutMoviesInput = {
    where: CountryWhereUniqueInput
    create: XOR<CountryCreateWithoutMoviesInput, CountryUncheckedCreateWithoutMoviesInput>
  }

  export type MovieActorCreateWithoutMovieInput = {
    characterName: string
    castOrder: number
    person: PersonCreateNestedOneWithoutActorInMoviesInput
  }

  export type MovieActorUncheckedCreateWithoutMovieInput = {
    personId: string
    characterName: string
    castOrder: number
  }

  export type MovieActorCreateOrConnectWithoutMovieInput = {
    where: MovieActorWhereUniqueInput
    create: XOR<MovieActorCreateWithoutMovieInput, MovieActorUncheckedCreateWithoutMovieInput>
  }

  export type MovieActorCreateManyMovieInputEnvelope = {
    data: MovieActorCreateManyMovieInput | MovieActorCreateManyMovieInput[]
    skipDuplicates?: boolean
  }

  export type MovieDirectorCreateWithoutMovieInput = {
    type: $Enums.DirectorType
    person: PersonCreateNestedOneWithoutDirectorInMoviesInput
  }

  export type MovieDirectorUncheckedCreateWithoutMovieInput = {
    personId: string
    type: $Enums.DirectorType
  }

  export type MovieDirectorCreateOrConnectWithoutMovieInput = {
    where: MovieDirectorWhereUniqueInput
    create: XOR<MovieDirectorCreateWithoutMovieInput, MovieDirectorUncheckedCreateWithoutMovieInput>
  }

  export type MovieDirectorCreateManyMovieInputEnvelope = {
    data: MovieDirectorCreateManyMovieInput | MovieDirectorCreateManyMovieInput[]
    skipDuplicates?: boolean
  }

  export type MovieProducerCreateWithoutMovieInput = {
    type: $Enums.ProducerType
    person: PersonCreateNestedOneWithoutProducerInMoviesInput
  }

  export type MovieProducerUncheckedCreateWithoutMovieInput = {
    personId: string
    type: $Enums.ProducerType
  }

  export type MovieProducerCreateOrConnectWithoutMovieInput = {
    where: MovieProducerWhereUniqueInput
    create: XOR<MovieProducerCreateWithoutMovieInput, MovieProducerUncheckedCreateWithoutMovieInput>
  }

  export type MovieProducerCreateManyMovieInputEnvelope = {
    data: MovieProducerCreateManyMovieInput | MovieProducerCreateManyMovieInput[]
    skipDuplicates?: boolean
  }

  export type MovieCinemaOverrideCreateWithoutMovieInput = {
    movieDataOverrides?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt: Date | string
    cinema: CinemaCreateNestedOneWithoutMovieCinemaOverridesInput
  }

  export type MovieCinemaOverrideUncheckedCreateWithoutMovieInput = {
    cinemaId: string
    movieDataOverrides?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type MovieCinemaOverrideCreateOrConnectWithoutMovieInput = {
    where: MovieCinemaOverrideWhereUniqueInput
    create: XOR<MovieCinemaOverrideCreateWithoutMovieInput, MovieCinemaOverrideUncheckedCreateWithoutMovieInput>
  }

  export type MovieCinemaOverrideCreateManyMovieInputEnvelope = {
    data: MovieCinemaOverrideCreateManyMovieInput | MovieCinemaOverrideCreateManyMovieInput[]
    skipDuplicates?: boolean
  }

  export type MovieProjectionCreateWithoutMovieInput = {
    id?: string
    projectionDateTime: Date | string
    createdAt?: Date | string
    updatedAt: Date | string
    options?: JsonNullValueInput | InputJsonValue
    cinemaTheater: CinemaTheaterCreateNestedOneWithoutMovieProjectionsInput
    dubbedLanguage?: LanguageCreateNestedOneWithoutDubbedLanguageMovieProjectionsInput
    projectionPrices?: ProjectionPriceCreateNestedManyWithoutMovieProjectionInput
    reservations?: ReservationCreateNestedManyWithoutMovieProjectionInput
  }

  export type MovieProjectionUncheckedCreateWithoutMovieInput = {
    id?: string
    cinemaTheaterId: string
    projectionDateTime: Date | string
    createdAt?: Date | string
    updatedAt: Date | string
    dubbedLanguageId?: string | null
    options?: JsonNullValueInput | InputJsonValue
    projectionPrices?: ProjectionPriceUncheckedCreateNestedManyWithoutMovieProjectionInput
    reservations?: ReservationUncheckedCreateNestedManyWithoutMovieProjectionInput
  }

  export type MovieProjectionCreateOrConnectWithoutMovieInput = {
    where: MovieProjectionWhereUniqueInput
    create: XOR<MovieProjectionCreateWithoutMovieInput, MovieProjectionUncheckedCreateWithoutMovieInput>
  }

  export type MovieProjectionCreateManyMovieInputEnvelope = {
    data: MovieProjectionCreateManyMovieInput | MovieProjectionCreateManyMovieInput[]
    skipDuplicates?: boolean
  }

  export type GenreUpsertWithWhereUniqueWithoutMoviesInput = {
    where: GenreWhereUniqueInput
    update: XOR<GenreUpdateWithoutMoviesInput, GenreUncheckedUpdateWithoutMoviesInput>
    create: XOR<GenreCreateWithoutMoviesInput, GenreUncheckedCreateWithoutMoviesInput>
  }

  export type GenreUpdateWithWhereUniqueWithoutMoviesInput = {
    where: GenreWhereUniqueInput
    data: XOR<GenreUpdateWithoutMoviesInput, GenreUncheckedUpdateWithoutMoviesInput>
  }

  export type GenreUpdateManyWithWhereWithoutMoviesInput = {
    where: GenreScalarWhereInput
    data: XOR<GenreUpdateManyMutationInput, GenreUncheckedUpdateManyWithoutMoviesInput>
  }

  export type GenreScalarWhereInput = {
    AND?: GenreScalarWhereInput | GenreScalarWhereInput[]
    OR?: GenreScalarWhereInput[]
    NOT?: GenreScalarWhereInput | GenreScalarWhereInput[]
    systemName?: StringFilter<"Genre"> | string
    localizedName?: StringFilter<"Genre"> | string
  }

  export type LanguageUpsertWithoutOriginalLanguageMoviesInput = {
    update: XOR<LanguageUpdateWithoutOriginalLanguageMoviesInput, LanguageUncheckedUpdateWithoutOriginalLanguageMoviesInput>
    create: XOR<LanguageCreateWithoutOriginalLanguageMoviesInput, LanguageUncheckedCreateWithoutOriginalLanguageMoviesInput>
    where?: LanguageWhereInput
  }

  export type LanguageUpdateToOneWithWhereWithoutOriginalLanguageMoviesInput = {
    where?: LanguageWhereInput
    data: XOR<LanguageUpdateWithoutOriginalLanguageMoviesInput, LanguageUncheckedUpdateWithoutOriginalLanguageMoviesInput>
  }

  export type LanguageUpdateWithoutOriginalLanguageMoviesInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    dubbedLanguageMovieProjections?: MovieProjectionUpdateManyWithoutDubbedLanguageNestedInput
  }

  export type LanguageUncheckedUpdateWithoutOriginalLanguageMoviesInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    dubbedLanguageMovieProjections?: MovieProjectionUncheckedUpdateManyWithoutDubbedLanguageNestedInput
  }

  export type CountryUpsertWithoutMoviesInput = {
    update: XOR<CountryUpdateWithoutMoviesInput, CountryUncheckedUpdateWithoutMoviesInput>
    create: XOR<CountryCreateWithoutMoviesInput, CountryUncheckedCreateWithoutMoviesInput>
    where?: CountryWhereInput
  }

  export type CountryUpdateToOneWithWhereWithoutMoviesInput = {
    where?: CountryWhereInput
    data: XOR<CountryUpdateWithoutMoviesInput, CountryUncheckedUpdateWithoutMoviesInput>
  }

  export type CountryUpdateWithoutMoviesInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    cities?: CityUpdateManyWithoutCountryNestedInput
  }

  export type CountryUncheckedUpdateWithoutMoviesInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    cities?: CityUncheckedUpdateManyWithoutCountryNestedInput
  }

  export type MovieActorUpsertWithWhereUniqueWithoutMovieInput = {
    where: MovieActorWhereUniqueInput
    update: XOR<MovieActorUpdateWithoutMovieInput, MovieActorUncheckedUpdateWithoutMovieInput>
    create: XOR<MovieActorCreateWithoutMovieInput, MovieActorUncheckedCreateWithoutMovieInput>
  }

  export type MovieActorUpdateWithWhereUniqueWithoutMovieInput = {
    where: MovieActorWhereUniqueInput
    data: XOR<MovieActorUpdateWithoutMovieInput, MovieActorUncheckedUpdateWithoutMovieInput>
  }

  export type MovieActorUpdateManyWithWhereWithoutMovieInput = {
    where: MovieActorScalarWhereInput
    data: XOR<MovieActorUpdateManyMutationInput, MovieActorUncheckedUpdateManyWithoutMovieInput>
  }

  export type MovieActorScalarWhereInput = {
    AND?: MovieActorScalarWhereInput | MovieActorScalarWhereInput[]
    OR?: MovieActorScalarWhereInput[]
    NOT?: MovieActorScalarWhereInput | MovieActorScalarWhereInput[]
    personId?: UuidFilter<"MovieActor"> | string
    movieId?: UuidFilter<"MovieActor"> | string
    characterName?: StringFilter<"MovieActor"> | string
    castOrder?: IntFilter<"MovieActor"> | number
  }

  export type MovieDirectorUpsertWithWhereUniqueWithoutMovieInput = {
    where: MovieDirectorWhereUniqueInput
    update: XOR<MovieDirectorUpdateWithoutMovieInput, MovieDirectorUncheckedUpdateWithoutMovieInput>
    create: XOR<MovieDirectorCreateWithoutMovieInput, MovieDirectorUncheckedCreateWithoutMovieInput>
  }

  export type MovieDirectorUpdateWithWhereUniqueWithoutMovieInput = {
    where: MovieDirectorWhereUniqueInput
    data: XOR<MovieDirectorUpdateWithoutMovieInput, MovieDirectorUncheckedUpdateWithoutMovieInput>
  }

  export type MovieDirectorUpdateManyWithWhereWithoutMovieInput = {
    where: MovieDirectorScalarWhereInput
    data: XOR<MovieDirectorUpdateManyMutationInput, MovieDirectorUncheckedUpdateManyWithoutMovieInput>
  }

  export type MovieDirectorScalarWhereInput = {
    AND?: MovieDirectorScalarWhereInput | MovieDirectorScalarWhereInput[]
    OR?: MovieDirectorScalarWhereInput[]
    NOT?: MovieDirectorScalarWhereInput | MovieDirectorScalarWhereInput[]
    personId?: UuidFilter<"MovieDirector"> | string
    movieId?: UuidFilter<"MovieDirector"> | string
    type?: EnumDirectorTypeFilter<"MovieDirector"> | $Enums.DirectorType
  }

  export type MovieProducerUpsertWithWhereUniqueWithoutMovieInput = {
    where: MovieProducerWhereUniqueInput
    update: XOR<MovieProducerUpdateWithoutMovieInput, MovieProducerUncheckedUpdateWithoutMovieInput>
    create: XOR<MovieProducerCreateWithoutMovieInput, MovieProducerUncheckedCreateWithoutMovieInput>
  }

  export type MovieProducerUpdateWithWhereUniqueWithoutMovieInput = {
    where: MovieProducerWhereUniqueInput
    data: XOR<MovieProducerUpdateWithoutMovieInput, MovieProducerUncheckedUpdateWithoutMovieInput>
  }

  export type MovieProducerUpdateManyWithWhereWithoutMovieInput = {
    where: MovieProducerScalarWhereInput
    data: XOR<MovieProducerUpdateManyMutationInput, MovieProducerUncheckedUpdateManyWithoutMovieInput>
  }

  export type MovieProducerScalarWhereInput = {
    AND?: MovieProducerScalarWhereInput | MovieProducerScalarWhereInput[]
    OR?: MovieProducerScalarWhereInput[]
    NOT?: MovieProducerScalarWhereInput | MovieProducerScalarWhereInput[]
    personId?: UuidFilter<"MovieProducer"> | string
    movieId?: UuidFilter<"MovieProducer"> | string
    type?: EnumProducerTypeFilter<"MovieProducer"> | $Enums.ProducerType
  }

  export type MovieCinemaOverrideUpsertWithWhereUniqueWithoutMovieInput = {
    where: MovieCinemaOverrideWhereUniqueInput
    update: XOR<MovieCinemaOverrideUpdateWithoutMovieInput, MovieCinemaOverrideUncheckedUpdateWithoutMovieInput>
    create: XOR<MovieCinemaOverrideCreateWithoutMovieInput, MovieCinemaOverrideUncheckedCreateWithoutMovieInput>
  }

  export type MovieCinemaOverrideUpdateWithWhereUniqueWithoutMovieInput = {
    where: MovieCinemaOverrideWhereUniqueInput
    data: XOR<MovieCinemaOverrideUpdateWithoutMovieInput, MovieCinemaOverrideUncheckedUpdateWithoutMovieInput>
  }

  export type MovieCinemaOverrideUpdateManyWithWhereWithoutMovieInput = {
    where: MovieCinemaOverrideScalarWhereInput
    data: XOR<MovieCinemaOverrideUpdateManyMutationInput, MovieCinemaOverrideUncheckedUpdateManyWithoutMovieInput>
  }

  export type MovieProjectionUpsertWithWhereUniqueWithoutMovieInput = {
    where: MovieProjectionWhereUniqueInput
    update: XOR<MovieProjectionUpdateWithoutMovieInput, MovieProjectionUncheckedUpdateWithoutMovieInput>
    create: XOR<MovieProjectionCreateWithoutMovieInput, MovieProjectionUncheckedCreateWithoutMovieInput>
  }

  export type MovieProjectionUpdateWithWhereUniqueWithoutMovieInput = {
    where: MovieProjectionWhereUniqueInput
    data: XOR<MovieProjectionUpdateWithoutMovieInput, MovieProjectionUncheckedUpdateWithoutMovieInput>
  }

  export type MovieProjectionUpdateManyWithWhereWithoutMovieInput = {
    where: MovieProjectionScalarWhereInput
    data: XOR<MovieProjectionUpdateManyMutationInput, MovieProjectionUncheckedUpdateManyWithoutMovieInput>
  }

  export type MovieActorCreateWithoutPersonInput = {
    characterName: string
    castOrder: number
    movie: MovieCreateNestedOneWithoutActorsInput
  }

  export type MovieActorUncheckedCreateWithoutPersonInput = {
    movieId: string
    characterName: string
    castOrder: number
  }

  export type MovieActorCreateOrConnectWithoutPersonInput = {
    where: MovieActorWhereUniqueInput
    create: XOR<MovieActorCreateWithoutPersonInput, MovieActorUncheckedCreateWithoutPersonInput>
  }

  export type MovieActorCreateManyPersonInputEnvelope = {
    data: MovieActorCreateManyPersonInput | MovieActorCreateManyPersonInput[]
    skipDuplicates?: boolean
  }

  export type MovieDirectorCreateWithoutPersonInput = {
    type: $Enums.DirectorType
    movie: MovieCreateNestedOneWithoutDirectorsInput
  }

  export type MovieDirectorUncheckedCreateWithoutPersonInput = {
    movieId: string
    type: $Enums.DirectorType
  }

  export type MovieDirectorCreateOrConnectWithoutPersonInput = {
    where: MovieDirectorWhereUniqueInput
    create: XOR<MovieDirectorCreateWithoutPersonInput, MovieDirectorUncheckedCreateWithoutPersonInput>
  }

  export type MovieDirectorCreateManyPersonInputEnvelope = {
    data: MovieDirectorCreateManyPersonInput | MovieDirectorCreateManyPersonInput[]
    skipDuplicates?: boolean
  }

  export type MovieProducerCreateWithoutPersonInput = {
    type: $Enums.ProducerType
    movie: MovieCreateNestedOneWithoutProducersInput
  }

  export type MovieProducerUncheckedCreateWithoutPersonInput = {
    movieId: string
    type: $Enums.ProducerType
  }

  export type MovieProducerCreateOrConnectWithoutPersonInput = {
    where: MovieProducerWhereUniqueInput
    create: XOR<MovieProducerCreateWithoutPersonInput, MovieProducerUncheckedCreateWithoutPersonInput>
  }

  export type MovieProducerCreateManyPersonInputEnvelope = {
    data: MovieProducerCreateManyPersonInput | MovieProducerCreateManyPersonInput[]
    skipDuplicates?: boolean
  }

  export type MovieActorUpsertWithWhereUniqueWithoutPersonInput = {
    where: MovieActorWhereUniqueInput
    update: XOR<MovieActorUpdateWithoutPersonInput, MovieActorUncheckedUpdateWithoutPersonInput>
    create: XOR<MovieActorCreateWithoutPersonInput, MovieActorUncheckedCreateWithoutPersonInput>
  }

  export type MovieActorUpdateWithWhereUniqueWithoutPersonInput = {
    where: MovieActorWhereUniqueInput
    data: XOR<MovieActorUpdateWithoutPersonInput, MovieActorUncheckedUpdateWithoutPersonInput>
  }

  export type MovieActorUpdateManyWithWhereWithoutPersonInput = {
    where: MovieActorScalarWhereInput
    data: XOR<MovieActorUpdateManyMutationInput, MovieActorUncheckedUpdateManyWithoutPersonInput>
  }

  export type MovieDirectorUpsertWithWhereUniqueWithoutPersonInput = {
    where: MovieDirectorWhereUniqueInput
    update: XOR<MovieDirectorUpdateWithoutPersonInput, MovieDirectorUncheckedUpdateWithoutPersonInput>
    create: XOR<MovieDirectorCreateWithoutPersonInput, MovieDirectorUncheckedCreateWithoutPersonInput>
  }

  export type MovieDirectorUpdateWithWhereUniqueWithoutPersonInput = {
    where: MovieDirectorWhereUniqueInput
    data: XOR<MovieDirectorUpdateWithoutPersonInput, MovieDirectorUncheckedUpdateWithoutPersonInput>
  }

  export type MovieDirectorUpdateManyWithWhereWithoutPersonInput = {
    where: MovieDirectorScalarWhereInput
    data: XOR<MovieDirectorUpdateManyMutationInput, MovieDirectorUncheckedUpdateManyWithoutPersonInput>
  }

  export type MovieProducerUpsertWithWhereUniqueWithoutPersonInput = {
    where: MovieProducerWhereUniqueInput
    update: XOR<MovieProducerUpdateWithoutPersonInput, MovieProducerUncheckedUpdateWithoutPersonInput>
    create: XOR<MovieProducerCreateWithoutPersonInput, MovieProducerUncheckedCreateWithoutPersonInput>
  }

  export type MovieProducerUpdateWithWhereUniqueWithoutPersonInput = {
    where: MovieProducerWhereUniqueInput
    data: XOR<MovieProducerUpdateWithoutPersonInput, MovieProducerUncheckedUpdateWithoutPersonInput>
  }

  export type MovieProducerUpdateManyWithWhereWithoutPersonInput = {
    where: MovieProducerScalarWhereInput
    data: XOR<MovieProducerUpdateManyMutationInput, MovieProducerUncheckedUpdateManyWithoutPersonInput>
  }

  export type PersonCreateWithoutActorInMoviesInput = {
    id?: string
    name: string
    biography?: string
    dateOfBirth?: Date | string | null
    dateOfDeath?: Date | string | null
    gender: $Enums.Gender
    createdAt?: Date | string
    updatedAt: Date | string
    externalId: string
    externalType: $Enums.InputProvider
    additionalData?: JsonNullValueInput | InputJsonValue
    directorInMovies?: MovieDirectorCreateNestedManyWithoutPersonInput
    producerInMovies?: MovieProducerCreateNestedManyWithoutPersonInput
  }

  export type PersonUncheckedCreateWithoutActorInMoviesInput = {
    id?: string
    name: string
    biography?: string
    dateOfBirth?: Date | string | null
    dateOfDeath?: Date | string | null
    gender: $Enums.Gender
    createdAt?: Date | string
    updatedAt: Date | string
    externalId: string
    externalType: $Enums.InputProvider
    additionalData?: JsonNullValueInput | InputJsonValue
    directorInMovies?: MovieDirectorUncheckedCreateNestedManyWithoutPersonInput
    producerInMovies?: MovieProducerUncheckedCreateNestedManyWithoutPersonInput
  }

  export type PersonCreateOrConnectWithoutActorInMoviesInput = {
    where: PersonWhereUniqueInput
    create: XOR<PersonCreateWithoutActorInMoviesInput, PersonUncheckedCreateWithoutActorInMoviesInput>
  }

  export type MovieCreateWithoutActorsInput = {
    id?: string
    title?: string | null
    originalTitle: string
    localizedTitle?: string | null
    plot: string
    localizedPlot?: string | null
    runtimeMinutes: number
    posterImages?: JsonNullValueInput | InputJsonValue
    videos?: JsonNullValueInput | InputJsonValue
    rating: number
    releaseDate: Date | string
    createdAt?: Date | string
    updatedAt: Date | string
    externalId: string
    externalType: $Enums.InputProvider
    additionalData?: JsonNullValueInput | InputJsonValue
    genres?: GenreCreateNestedManyWithoutMoviesInput
    originalLanguage: LanguageCreateNestedOneWithoutOriginalLanguageMoviesInput
    countryOfOrigin: CountryCreateNestedOneWithoutMoviesInput
    directors?: MovieDirectorCreateNestedManyWithoutMovieInput
    producers?: MovieProducerCreateNestedManyWithoutMovieInput
    movieCinemaOverrides?: MovieCinemaOverrideCreateNestedManyWithoutMovieInput
    movieProjections?: MovieProjectionCreateNestedManyWithoutMovieInput
  }

  export type MovieUncheckedCreateWithoutActorsInput = {
    id?: string
    title?: string | null
    originalTitle: string
    localizedTitle?: string | null
    plot: string
    localizedPlot?: string | null
    runtimeMinutes: number
    originalLanguageId: string
    countryOfOriginId: string
    posterImages?: JsonNullValueInput | InputJsonValue
    videos?: JsonNullValueInput | InputJsonValue
    rating: number
    releaseDate: Date | string
    createdAt?: Date | string
    updatedAt: Date | string
    externalId: string
    externalType: $Enums.InputProvider
    additionalData?: JsonNullValueInput | InputJsonValue
    genres?: GenreUncheckedCreateNestedManyWithoutMoviesInput
    directors?: MovieDirectorUncheckedCreateNestedManyWithoutMovieInput
    producers?: MovieProducerUncheckedCreateNestedManyWithoutMovieInput
    movieCinemaOverrides?: MovieCinemaOverrideUncheckedCreateNestedManyWithoutMovieInput
    movieProjections?: MovieProjectionUncheckedCreateNestedManyWithoutMovieInput
  }

  export type MovieCreateOrConnectWithoutActorsInput = {
    where: MovieWhereUniqueInput
    create: XOR<MovieCreateWithoutActorsInput, MovieUncheckedCreateWithoutActorsInput>
  }

  export type PersonUpsertWithoutActorInMoviesInput = {
    update: XOR<PersonUpdateWithoutActorInMoviesInput, PersonUncheckedUpdateWithoutActorInMoviesInput>
    create: XOR<PersonCreateWithoutActorInMoviesInput, PersonUncheckedCreateWithoutActorInMoviesInput>
    where?: PersonWhereInput
  }

  export type PersonUpdateToOneWithWhereWithoutActorInMoviesInput = {
    where?: PersonWhereInput
    data: XOR<PersonUpdateWithoutActorInMoviesInput, PersonUncheckedUpdateWithoutActorInMoviesInput>
  }

  export type PersonUpdateWithoutActorInMoviesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    biography?: StringFieldUpdateOperationsInput | string
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dateOfDeath?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    externalId?: StringFieldUpdateOperationsInput | string
    externalType?: EnumInputProviderFieldUpdateOperationsInput | $Enums.InputProvider
    additionalData?: JsonNullValueInput | InputJsonValue
    directorInMovies?: MovieDirectorUpdateManyWithoutPersonNestedInput
    producerInMovies?: MovieProducerUpdateManyWithoutPersonNestedInput
  }

  export type PersonUncheckedUpdateWithoutActorInMoviesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    biography?: StringFieldUpdateOperationsInput | string
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dateOfDeath?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    externalId?: StringFieldUpdateOperationsInput | string
    externalType?: EnumInputProviderFieldUpdateOperationsInput | $Enums.InputProvider
    additionalData?: JsonNullValueInput | InputJsonValue
    directorInMovies?: MovieDirectorUncheckedUpdateManyWithoutPersonNestedInput
    producerInMovies?: MovieProducerUncheckedUpdateManyWithoutPersonNestedInput
  }

  export type MovieUpsertWithoutActorsInput = {
    update: XOR<MovieUpdateWithoutActorsInput, MovieUncheckedUpdateWithoutActorsInput>
    create: XOR<MovieCreateWithoutActorsInput, MovieUncheckedCreateWithoutActorsInput>
    where?: MovieWhereInput
  }

  export type MovieUpdateToOneWithWhereWithoutActorsInput = {
    where?: MovieWhereInput
    data: XOR<MovieUpdateWithoutActorsInput, MovieUncheckedUpdateWithoutActorsInput>
  }

  export type MovieUpdateWithoutActorsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    originalTitle?: StringFieldUpdateOperationsInput | string
    localizedTitle?: NullableStringFieldUpdateOperationsInput | string | null
    plot?: StringFieldUpdateOperationsInput | string
    localizedPlot?: NullableStringFieldUpdateOperationsInput | string | null
    runtimeMinutes?: IntFieldUpdateOperationsInput | number
    posterImages?: JsonNullValueInput | InputJsonValue
    videos?: JsonNullValueInput | InputJsonValue
    rating?: IntFieldUpdateOperationsInput | number
    releaseDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    externalId?: StringFieldUpdateOperationsInput | string
    externalType?: EnumInputProviderFieldUpdateOperationsInput | $Enums.InputProvider
    additionalData?: JsonNullValueInput | InputJsonValue
    genres?: GenreUpdateManyWithoutMoviesNestedInput
    originalLanguage?: LanguageUpdateOneRequiredWithoutOriginalLanguageMoviesNestedInput
    countryOfOrigin?: CountryUpdateOneRequiredWithoutMoviesNestedInput
    directors?: MovieDirectorUpdateManyWithoutMovieNestedInput
    producers?: MovieProducerUpdateManyWithoutMovieNestedInput
    movieCinemaOverrides?: MovieCinemaOverrideUpdateManyWithoutMovieNestedInput
    movieProjections?: MovieProjectionUpdateManyWithoutMovieNestedInput
  }

  export type MovieUncheckedUpdateWithoutActorsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    originalTitle?: StringFieldUpdateOperationsInput | string
    localizedTitle?: NullableStringFieldUpdateOperationsInput | string | null
    plot?: StringFieldUpdateOperationsInput | string
    localizedPlot?: NullableStringFieldUpdateOperationsInput | string | null
    runtimeMinutes?: IntFieldUpdateOperationsInput | number
    originalLanguageId?: StringFieldUpdateOperationsInput | string
    countryOfOriginId?: StringFieldUpdateOperationsInput | string
    posterImages?: JsonNullValueInput | InputJsonValue
    videos?: JsonNullValueInput | InputJsonValue
    rating?: IntFieldUpdateOperationsInput | number
    releaseDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    externalId?: StringFieldUpdateOperationsInput | string
    externalType?: EnumInputProviderFieldUpdateOperationsInput | $Enums.InputProvider
    additionalData?: JsonNullValueInput | InputJsonValue
    genres?: GenreUncheckedUpdateManyWithoutMoviesNestedInput
    directors?: MovieDirectorUncheckedUpdateManyWithoutMovieNestedInput
    producers?: MovieProducerUncheckedUpdateManyWithoutMovieNestedInput
    movieCinemaOverrides?: MovieCinemaOverrideUncheckedUpdateManyWithoutMovieNestedInput
    movieProjections?: MovieProjectionUncheckedUpdateManyWithoutMovieNestedInput
  }

  export type PersonCreateWithoutDirectorInMoviesInput = {
    id?: string
    name: string
    biography?: string
    dateOfBirth?: Date | string | null
    dateOfDeath?: Date | string | null
    gender: $Enums.Gender
    createdAt?: Date | string
    updatedAt: Date | string
    externalId: string
    externalType: $Enums.InputProvider
    additionalData?: JsonNullValueInput | InputJsonValue
    actorInMovies?: MovieActorCreateNestedManyWithoutPersonInput
    producerInMovies?: MovieProducerCreateNestedManyWithoutPersonInput
  }

  export type PersonUncheckedCreateWithoutDirectorInMoviesInput = {
    id?: string
    name: string
    biography?: string
    dateOfBirth?: Date | string | null
    dateOfDeath?: Date | string | null
    gender: $Enums.Gender
    createdAt?: Date | string
    updatedAt: Date | string
    externalId: string
    externalType: $Enums.InputProvider
    additionalData?: JsonNullValueInput | InputJsonValue
    actorInMovies?: MovieActorUncheckedCreateNestedManyWithoutPersonInput
    producerInMovies?: MovieProducerUncheckedCreateNestedManyWithoutPersonInput
  }

  export type PersonCreateOrConnectWithoutDirectorInMoviesInput = {
    where: PersonWhereUniqueInput
    create: XOR<PersonCreateWithoutDirectorInMoviesInput, PersonUncheckedCreateWithoutDirectorInMoviesInput>
  }

  export type MovieCreateWithoutDirectorsInput = {
    id?: string
    title?: string | null
    originalTitle: string
    localizedTitle?: string | null
    plot: string
    localizedPlot?: string | null
    runtimeMinutes: number
    posterImages?: JsonNullValueInput | InputJsonValue
    videos?: JsonNullValueInput | InputJsonValue
    rating: number
    releaseDate: Date | string
    createdAt?: Date | string
    updatedAt: Date | string
    externalId: string
    externalType: $Enums.InputProvider
    additionalData?: JsonNullValueInput | InputJsonValue
    genres?: GenreCreateNestedManyWithoutMoviesInput
    originalLanguage: LanguageCreateNestedOneWithoutOriginalLanguageMoviesInput
    countryOfOrigin: CountryCreateNestedOneWithoutMoviesInput
    actors?: MovieActorCreateNestedManyWithoutMovieInput
    producers?: MovieProducerCreateNestedManyWithoutMovieInput
    movieCinemaOverrides?: MovieCinemaOverrideCreateNestedManyWithoutMovieInput
    movieProjections?: MovieProjectionCreateNestedManyWithoutMovieInput
  }

  export type MovieUncheckedCreateWithoutDirectorsInput = {
    id?: string
    title?: string | null
    originalTitle: string
    localizedTitle?: string | null
    plot: string
    localizedPlot?: string | null
    runtimeMinutes: number
    originalLanguageId: string
    countryOfOriginId: string
    posterImages?: JsonNullValueInput | InputJsonValue
    videos?: JsonNullValueInput | InputJsonValue
    rating: number
    releaseDate: Date | string
    createdAt?: Date | string
    updatedAt: Date | string
    externalId: string
    externalType: $Enums.InputProvider
    additionalData?: JsonNullValueInput | InputJsonValue
    genres?: GenreUncheckedCreateNestedManyWithoutMoviesInput
    actors?: MovieActorUncheckedCreateNestedManyWithoutMovieInput
    producers?: MovieProducerUncheckedCreateNestedManyWithoutMovieInput
    movieCinemaOverrides?: MovieCinemaOverrideUncheckedCreateNestedManyWithoutMovieInput
    movieProjections?: MovieProjectionUncheckedCreateNestedManyWithoutMovieInput
  }

  export type MovieCreateOrConnectWithoutDirectorsInput = {
    where: MovieWhereUniqueInput
    create: XOR<MovieCreateWithoutDirectorsInput, MovieUncheckedCreateWithoutDirectorsInput>
  }

  export type PersonUpsertWithoutDirectorInMoviesInput = {
    update: XOR<PersonUpdateWithoutDirectorInMoviesInput, PersonUncheckedUpdateWithoutDirectorInMoviesInput>
    create: XOR<PersonCreateWithoutDirectorInMoviesInput, PersonUncheckedCreateWithoutDirectorInMoviesInput>
    where?: PersonWhereInput
  }

  export type PersonUpdateToOneWithWhereWithoutDirectorInMoviesInput = {
    where?: PersonWhereInput
    data: XOR<PersonUpdateWithoutDirectorInMoviesInput, PersonUncheckedUpdateWithoutDirectorInMoviesInput>
  }

  export type PersonUpdateWithoutDirectorInMoviesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    biography?: StringFieldUpdateOperationsInput | string
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dateOfDeath?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    externalId?: StringFieldUpdateOperationsInput | string
    externalType?: EnumInputProviderFieldUpdateOperationsInput | $Enums.InputProvider
    additionalData?: JsonNullValueInput | InputJsonValue
    actorInMovies?: MovieActorUpdateManyWithoutPersonNestedInput
    producerInMovies?: MovieProducerUpdateManyWithoutPersonNestedInput
  }

  export type PersonUncheckedUpdateWithoutDirectorInMoviesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    biography?: StringFieldUpdateOperationsInput | string
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dateOfDeath?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    externalId?: StringFieldUpdateOperationsInput | string
    externalType?: EnumInputProviderFieldUpdateOperationsInput | $Enums.InputProvider
    additionalData?: JsonNullValueInput | InputJsonValue
    actorInMovies?: MovieActorUncheckedUpdateManyWithoutPersonNestedInput
    producerInMovies?: MovieProducerUncheckedUpdateManyWithoutPersonNestedInput
  }

  export type MovieUpsertWithoutDirectorsInput = {
    update: XOR<MovieUpdateWithoutDirectorsInput, MovieUncheckedUpdateWithoutDirectorsInput>
    create: XOR<MovieCreateWithoutDirectorsInput, MovieUncheckedCreateWithoutDirectorsInput>
    where?: MovieWhereInput
  }

  export type MovieUpdateToOneWithWhereWithoutDirectorsInput = {
    where?: MovieWhereInput
    data: XOR<MovieUpdateWithoutDirectorsInput, MovieUncheckedUpdateWithoutDirectorsInput>
  }

  export type MovieUpdateWithoutDirectorsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    originalTitle?: StringFieldUpdateOperationsInput | string
    localizedTitle?: NullableStringFieldUpdateOperationsInput | string | null
    plot?: StringFieldUpdateOperationsInput | string
    localizedPlot?: NullableStringFieldUpdateOperationsInput | string | null
    runtimeMinutes?: IntFieldUpdateOperationsInput | number
    posterImages?: JsonNullValueInput | InputJsonValue
    videos?: JsonNullValueInput | InputJsonValue
    rating?: IntFieldUpdateOperationsInput | number
    releaseDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    externalId?: StringFieldUpdateOperationsInput | string
    externalType?: EnumInputProviderFieldUpdateOperationsInput | $Enums.InputProvider
    additionalData?: JsonNullValueInput | InputJsonValue
    genres?: GenreUpdateManyWithoutMoviesNestedInput
    originalLanguage?: LanguageUpdateOneRequiredWithoutOriginalLanguageMoviesNestedInput
    countryOfOrigin?: CountryUpdateOneRequiredWithoutMoviesNestedInput
    actors?: MovieActorUpdateManyWithoutMovieNestedInput
    producers?: MovieProducerUpdateManyWithoutMovieNestedInput
    movieCinemaOverrides?: MovieCinemaOverrideUpdateManyWithoutMovieNestedInput
    movieProjections?: MovieProjectionUpdateManyWithoutMovieNestedInput
  }

  export type MovieUncheckedUpdateWithoutDirectorsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    originalTitle?: StringFieldUpdateOperationsInput | string
    localizedTitle?: NullableStringFieldUpdateOperationsInput | string | null
    plot?: StringFieldUpdateOperationsInput | string
    localizedPlot?: NullableStringFieldUpdateOperationsInput | string | null
    runtimeMinutes?: IntFieldUpdateOperationsInput | number
    originalLanguageId?: StringFieldUpdateOperationsInput | string
    countryOfOriginId?: StringFieldUpdateOperationsInput | string
    posterImages?: JsonNullValueInput | InputJsonValue
    videos?: JsonNullValueInput | InputJsonValue
    rating?: IntFieldUpdateOperationsInput | number
    releaseDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    externalId?: StringFieldUpdateOperationsInput | string
    externalType?: EnumInputProviderFieldUpdateOperationsInput | $Enums.InputProvider
    additionalData?: JsonNullValueInput | InputJsonValue
    genres?: GenreUncheckedUpdateManyWithoutMoviesNestedInput
    actors?: MovieActorUncheckedUpdateManyWithoutMovieNestedInput
    producers?: MovieProducerUncheckedUpdateManyWithoutMovieNestedInput
    movieCinemaOverrides?: MovieCinemaOverrideUncheckedUpdateManyWithoutMovieNestedInput
    movieProjections?: MovieProjectionUncheckedUpdateManyWithoutMovieNestedInput
  }

  export type PersonCreateWithoutProducerInMoviesInput = {
    id?: string
    name: string
    biography?: string
    dateOfBirth?: Date | string | null
    dateOfDeath?: Date | string | null
    gender: $Enums.Gender
    createdAt?: Date | string
    updatedAt: Date | string
    externalId: string
    externalType: $Enums.InputProvider
    additionalData?: JsonNullValueInput | InputJsonValue
    actorInMovies?: MovieActorCreateNestedManyWithoutPersonInput
    directorInMovies?: MovieDirectorCreateNestedManyWithoutPersonInput
  }

  export type PersonUncheckedCreateWithoutProducerInMoviesInput = {
    id?: string
    name: string
    biography?: string
    dateOfBirth?: Date | string | null
    dateOfDeath?: Date | string | null
    gender: $Enums.Gender
    createdAt?: Date | string
    updatedAt: Date | string
    externalId: string
    externalType: $Enums.InputProvider
    additionalData?: JsonNullValueInput | InputJsonValue
    actorInMovies?: MovieActorUncheckedCreateNestedManyWithoutPersonInput
    directorInMovies?: MovieDirectorUncheckedCreateNestedManyWithoutPersonInput
  }

  export type PersonCreateOrConnectWithoutProducerInMoviesInput = {
    where: PersonWhereUniqueInput
    create: XOR<PersonCreateWithoutProducerInMoviesInput, PersonUncheckedCreateWithoutProducerInMoviesInput>
  }

  export type MovieCreateWithoutProducersInput = {
    id?: string
    title?: string | null
    originalTitle: string
    localizedTitle?: string | null
    plot: string
    localizedPlot?: string | null
    runtimeMinutes: number
    posterImages?: JsonNullValueInput | InputJsonValue
    videos?: JsonNullValueInput | InputJsonValue
    rating: number
    releaseDate: Date | string
    createdAt?: Date | string
    updatedAt: Date | string
    externalId: string
    externalType: $Enums.InputProvider
    additionalData?: JsonNullValueInput | InputJsonValue
    genres?: GenreCreateNestedManyWithoutMoviesInput
    originalLanguage: LanguageCreateNestedOneWithoutOriginalLanguageMoviesInput
    countryOfOrigin: CountryCreateNestedOneWithoutMoviesInput
    actors?: MovieActorCreateNestedManyWithoutMovieInput
    directors?: MovieDirectorCreateNestedManyWithoutMovieInput
    movieCinemaOverrides?: MovieCinemaOverrideCreateNestedManyWithoutMovieInput
    movieProjections?: MovieProjectionCreateNestedManyWithoutMovieInput
  }

  export type MovieUncheckedCreateWithoutProducersInput = {
    id?: string
    title?: string | null
    originalTitle: string
    localizedTitle?: string | null
    plot: string
    localizedPlot?: string | null
    runtimeMinutes: number
    originalLanguageId: string
    countryOfOriginId: string
    posterImages?: JsonNullValueInput | InputJsonValue
    videos?: JsonNullValueInput | InputJsonValue
    rating: number
    releaseDate: Date | string
    createdAt?: Date | string
    updatedAt: Date | string
    externalId: string
    externalType: $Enums.InputProvider
    additionalData?: JsonNullValueInput | InputJsonValue
    genres?: GenreUncheckedCreateNestedManyWithoutMoviesInput
    actors?: MovieActorUncheckedCreateNestedManyWithoutMovieInput
    directors?: MovieDirectorUncheckedCreateNestedManyWithoutMovieInput
    movieCinemaOverrides?: MovieCinemaOverrideUncheckedCreateNestedManyWithoutMovieInput
    movieProjections?: MovieProjectionUncheckedCreateNestedManyWithoutMovieInput
  }

  export type MovieCreateOrConnectWithoutProducersInput = {
    where: MovieWhereUniqueInput
    create: XOR<MovieCreateWithoutProducersInput, MovieUncheckedCreateWithoutProducersInput>
  }

  export type PersonUpsertWithoutProducerInMoviesInput = {
    update: XOR<PersonUpdateWithoutProducerInMoviesInput, PersonUncheckedUpdateWithoutProducerInMoviesInput>
    create: XOR<PersonCreateWithoutProducerInMoviesInput, PersonUncheckedCreateWithoutProducerInMoviesInput>
    where?: PersonWhereInput
  }

  export type PersonUpdateToOneWithWhereWithoutProducerInMoviesInput = {
    where?: PersonWhereInput
    data: XOR<PersonUpdateWithoutProducerInMoviesInput, PersonUncheckedUpdateWithoutProducerInMoviesInput>
  }

  export type PersonUpdateWithoutProducerInMoviesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    biography?: StringFieldUpdateOperationsInput | string
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dateOfDeath?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    externalId?: StringFieldUpdateOperationsInput | string
    externalType?: EnumInputProviderFieldUpdateOperationsInput | $Enums.InputProvider
    additionalData?: JsonNullValueInput | InputJsonValue
    actorInMovies?: MovieActorUpdateManyWithoutPersonNestedInput
    directorInMovies?: MovieDirectorUpdateManyWithoutPersonNestedInput
  }

  export type PersonUncheckedUpdateWithoutProducerInMoviesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    biography?: StringFieldUpdateOperationsInput | string
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dateOfDeath?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    externalId?: StringFieldUpdateOperationsInput | string
    externalType?: EnumInputProviderFieldUpdateOperationsInput | $Enums.InputProvider
    additionalData?: JsonNullValueInput | InputJsonValue
    actorInMovies?: MovieActorUncheckedUpdateManyWithoutPersonNestedInput
    directorInMovies?: MovieDirectorUncheckedUpdateManyWithoutPersonNestedInput
  }

  export type MovieUpsertWithoutProducersInput = {
    update: XOR<MovieUpdateWithoutProducersInput, MovieUncheckedUpdateWithoutProducersInput>
    create: XOR<MovieCreateWithoutProducersInput, MovieUncheckedCreateWithoutProducersInput>
    where?: MovieWhereInput
  }

  export type MovieUpdateToOneWithWhereWithoutProducersInput = {
    where?: MovieWhereInput
    data: XOR<MovieUpdateWithoutProducersInput, MovieUncheckedUpdateWithoutProducersInput>
  }

  export type MovieUpdateWithoutProducersInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    originalTitle?: StringFieldUpdateOperationsInput | string
    localizedTitle?: NullableStringFieldUpdateOperationsInput | string | null
    plot?: StringFieldUpdateOperationsInput | string
    localizedPlot?: NullableStringFieldUpdateOperationsInput | string | null
    runtimeMinutes?: IntFieldUpdateOperationsInput | number
    posterImages?: JsonNullValueInput | InputJsonValue
    videos?: JsonNullValueInput | InputJsonValue
    rating?: IntFieldUpdateOperationsInput | number
    releaseDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    externalId?: StringFieldUpdateOperationsInput | string
    externalType?: EnumInputProviderFieldUpdateOperationsInput | $Enums.InputProvider
    additionalData?: JsonNullValueInput | InputJsonValue
    genres?: GenreUpdateManyWithoutMoviesNestedInput
    originalLanguage?: LanguageUpdateOneRequiredWithoutOriginalLanguageMoviesNestedInput
    countryOfOrigin?: CountryUpdateOneRequiredWithoutMoviesNestedInput
    actors?: MovieActorUpdateManyWithoutMovieNestedInput
    directors?: MovieDirectorUpdateManyWithoutMovieNestedInput
    movieCinemaOverrides?: MovieCinemaOverrideUpdateManyWithoutMovieNestedInput
    movieProjections?: MovieProjectionUpdateManyWithoutMovieNestedInput
  }

  export type MovieUncheckedUpdateWithoutProducersInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    originalTitle?: StringFieldUpdateOperationsInput | string
    localizedTitle?: NullableStringFieldUpdateOperationsInput | string | null
    plot?: StringFieldUpdateOperationsInput | string
    localizedPlot?: NullableStringFieldUpdateOperationsInput | string | null
    runtimeMinutes?: IntFieldUpdateOperationsInput | number
    originalLanguageId?: StringFieldUpdateOperationsInput | string
    countryOfOriginId?: StringFieldUpdateOperationsInput | string
    posterImages?: JsonNullValueInput | InputJsonValue
    videos?: JsonNullValueInput | InputJsonValue
    rating?: IntFieldUpdateOperationsInput | number
    releaseDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    externalId?: StringFieldUpdateOperationsInput | string
    externalType?: EnumInputProviderFieldUpdateOperationsInput | $Enums.InputProvider
    additionalData?: JsonNullValueInput | InputJsonValue
    genres?: GenreUncheckedUpdateManyWithoutMoviesNestedInput
    actors?: MovieActorUncheckedUpdateManyWithoutMovieNestedInput
    directors?: MovieDirectorUncheckedUpdateManyWithoutMovieNestedInput
    movieCinemaOverrides?: MovieCinemaOverrideUncheckedUpdateManyWithoutMovieNestedInput
    movieProjections?: MovieProjectionUncheckedUpdateManyWithoutMovieNestedInput
  }

  export type MovieCreateWithoutMovieCinemaOverridesInput = {
    id?: string
    title?: string | null
    originalTitle: string
    localizedTitle?: string | null
    plot: string
    localizedPlot?: string | null
    runtimeMinutes: number
    posterImages?: JsonNullValueInput | InputJsonValue
    videos?: JsonNullValueInput | InputJsonValue
    rating: number
    releaseDate: Date | string
    createdAt?: Date | string
    updatedAt: Date | string
    externalId: string
    externalType: $Enums.InputProvider
    additionalData?: JsonNullValueInput | InputJsonValue
    genres?: GenreCreateNestedManyWithoutMoviesInput
    originalLanguage: LanguageCreateNestedOneWithoutOriginalLanguageMoviesInput
    countryOfOrigin: CountryCreateNestedOneWithoutMoviesInput
    actors?: MovieActorCreateNestedManyWithoutMovieInput
    directors?: MovieDirectorCreateNestedManyWithoutMovieInput
    producers?: MovieProducerCreateNestedManyWithoutMovieInput
    movieProjections?: MovieProjectionCreateNestedManyWithoutMovieInput
  }

  export type MovieUncheckedCreateWithoutMovieCinemaOverridesInput = {
    id?: string
    title?: string | null
    originalTitle: string
    localizedTitle?: string | null
    plot: string
    localizedPlot?: string | null
    runtimeMinutes: number
    originalLanguageId: string
    countryOfOriginId: string
    posterImages?: JsonNullValueInput | InputJsonValue
    videos?: JsonNullValueInput | InputJsonValue
    rating: number
    releaseDate: Date | string
    createdAt?: Date | string
    updatedAt: Date | string
    externalId: string
    externalType: $Enums.InputProvider
    additionalData?: JsonNullValueInput | InputJsonValue
    genres?: GenreUncheckedCreateNestedManyWithoutMoviesInput
    actors?: MovieActorUncheckedCreateNestedManyWithoutMovieInput
    directors?: MovieDirectorUncheckedCreateNestedManyWithoutMovieInput
    producers?: MovieProducerUncheckedCreateNestedManyWithoutMovieInput
    movieProjections?: MovieProjectionUncheckedCreateNestedManyWithoutMovieInput
  }

  export type MovieCreateOrConnectWithoutMovieCinemaOverridesInput = {
    where: MovieWhereUniqueInput
    create: XOR<MovieCreateWithoutMovieCinemaOverridesInput, MovieUncheckedCreateWithoutMovieCinemaOverridesInput>
  }

  export type CinemaCreateWithoutMovieCinemaOverridesInput = {
    id?: string
    name: string
    description: string
    address: string
    rating: number
    phone?: JsonNullValueInput | InputJsonValue
    posterImages?: JsonNullValueInput | InputJsonValue
    geoLatitude?: Decimal | DecimalJsLike | number | string | null
    geoLongitude?: Decimal | DecimalJsLike | number | string | null
    city: CityCreateNestedOneWithoutCinemasInput
    cinemaTheaters?: CinemaTheaterCreateNestedManyWithoutCinemaInput
  }

  export type CinemaUncheckedCreateWithoutMovieCinemaOverridesInput = {
    id?: string
    name: string
    description: string
    cityId: string
    address: string
    rating: number
    phone?: JsonNullValueInput | InputJsonValue
    posterImages?: JsonNullValueInput | InputJsonValue
    geoLatitude?: Decimal | DecimalJsLike | number | string | null
    geoLongitude?: Decimal | DecimalJsLike | number | string | null
    cinemaTheaters?: CinemaTheaterUncheckedCreateNestedManyWithoutCinemaInput
  }

  export type CinemaCreateOrConnectWithoutMovieCinemaOverridesInput = {
    where: CinemaWhereUniqueInput
    create: XOR<CinemaCreateWithoutMovieCinemaOverridesInput, CinemaUncheckedCreateWithoutMovieCinemaOverridesInput>
  }

  export type MovieUpsertWithoutMovieCinemaOverridesInput = {
    update: XOR<MovieUpdateWithoutMovieCinemaOverridesInput, MovieUncheckedUpdateWithoutMovieCinemaOverridesInput>
    create: XOR<MovieCreateWithoutMovieCinemaOverridesInput, MovieUncheckedCreateWithoutMovieCinemaOverridesInput>
    where?: MovieWhereInput
  }

  export type MovieUpdateToOneWithWhereWithoutMovieCinemaOverridesInput = {
    where?: MovieWhereInput
    data: XOR<MovieUpdateWithoutMovieCinemaOverridesInput, MovieUncheckedUpdateWithoutMovieCinemaOverridesInput>
  }

  export type MovieUpdateWithoutMovieCinemaOverridesInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    originalTitle?: StringFieldUpdateOperationsInput | string
    localizedTitle?: NullableStringFieldUpdateOperationsInput | string | null
    plot?: StringFieldUpdateOperationsInput | string
    localizedPlot?: NullableStringFieldUpdateOperationsInput | string | null
    runtimeMinutes?: IntFieldUpdateOperationsInput | number
    posterImages?: JsonNullValueInput | InputJsonValue
    videos?: JsonNullValueInput | InputJsonValue
    rating?: IntFieldUpdateOperationsInput | number
    releaseDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    externalId?: StringFieldUpdateOperationsInput | string
    externalType?: EnumInputProviderFieldUpdateOperationsInput | $Enums.InputProvider
    additionalData?: JsonNullValueInput | InputJsonValue
    genres?: GenreUpdateManyWithoutMoviesNestedInput
    originalLanguage?: LanguageUpdateOneRequiredWithoutOriginalLanguageMoviesNestedInput
    countryOfOrigin?: CountryUpdateOneRequiredWithoutMoviesNestedInput
    actors?: MovieActorUpdateManyWithoutMovieNestedInput
    directors?: MovieDirectorUpdateManyWithoutMovieNestedInput
    producers?: MovieProducerUpdateManyWithoutMovieNestedInput
    movieProjections?: MovieProjectionUpdateManyWithoutMovieNestedInput
  }

  export type MovieUncheckedUpdateWithoutMovieCinemaOverridesInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    originalTitle?: StringFieldUpdateOperationsInput | string
    localizedTitle?: NullableStringFieldUpdateOperationsInput | string | null
    plot?: StringFieldUpdateOperationsInput | string
    localizedPlot?: NullableStringFieldUpdateOperationsInput | string | null
    runtimeMinutes?: IntFieldUpdateOperationsInput | number
    originalLanguageId?: StringFieldUpdateOperationsInput | string
    countryOfOriginId?: StringFieldUpdateOperationsInput | string
    posterImages?: JsonNullValueInput | InputJsonValue
    videos?: JsonNullValueInput | InputJsonValue
    rating?: IntFieldUpdateOperationsInput | number
    releaseDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    externalId?: StringFieldUpdateOperationsInput | string
    externalType?: EnumInputProviderFieldUpdateOperationsInput | $Enums.InputProvider
    additionalData?: JsonNullValueInput | InputJsonValue
    genres?: GenreUncheckedUpdateManyWithoutMoviesNestedInput
    actors?: MovieActorUncheckedUpdateManyWithoutMovieNestedInput
    directors?: MovieDirectorUncheckedUpdateManyWithoutMovieNestedInput
    producers?: MovieProducerUncheckedUpdateManyWithoutMovieNestedInput
    movieProjections?: MovieProjectionUncheckedUpdateManyWithoutMovieNestedInput
  }

  export type CinemaUpsertWithoutMovieCinemaOverridesInput = {
    update: XOR<CinemaUpdateWithoutMovieCinemaOverridesInput, CinemaUncheckedUpdateWithoutMovieCinemaOverridesInput>
    create: XOR<CinemaCreateWithoutMovieCinemaOverridesInput, CinemaUncheckedCreateWithoutMovieCinemaOverridesInput>
    where?: CinemaWhereInput
  }

  export type CinemaUpdateToOneWithWhereWithoutMovieCinemaOverridesInput = {
    where?: CinemaWhereInput
    data: XOR<CinemaUpdateWithoutMovieCinemaOverridesInput, CinemaUncheckedUpdateWithoutMovieCinemaOverridesInput>
  }

  export type CinemaUpdateWithoutMovieCinemaOverridesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    phone?: JsonNullValueInput | InputJsonValue
    posterImages?: JsonNullValueInput | InputJsonValue
    geoLatitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    geoLongitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    city?: CityUpdateOneRequiredWithoutCinemasNestedInput
    cinemaTheaters?: CinemaTheaterUpdateManyWithoutCinemaNestedInput
  }

  export type CinemaUncheckedUpdateWithoutMovieCinemaOverridesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    cityId?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    phone?: JsonNullValueInput | InputJsonValue
    posterImages?: JsonNullValueInput | InputJsonValue
    geoLatitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    geoLongitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    cinemaTheaters?: CinemaTheaterUncheckedUpdateManyWithoutCinemaNestedInput
  }

  export type MovieCreateWithoutMovieProjectionsInput = {
    id?: string
    title?: string | null
    originalTitle: string
    localizedTitle?: string | null
    plot: string
    localizedPlot?: string | null
    runtimeMinutes: number
    posterImages?: JsonNullValueInput | InputJsonValue
    videos?: JsonNullValueInput | InputJsonValue
    rating: number
    releaseDate: Date | string
    createdAt?: Date | string
    updatedAt: Date | string
    externalId: string
    externalType: $Enums.InputProvider
    additionalData?: JsonNullValueInput | InputJsonValue
    genres?: GenreCreateNestedManyWithoutMoviesInput
    originalLanguage: LanguageCreateNestedOneWithoutOriginalLanguageMoviesInput
    countryOfOrigin: CountryCreateNestedOneWithoutMoviesInput
    actors?: MovieActorCreateNestedManyWithoutMovieInput
    directors?: MovieDirectorCreateNestedManyWithoutMovieInput
    producers?: MovieProducerCreateNestedManyWithoutMovieInput
    movieCinemaOverrides?: MovieCinemaOverrideCreateNestedManyWithoutMovieInput
  }

  export type MovieUncheckedCreateWithoutMovieProjectionsInput = {
    id?: string
    title?: string | null
    originalTitle: string
    localizedTitle?: string | null
    plot: string
    localizedPlot?: string | null
    runtimeMinutes: number
    originalLanguageId: string
    countryOfOriginId: string
    posterImages?: JsonNullValueInput | InputJsonValue
    videos?: JsonNullValueInput | InputJsonValue
    rating: number
    releaseDate: Date | string
    createdAt?: Date | string
    updatedAt: Date | string
    externalId: string
    externalType: $Enums.InputProvider
    additionalData?: JsonNullValueInput | InputJsonValue
    genres?: GenreUncheckedCreateNestedManyWithoutMoviesInput
    actors?: MovieActorUncheckedCreateNestedManyWithoutMovieInput
    directors?: MovieDirectorUncheckedCreateNestedManyWithoutMovieInput
    producers?: MovieProducerUncheckedCreateNestedManyWithoutMovieInput
    movieCinemaOverrides?: MovieCinemaOverrideUncheckedCreateNestedManyWithoutMovieInput
  }

  export type MovieCreateOrConnectWithoutMovieProjectionsInput = {
    where: MovieWhereUniqueInput
    create: XOR<MovieCreateWithoutMovieProjectionsInput, MovieUncheckedCreateWithoutMovieProjectionsInput>
  }

  export type CinemaTheaterCreateWithoutMovieProjectionsInput = {
    id?: string
    name: string
    supports3D?: boolean
    posterImages?: JsonNullValueInput | InputJsonValue
    cinema: CinemaCreateNestedOneWithoutCinemaTheatersInput
    cinemaSeatGroups?: CinemaSeatGroupCreateNestedManyWithoutCinemaTheaterInput
  }

  export type CinemaTheaterUncheckedCreateWithoutMovieProjectionsInput = {
    id?: string
    name: string
    cinemaId: string
    supports3D?: boolean
    posterImages?: JsonNullValueInput | InputJsonValue
    cinemaSeatGroups?: CinemaSeatGroupUncheckedCreateNestedManyWithoutCinemaTheaterInput
  }

  export type CinemaTheaterCreateOrConnectWithoutMovieProjectionsInput = {
    where: CinemaTheaterWhereUniqueInput
    create: XOR<CinemaTheaterCreateWithoutMovieProjectionsInput, CinemaTheaterUncheckedCreateWithoutMovieProjectionsInput>
  }

  export type LanguageCreateWithoutDubbedLanguageMovieProjectionsInput = {
    code: string
    name: string
    originalLanguageMovies?: MovieCreateNestedManyWithoutOriginalLanguageInput
  }

  export type LanguageUncheckedCreateWithoutDubbedLanguageMovieProjectionsInput = {
    code: string
    name: string
    originalLanguageMovies?: MovieUncheckedCreateNestedManyWithoutOriginalLanguageInput
  }

  export type LanguageCreateOrConnectWithoutDubbedLanguageMovieProjectionsInput = {
    where: LanguageWhereUniqueInput
    create: XOR<LanguageCreateWithoutDubbedLanguageMovieProjectionsInput, LanguageUncheckedCreateWithoutDubbedLanguageMovieProjectionsInput>
  }

  export type ProjectionPriceCreateWithoutMovieProjectionInput = {
    type?: $Enums.PriceType
    price: Decimal | DecimalJsLike | number | string
    currencyCode: $Enums.CurrencyCode
    cinemaSeatGroup: CinemaSeatGroupCreateNestedOneWithoutProjectionPricesInput
  }

  export type ProjectionPriceUncheckedCreateWithoutMovieProjectionInput = {
    groupId: string
    type?: $Enums.PriceType
    price: Decimal | DecimalJsLike | number | string
    currencyCode: $Enums.CurrencyCode
  }

  export type ProjectionPriceCreateOrConnectWithoutMovieProjectionInput = {
    where: ProjectionPriceWhereUniqueInput
    create: XOR<ProjectionPriceCreateWithoutMovieProjectionInput, ProjectionPriceUncheckedCreateWithoutMovieProjectionInput>
  }

  export type ProjectionPriceCreateManyMovieProjectionInputEnvelope = {
    data: ProjectionPriceCreateManyMovieProjectionInput | ProjectionPriceCreateManyMovieProjectionInput[]
    skipDuplicates?: boolean
  }

  export type ReservationCreateWithoutMovieProjectionInput = {
    id?: string
    customerInformation?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt: Date | string
    options?: JsonNullValueInput | InputJsonValue
    deletedAt?: Date | string | null
    reservationSeats?: ReservationSeatsCreateNestedManyWithoutReservationInput
  }

  export type ReservationUncheckedCreateWithoutMovieProjectionInput = {
    id?: string
    customerInformation?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt: Date | string
    options?: JsonNullValueInput | InputJsonValue
    deletedAt?: Date | string | null
    reservationSeats?: ReservationSeatsUncheckedCreateNestedManyWithoutReservationInput
  }

  export type ReservationCreateOrConnectWithoutMovieProjectionInput = {
    where: ReservationWhereUniqueInput
    create: XOR<ReservationCreateWithoutMovieProjectionInput, ReservationUncheckedCreateWithoutMovieProjectionInput>
  }

  export type ReservationCreateManyMovieProjectionInputEnvelope = {
    data: ReservationCreateManyMovieProjectionInput | ReservationCreateManyMovieProjectionInput[]
    skipDuplicates?: boolean
  }

  export type MovieUpsertWithoutMovieProjectionsInput = {
    update: XOR<MovieUpdateWithoutMovieProjectionsInput, MovieUncheckedUpdateWithoutMovieProjectionsInput>
    create: XOR<MovieCreateWithoutMovieProjectionsInput, MovieUncheckedCreateWithoutMovieProjectionsInput>
    where?: MovieWhereInput
  }

  export type MovieUpdateToOneWithWhereWithoutMovieProjectionsInput = {
    where?: MovieWhereInput
    data: XOR<MovieUpdateWithoutMovieProjectionsInput, MovieUncheckedUpdateWithoutMovieProjectionsInput>
  }

  export type MovieUpdateWithoutMovieProjectionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    originalTitle?: StringFieldUpdateOperationsInput | string
    localizedTitle?: NullableStringFieldUpdateOperationsInput | string | null
    plot?: StringFieldUpdateOperationsInput | string
    localizedPlot?: NullableStringFieldUpdateOperationsInput | string | null
    runtimeMinutes?: IntFieldUpdateOperationsInput | number
    posterImages?: JsonNullValueInput | InputJsonValue
    videos?: JsonNullValueInput | InputJsonValue
    rating?: IntFieldUpdateOperationsInput | number
    releaseDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    externalId?: StringFieldUpdateOperationsInput | string
    externalType?: EnumInputProviderFieldUpdateOperationsInput | $Enums.InputProvider
    additionalData?: JsonNullValueInput | InputJsonValue
    genres?: GenreUpdateManyWithoutMoviesNestedInput
    originalLanguage?: LanguageUpdateOneRequiredWithoutOriginalLanguageMoviesNestedInput
    countryOfOrigin?: CountryUpdateOneRequiredWithoutMoviesNestedInput
    actors?: MovieActorUpdateManyWithoutMovieNestedInput
    directors?: MovieDirectorUpdateManyWithoutMovieNestedInput
    producers?: MovieProducerUpdateManyWithoutMovieNestedInput
    movieCinemaOverrides?: MovieCinemaOverrideUpdateManyWithoutMovieNestedInput
  }

  export type MovieUncheckedUpdateWithoutMovieProjectionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    originalTitle?: StringFieldUpdateOperationsInput | string
    localizedTitle?: NullableStringFieldUpdateOperationsInput | string | null
    plot?: StringFieldUpdateOperationsInput | string
    localizedPlot?: NullableStringFieldUpdateOperationsInput | string | null
    runtimeMinutes?: IntFieldUpdateOperationsInput | number
    originalLanguageId?: StringFieldUpdateOperationsInput | string
    countryOfOriginId?: StringFieldUpdateOperationsInput | string
    posterImages?: JsonNullValueInput | InputJsonValue
    videos?: JsonNullValueInput | InputJsonValue
    rating?: IntFieldUpdateOperationsInput | number
    releaseDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    externalId?: StringFieldUpdateOperationsInput | string
    externalType?: EnumInputProviderFieldUpdateOperationsInput | $Enums.InputProvider
    additionalData?: JsonNullValueInput | InputJsonValue
    genres?: GenreUncheckedUpdateManyWithoutMoviesNestedInput
    actors?: MovieActorUncheckedUpdateManyWithoutMovieNestedInput
    directors?: MovieDirectorUncheckedUpdateManyWithoutMovieNestedInput
    producers?: MovieProducerUncheckedUpdateManyWithoutMovieNestedInput
    movieCinemaOverrides?: MovieCinemaOverrideUncheckedUpdateManyWithoutMovieNestedInput
  }

  export type CinemaTheaterUpsertWithoutMovieProjectionsInput = {
    update: XOR<CinemaTheaterUpdateWithoutMovieProjectionsInput, CinemaTheaterUncheckedUpdateWithoutMovieProjectionsInput>
    create: XOR<CinemaTheaterCreateWithoutMovieProjectionsInput, CinemaTheaterUncheckedCreateWithoutMovieProjectionsInput>
    where?: CinemaTheaterWhereInput
  }

  export type CinemaTheaterUpdateToOneWithWhereWithoutMovieProjectionsInput = {
    where?: CinemaTheaterWhereInput
    data: XOR<CinemaTheaterUpdateWithoutMovieProjectionsInput, CinemaTheaterUncheckedUpdateWithoutMovieProjectionsInput>
  }

  export type CinemaTheaterUpdateWithoutMovieProjectionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    supports3D?: BoolFieldUpdateOperationsInput | boolean
    posterImages?: JsonNullValueInput | InputJsonValue
    cinema?: CinemaUpdateOneRequiredWithoutCinemaTheatersNestedInput
    cinemaSeatGroups?: CinemaSeatGroupUpdateManyWithoutCinemaTheaterNestedInput
  }

  export type CinemaTheaterUncheckedUpdateWithoutMovieProjectionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    cinemaId?: StringFieldUpdateOperationsInput | string
    supports3D?: BoolFieldUpdateOperationsInput | boolean
    posterImages?: JsonNullValueInput | InputJsonValue
    cinemaSeatGroups?: CinemaSeatGroupUncheckedUpdateManyWithoutCinemaTheaterNestedInput
  }

  export type LanguageUpsertWithoutDubbedLanguageMovieProjectionsInput = {
    update: XOR<LanguageUpdateWithoutDubbedLanguageMovieProjectionsInput, LanguageUncheckedUpdateWithoutDubbedLanguageMovieProjectionsInput>
    create: XOR<LanguageCreateWithoutDubbedLanguageMovieProjectionsInput, LanguageUncheckedCreateWithoutDubbedLanguageMovieProjectionsInput>
    where?: LanguageWhereInput
  }

  export type LanguageUpdateToOneWithWhereWithoutDubbedLanguageMovieProjectionsInput = {
    where?: LanguageWhereInput
    data: XOR<LanguageUpdateWithoutDubbedLanguageMovieProjectionsInput, LanguageUncheckedUpdateWithoutDubbedLanguageMovieProjectionsInput>
  }

  export type LanguageUpdateWithoutDubbedLanguageMovieProjectionsInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    originalLanguageMovies?: MovieUpdateManyWithoutOriginalLanguageNestedInput
  }

  export type LanguageUncheckedUpdateWithoutDubbedLanguageMovieProjectionsInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    originalLanguageMovies?: MovieUncheckedUpdateManyWithoutOriginalLanguageNestedInput
  }

  export type ProjectionPriceUpsertWithWhereUniqueWithoutMovieProjectionInput = {
    where: ProjectionPriceWhereUniqueInput
    update: XOR<ProjectionPriceUpdateWithoutMovieProjectionInput, ProjectionPriceUncheckedUpdateWithoutMovieProjectionInput>
    create: XOR<ProjectionPriceCreateWithoutMovieProjectionInput, ProjectionPriceUncheckedCreateWithoutMovieProjectionInput>
  }

  export type ProjectionPriceUpdateWithWhereUniqueWithoutMovieProjectionInput = {
    where: ProjectionPriceWhereUniqueInput
    data: XOR<ProjectionPriceUpdateWithoutMovieProjectionInput, ProjectionPriceUncheckedUpdateWithoutMovieProjectionInput>
  }

  export type ProjectionPriceUpdateManyWithWhereWithoutMovieProjectionInput = {
    where: ProjectionPriceScalarWhereInput
    data: XOR<ProjectionPriceUpdateManyMutationInput, ProjectionPriceUncheckedUpdateManyWithoutMovieProjectionInput>
  }

  export type ReservationUpsertWithWhereUniqueWithoutMovieProjectionInput = {
    where: ReservationWhereUniqueInput
    update: XOR<ReservationUpdateWithoutMovieProjectionInput, ReservationUncheckedUpdateWithoutMovieProjectionInput>
    create: XOR<ReservationCreateWithoutMovieProjectionInput, ReservationUncheckedCreateWithoutMovieProjectionInput>
  }

  export type ReservationUpdateWithWhereUniqueWithoutMovieProjectionInput = {
    where: ReservationWhereUniqueInput
    data: XOR<ReservationUpdateWithoutMovieProjectionInput, ReservationUncheckedUpdateWithoutMovieProjectionInput>
  }

  export type ReservationUpdateManyWithWhereWithoutMovieProjectionInput = {
    where: ReservationScalarWhereInput
    data: XOR<ReservationUpdateManyMutationInput, ReservationUncheckedUpdateManyWithoutMovieProjectionInput>
  }

  export type ReservationScalarWhereInput = {
    AND?: ReservationScalarWhereInput | ReservationScalarWhereInput[]
    OR?: ReservationScalarWhereInput[]
    NOT?: ReservationScalarWhereInput | ReservationScalarWhereInput[]
    id?: UuidFilter<"Reservation"> | string
    eventId?: UuidFilter<"Reservation"> | string
    customerInformation?: JsonFilter<"Reservation">
    createdAt?: DateTimeFilter<"Reservation"> | Date | string
    updatedAt?: DateTimeFilter<"Reservation"> | Date | string
    options?: JsonFilter<"Reservation">
    deletedAt?: DateTimeNullableFilter<"Reservation"> | Date | string | null
  }

  export type CinemaSeatGroupCreateWithoutProjectionPricesInput = {
    id?: string
    name: string
    rowCount: number
    columnCount: number
    position?: $Enums.CinemaSeatGroupPositionEnum
    options?: JsonNullValueInput | InputJsonValue
    cinemaTheater: CinemaTheaterCreateNestedOneWithoutCinemaSeatGroupsInput
    cinemaSeats?: CinemaSeatCreateNestedManyWithoutCinemaSeatGroupInput
  }

  export type CinemaSeatGroupUncheckedCreateWithoutProjectionPricesInput = {
    id?: string
    cinemaTheaterId: string
    name: string
    rowCount: number
    columnCount: number
    position?: $Enums.CinemaSeatGroupPositionEnum
    options?: JsonNullValueInput | InputJsonValue
    cinemaSeats?: CinemaSeatUncheckedCreateNestedManyWithoutCinemaSeatGroupInput
  }

  export type CinemaSeatGroupCreateOrConnectWithoutProjectionPricesInput = {
    where: CinemaSeatGroupWhereUniqueInput
    create: XOR<CinemaSeatGroupCreateWithoutProjectionPricesInput, CinemaSeatGroupUncheckedCreateWithoutProjectionPricesInput>
  }

  export type MovieProjectionCreateWithoutProjectionPricesInput = {
    id?: string
    projectionDateTime: Date | string
    createdAt?: Date | string
    updatedAt: Date | string
    options?: JsonNullValueInput | InputJsonValue
    movie: MovieCreateNestedOneWithoutMovieProjectionsInput
    cinemaTheater: CinemaTheaterCreateNestedOneWithoutMovieProjectionsInput
    dubbedLanguage?: LanguageCreateNestedOneWithoutDubbedLanguageMovieProjectionsInput
    reservations?: ReservationCreateNestedManyWithoutMovieProjectionInput
  }

  export type MovieProjectionUncheckedCreateWithoutProjectionPricesInput = {
    id?: string
    movieId: string
    cinemaTheaterId: string
    projectionDateTime: Date | string
    createdAt?: Date | string
    updatedAt: Date | string
    dubbedLanguageId?: string | null
    options?: JsonNullValueInput | InputJsonValue
    reservations?: ReservationUncheckedCreateNestedManyWithoutMovieProjectionInput
  }

  export type MovieProjectionCreateOrConnectWithoutProjectionPricesInput = {
    where: MovieProjectionWhereUniqueInput
    create: XOR<MovieProjectionCreateWithoutProjectionPricesInput, MovieProjectionUncheckedCreateWithoutProjectionPricesInput>
  }

  export type CinemaSeatGroupUpsertWithoutProjectionPricesInput = {
    update: XOR<CinemaSeatGroupUpdateWithoutProjectionPricesInput, CinemaSeatGroupUncheckedUpdateWithoutProjectionPricesInput>
    create: XOR<CinemaSeatGroupCreateWithoutProjectionPricesInput, CinemaSeatGroupUncheckedCreateWithoutProjectionPricesInput>
    where?: CinemaSeatGroupWhereInput
  }

  export type CinemaSeatGroupUpdateToOneWithWhereWithoutProjectionPricesInput = {
    where?: CinemaSeatGroupWhereInput
    data: XOR<CinemaSeatGroupUpdateWithoutProjectionPricesInput, CinemaSeatGroupUncheckedUpdateWithoutProjectionPricesInput>
  }

  export type CinemaSeatGroupUpdateWithoutProjectionPricesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    rowCount?: IntFieldUpdateOperationsInput | number
    columnCount?: IntFieldUpdateOperationsInput | number
    position?: EnumCinemaSeatGroupPositionEnumFieldUpdateOperationsInput | $Enums.CinemaSeatGroupPositionEnum
    options?: JsonNullValueInput | InputJsonValue
    cinemaTheater?: CinemaTheaterUpdateOneRequiredWithoutCinemaSeatGroupsNestedInput
    cinemaSeats?: CinemaSeatUpdateManyWithoutCinemaSeatGroupNestedInput
  }

  export type CinemaSeatGroupUncheckedUpdateWithoutProjectionPricesInput = {
    id?: StringFieldUpdateOperationsInput | string
    cinemaTheaterId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    rowCount?: IntFieldUpdateOperationsInput | number
    columnCount?: IntFieldUpdateOperationsInput | number
    position?: EnumCinemaSeatGroupPositionEnumFieldUpdateOperationsInput | $Enums.CinemaSeatGroupPositionEnum
    options?: JsonNullValueInput | InputJsonValue
    cinemaSeats?: CinemaSeatUncheckedUpdateManyWithoutCinemaSeatGroupNestedInput
  }

  export type MovieProjectionUpsertWithoutProjectionPricesInput = {
    update: XOR<MovieProjectionUpdateWithoutProjectionPricesInput, MovieProjectionUncheckedUpdateWithoutProjectionPricesInput>
    create: XOR<MovieProjectionCreateWithoutProjectionPricesInput, MovieProjectionUncheckedCreateWithoutProjectionPricesInput>
    where?: MovieProjectionWhereInput
  }

  export type MovieProjectionUpdateToOneWithWhereWithoutProjectionPricesInput = {
    where?: MovieProjectionWhereInput
    data: XOR<MovieProjectionUpdateWithoutProjectionPricesInput, MovieProjectionUncheckedUpdateWithoutProjectionPricesInput>
  }

  export type MovieProjectionUpdateWithoutProjectionPricesInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectionDateTime?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    options?: JsonNullValueInput | InputJsonValue
    movie?: MovieUpdateOneRequiredWithoutMovieProjectionsNestedInput
    cinemaTheater?: CinemaTheaterUpdateOneRequiredWithoutMovieProjectionsNestedInput
    dubbedLanguage?: LanguageUpdateOneWithoutDubbedLanguageMovieProjectionsNestedInput
    reservations?: ReservationUpdateManyWithoutMovieProjectionNestedInput
  }

  export type MovieProjectionUncheckedUpdateWithoutProjectionPricesInput = {
    id?: StringFieldUpdateOperationsInput | string
    movieId?: StringFieldUpdateOperationsInput | string
    cinemaTheaterId?: StringFieldUpdateOperationsInput | string
    projectionDateTime?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dubbedLanguageId?: NullableStringFieldUpdateOperationsInput | string | null
    options?: JsonNullValueInput | InputJsonValue
    reservations?: ReservationUncheckedUpdateManyWithoutMovieProjectionNestedInput
  }

  export type ReservationSeatsCreateWithoutValidatedByAdminUserInput = {
    id?: string
    eventId: string
    options?: JsonNullValueInput | InputJsonValue
    deletedAt?: Date | string | null
    validatedAt?: Date | string | null
    reservation: ReservationCreateNestedOneWithoutReservationSeatsInput
    cinemaSeat: CinemaSeatCreateNestedOneWithoutReservationInput
  }

  export type ReservationSeatsUncheckedCreateWithoutValidatedByAdminUserInput = {
    id?: string
    reservationId: string
    eventId: string
    seatId: string
    options?: JsonNullValueInput | InputJsonValue
    deletedAt?: Date | string | null
    validatedAt?: Date | string | null
  }

  export type ReservationSeatsCreateOrConnectWithoutValidatedByAdminUserInput = {
    where: ReservationSeatsWhereUniqueInput
    create: XOR<ReservationSeatsCreateWithoutValidatedByAdminUserInput, ReservationSeatsUncheckedCreateWithoutValidatedByAdminUserInput>
  }

  export type ReservationSeatsCreateManyValidatedByAdminUserInputEnvelope = {
    data: ReservationSeatsCreateManyValidatedByAdminUserInput | ReservationSeatsCreateManyValidatedByAdminUserInput[]
    skipDuplicates?: boolean
  }

  export type ReservationSeatsUpsertWithWhereUniqueWithoutValidatedByAdminUserInput = {
    where: ReservationSeatsWhereUniqueInput
    update: XOR<ReservationSeatsUpdateWithoutValidatedByAdminUserInput, ReservationSeatsUncheckedUpdateWithoutValidatedByAdminUserInput>
    create: XOR<ReservationSeatsCreateWithoutValidatedByAdminUserInput, ReservationSeatsUncheckedCreateWithoutValidatedByAdminUserInput>
  }

  export type ReservationSeatsUpdateWithWhereUniqueWithoutValidatedByAdminUserInput = {
    where: ReservationSeatsWhereUniqueInput
    data: XOR<ReservationSeatsUpdateWithoutValidatedByAdminUserInput, ReservationSeatsUncheckedUpdateWithoutValidatedByAdminUserInput>
  }

  export type ReservationSeatsUpdateManyWithWhereWithoutValidatedByAdminUserInput = {
    where: ReservationSeatsScalarWhereInput
    data: XOR<ReservationSeatsUpdateManyMutationInput, ReservationSeatsUncheckedUpdateManyWithoutValidatedByAdminUserInput>
  }

  export type MovieProjectionCreateWithoutReservationsInput = {
    id?: string
    projectionDateTime: Date | string
    createdAt?: Date | string
    updatedAt: Date | string
    options?: JsonNullValueInput | InputJsonValue
    movie: MovieCreateNestedOneWithoutMovieProjectionsInput
    cinemaTheater: CinemaTheaterCreateNestedOneWithoutMovieProjectionsInput
    dubbedLanguage?: LanguageCreateNestedOneWithoutDubbedLanguageMovieProjectionsInput
    projectionPrices?: ProjectionPriceCreateNestedManyWithoutMovieProjectionInput
  }

  export type MovieProjectionUncheckedCreateWithoutReservationsInput = {
    id?: string
    movieId: string
    cinemaTheaterId: string
    projectionDateTime: Date | string
    createdAt?: Date | string
    updatedAt: Date | string
    dubbedLanguageId?: string | null
    options?: JsonNullValueInput | InputJsonValue
    projectionPrices?: ProjectionPriceUncheckedCreateNestedManyWithoutMovieProjectionInput
  }

  export type MovieProjectionCreateOrConnectWithoutReservationsInput = {
    where: MovieProjectionWhereUniqueInput
    create: XOR<MovieProjectionCreateWithoutReservationsInput, MovieProjectionUncheckedCreateWithoutReservationsInput>
  }

  export type ReservationSeatsCreateWithoutReservationInput = {
    id?: string
    eventId: string
    options?: JsonNullValueInput | InputJsonValue
    deletedAt?: Date | string | null
    validatedAt?: Date | string | null
    cinemaSeat: CinemaSeatCreateNestedOneWithoutReservationInput
    validatedByAdminUser?: AdminUserCreateNestedOneWithoutValidatedReservationSeatsInput
  }

  export type ReservationSeatsUncheckedCreateWithoutReservationInput = {
    id?: string
    eventId: string
    seatId: string
    options?: JsonNullValueInput | InputJsonValue
    deletedAt?: Date | string | null
    validatedAt?: Date | string | null
    validatedByAdminUserId?: string | null
  }

  export type ReservationSeatsCreateOrConnectWithoutReservationInput = {
    where: ReservationSeatsWhereUniqueInput
    create: XOR<ReservationSeatsCreateWithoutReservationInput, ReservationSeatsUncheckedCreateWithoutReservationInput>
  }

  export type ReservationSeatsCreateManyReservationInputEnvelope = {
    data: ReservationSeatsCreateManyReservationInput | ReservationSeatsCreateManyReservationInput[]
    skipDuplicates?: boolean
  }

  export type MovieProjectionUpsertWithoutReservationsInput = {
    update: XOR<MovieProjectionUpdateWithoutReservationsInput, MovieProjectionUncheckedUpdateWithoutReservationsInput>
    create: XOR<MovieProjectionCreateWithoutReservationsInput, MovieProjectionUncheckedCreateWithoutReservationsInput>
    where?: MovieProjectionWhereInput
  }

  export type MovieProjectionUpdateToOneWithWhereWithoutReservationsInput = {
    where?: MovieProjectionWhereInput
    data: XOR<MovieProjectionUpdateWithoutReservationsInput, MovieProjectionUncheckedUpdateWithoutReservationsInput>
  }

  export type MovieProjectionUpdateWithoutReservationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectionDateTime?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    options?: JsonNullValueInput | InputJsonValue
    movie?: MovieUpdateOneRequiredWithoutMovieProjectionsNestedInput
    cinemaTheater?: CinemaTheaterUpdateOneRequiredWithoutMovieProjectionsNestedInput
    dubbedLanguage?: LanguageUpdateOneWithoutDubbedLanguageMovieProjectionsNestedInput
    projectionPrices?: ProjectionPriceUpdateManyWithoutMovieProjectionNestedInput
  }

  export type MovieProjectionUncheckedUpdateWithoutReservationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    movieId?: StringFieldUpdateOperationsInput | string
    cinemaTheaterId?: StringFieldUpdateOperationsInput | string
    projectionDateTime?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dubbedLanguageId?: NullableStringFieldUpdateOperationsInput | string | null
    options?: JsonNullValueInput | InputJsonValue
    projectionPrices?: ProjectionPriceUncheckedUpdateManyWithoutMovieProjectionNestedInput
  }

  export type ReservationSeatsUpsertWithWhereUniqueWithoutReservationInput = {
    where: ReservationSeatsWhereUniqueInput
    update: XOR<ReservationSeatsUpdateWithoutReservationInput, ReservationSeatsUncheckedUpdateWithoutReservationInput>
    create: XOR<ReservationSeatsCreateWithoutReservationInput, ReservationSeatsUncheckedCreateWithoutReservationInput>
  }

  export type ReservationSeatsUpdateWithWhereUniqueWithoutReservationInput = {
    where: ReservationSeatsWhereUniqueInput
    data: XOR<ReservationSeatsUpdateWithoutReservationInput, ReservationSeatsUncheckedUpdateWithoutReservationInput>
  }

  export type ReservationSeatsUpdateManyWithWhereWithoutReservationInput = {
    where: ReservationSeatsScalarWhereInput
    data: XOR<ReservationSeatsUpdateManyMutationInput, ReservationSeatsUncheckedUpdateManyWithoutReservationInput>
  }

  export type ReservationCreateWithoutReservationSeatsInput = {
    id?: string
    customerInformation?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt: Date | string
    options?: JsonNullValueInput | InputJsonValue
    deletedAt?: Date | string | null
    movieProjection: MovieProjectionCreateNestedOneWithoutReservationsInput
  }

  export type ReservationUncheckedCreateWithoutReservationSeatsInput = {
    id?: string
    eventId: string
    customerInformation?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt: Date | string
    options?: JsonNullValueInput | InputJsonValue
    deletedAt?: Date | string | null
  }

  export type ReservationCreateOrConnectWithoutReservationSeatsInput = {
    where: ReservationWhereUniqueInput
    create: XOR<ReservationCreateWithoutReservationSeatsInput, ReservationUncheckedCreateWithoutReservationSeatsInput>
  }

  export type CinemaSeatCreateWithoutReservationInput = {
    id?: string
    seatRow: string
    seatColumn: string
    options?: JsonNullValueInput | InputJsonValue
    cinemaSeatGroup: CinemaSeatGroupCreateNestedOneWithoutCinemaSeatsInput
  }

  export type CinemaSeatUncheckedCreateWithoutReservationInput = {
    id?: string
    cinemaSeatGroupId: string
    seatRow: string
    seatColumn: string
    options?: JsonNullValueInput | InputJsonValue
  }

  export type CinemaSeatCreateOrConnectWithoutReservationInput = {
    where: CinemaSeatWhereUniqueInput
    create: XOR<CinemaSeatCreateWithoutReservationInput, CinemaSeatUncheckedCreateWithoutReservationInput>
  }

  export type AdminUserCreateWithoutValidatedReservationSeatsInput = {
    id?: string
    email: string
    password: string
    fullName: string
    role: $Enums.AdminRole
    cinemaIds?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type AdminUserUncheckedCreateWithoutValidatedReservationSeatsInput = {
    id?: string
    email: string
    password: string
    fullName: string
    role: $Enums.AdminRole
    cinemaIds?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type AdminUserCreateOrConnectWithoutValidatedReservationSeatsInput = {
    where: AdminUserWhereUniqueInput
    create: XOR<AdminUserCreateWithoutValidatedReservationSeatsInput, AdminUserUncheckedCreateWithoutValidatedReservationSeatsInput>
  }

  export type ReservationUpsertWithoutReservationSeatsInput = {
    update: XOR<ReservationUpdateWithoutReservationSeatsInput, ReservationUncheckedUpdateWithoutReservationSeatsInput>
    create: XOR<ReservationCreateWithoutReservationSeatsInput, ReservationUncheckedCreateWithoutReservationSeatsInput>
    where?: ReservationWhereInput
  }

  export type ReservationUpdateToOneWithWhereWithoutReservationSeatsInput = {
    where?: ReservationWhereInput
    data: XOR<ReservationUpdateWithoutReservationSeatsInput, ReservationUncheckedUpdateWithoutReservationSeatsInput>
  }

  export type ReservationUpdateWithoutReservationSeatsInput = {
    id?: StringFieldUpdateOperationsInput | string
    customerInformation?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    options?: JsonNullValueInput | InputJsonValue
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    movieProjection?: MovieProjectionUpdateOneRequiredWithoutReservationsNestedInput
  }

  export type ReservationUncheckedUpdateWithoutReservationSeatsInput = {
    id?: StringFieldUpdateOperationsInput | string
    eventId?: StringFieldUpdateOperationsInput | string
    customerInformation?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    options?: JsonNullValueInput | InputJsonValue
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type CinemaSeatUpsertWithoutReservationInput = {
    update: XOR<CinemaSeatUpdateWithoutReservationInput, CinemaSeatUncheckedUpdateWithoutReservationInput>
    create: XOR<CinemaSeatCreateWithoutReservationInput, CinemaSeatUncheckedCreateWithoutReservationInput>
    where?: CinemaSeatWhereInput
  }

  export type CinemaSeatUpdateToOneWithWhereWithoutReservationInput = {
    where?: CinemaSeatWhereInput
    data: XOR<CinemaSeatUpdateWithoutReservationInput, CinemaSeatUncheckedUpdateWithoutReservationInput>
  }

  export type CinemaSeatUpdateWithoutReservationInput = {
    id?: StringFieldUpdateOperationsInput | string
    seatRow?: StringFieldUpdateOperationsInput | string
    seatColumn?: StringFieldUpdateOperationsInput | string
    options?: JsonNullValueInput | InputJsonValue
    cinemaSeatGroup?: CinemaSeatGroupUpdateOneRequiredWithoutCinemaSeatsNestedInput
  }

  export type CinemaSeatUncheckedUpdateWithoutReservationInput = {
    id?: StringFieldUpdateOperationsInput | string
    cinemaSeatGroupId?: StringFieldUpdateOperationsInput | string
    seatRow?: StringFieldUpdateOperationsInput | string
    seatColumn?: StringFieldUpdateOperationsInput | string
    options?: JsonNullValueInput | InputJsonValue
  }

  export type AdminUserUpsertWithoutValidatedReservationSeatsInput = {
    update: XOR<AdminUserUpdateWithoutValidatedReservationSeatsInput, AdminUserUncheckedUpdateWithoutValidatedReservationSeatsInput>
    create: XOR<AdminUserCreateWithoutValidatedReservationSeatsInput, AdminUserUncheckedCreateWithoutValidatedReservationSeatsInput>
    where?: AdminUserWhereInput
  }

  export type AdminUserUpdateToOneWithWhereWithoutValidatedReservationSeatsInput = {
    where?: AdminUserWhereInput
    data: XOR<AdminUserUpdateWithoutValidatedReservationSeatsInput, AdminUserUncheckedUpdateWithoutValidatedReservationSeatsInput>
  }

  export type AdminUserUpdateWithoutValidatedReservationSeatsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    role?: EnumAdminRoleFieldUpdateOperationsInput | $Enums.AdminRole
    cinemaIds?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdminUserUncheckedUpdateWithoutValidatedReservationSeatsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    role?: EnumAdminRoleFieldUpdateOperationsInput | $Enums.AdminRole
    cinemaIds?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MovieUpdateWithoutGenresInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    originalTitle?: StringFieldUpdateOperationsInput | string
    localizedTitle?: NullableStringFieldUpdateOperationsInput | string | null
    plot?: StringFieldUpdateOperationsInput | string
    localizedPlot?: NullableStringFieldUpdateOperationsInput | string | null
    runtimeMinutes?: IntFieldUpdateOperationsInput | number
    posterImages?: JsonNullValueInput | InputJsonValue
    videos?: JsonNullValueInput | InputJsonValue
    rating?: IntFieldUpdateOperationsInput | number
    releaseDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    externalId?: StringFieldUpdateOperationsInput | string
    externalType?: EnumInputProviderFieldUpdateOperationsInput | $Enums.InputProvider
    additionalData?: JsonNullValueInput | InputJsonValue
    originalLanguage?: LanguageUpdateOneRequiredWithoutOriginalLanguageMoviesNestedInput
    countryOfOrigin?: CountryUpdateOneRequiredWithoutMoviesNestedInput
    actors?: MovieActorUpdateManyWithoutMovieNestedInput
    directors?: MovieDirectorUpdateManyWithoutMovieNestedInput
    producers?: MovieProducerUpdateManyWithoutMovieNestedInput
    movieCinemaOverrides?: MovieCinemaOverrideUpdateManyWithoutMovieNestedInput
    movieProjections?: MovieProjectionUpdateManyWithoutMovieNestedInput
  }

  export type MovieUncheckedUpdateWithoutGenresInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    originalTitle?: StringFieldUpdateOperationsInput | string
    localizedTitle?: NullableStringFieldUpdateOperationsInput | string | null
    plot?: StringFieldUpdateOperationsInput | string
    localizedPlot?: NullableStringFieldUpdateOperationsInput | string | null
    runtimeMinutes?: IntFieldUpdateOperationsInput | number
    originalLanguageId?: StringFieldUpdateOperationsInput | string
    countryOfOriginId?: StringFieldUpdateOperationsInput | string
    posterImages?: JsonNullValueInput | InputJsonValue
    videos?: JsonNullValueInput | InputJsonValue
    rating?: IntFieldUpdateOperationsInput | number
    releaseDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    externalId?: StringFieldUpdateOperationsInput | string
    externalType?: EnumInputProviderFieldUpdateOperationsInput | $Enums.InputProvider
    additionalData?: JsonNullValueInput | InputJsonValue
    actors?: MovieActorUncheckedUpdateManyWithoutMovieNestedInput
    directors?: MovieDirectorUncheckedUpdateManyWithoutMovieNestedInput
    producers?: MovieProducerUncheckedUpdateManyWithoutMovieNestedInput
    movieCinemaOverrides?: MovieCinemaOverrideUncheckedUpdateManyWithoutMovieNestedInput
    movieProjections?: MovieProjectionUncheckedUpdateManyWithoutMovieNestedInput
  }

  export type MovieUncheckedUpdateManyWithoutGenresInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    originalTitle?: StringFieldUpdateOperationsInput | string
    localizedTitle?: NullableStringFieldUpdateOperationsInput | string | null
    plot?: StringFieldUpdateOperationsInput | string
    localizedPlot?: NullableStringFieldUpdateOperationsInput | string | null
    runtimeMinutes?: IntFieldUpdateOperationsInput | number
    originalLanguageId?: StringFieldUpdateOperationsInput | string
    countryOfOriginId?: StringFieldUpdateOperationsInput | string
    posterImages?: JsonNullValueInput | InputJsonValue
    videos?: JsonNullValueInput | InputJsonValue
    rating?: IntFieldUpdateOperationsInput | number
    releaseDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    externalId?: StringFieldUpdateOperationsInput | string
    externalType?: EnumInputProviderFieldUpdateOperationsInput | $Enums.InputProvider
    additionalData?: JsonNullValueInput | InputJsonValue
  }

  export type MovieCreateManyOriginalLanguageInput = {
    id?: string
    title?: string | null
    originalTitle: string
    localizedTitle?: string | null
    plot: string
    localizedPlot?: string | null
    runtimeMinutes: number
    countryOfOriginId: string
    posterImages?: JsonNullValueInput | InputJsonValue
    videos?: JsonNullValueInput | InputJsonValue
    rating: number
    releaseDate: Date | string
    createdAt?: Date | string
    updatedAt: Date | string
    externalId: string
    externalType: $Enums.InputProvider
    additionalData?: JsonNullValueInput | InputJsonValue
  }

  export type MovieProjectionCreateManyDubbedLanguageInput = {
    id?: string
    movieId: string
    cinemaTheaterId: string
    projectionDateTime: Date | string
    createdAt?: Date | string
    updatedAt: Date | string
    options?: JsonNullValueInput | InputJsonValue
  }

  export type MovieUpdateWithoutOriginalLanguageInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    originalTitle?: StringFieldUpdateOperationsInput | string
    localizedTitle?: NullableStringFieldUpdateOperationsInput | string | null
    plot?: StringFieldUpdateOperationsInput | string
    localizedPlot?: NullableStringFieldUpdateOperationsInput | string | null
    runtimeMinutes?: IntFieldUpdateOperationsInput | number
    posterImages?: JsonNullValueInput | InputJsonValue
    videos?: JsonNullValueInput | InputJsonValue
    rating?: IntFieldUpdateOperationsInput | number
    releaseDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    externalId?: StringFieldUpdateOperationsInput | string
    externalType?: EnumInputProviderFieldUpdateOperationsInput | $Enums.InputProvider
    additionalData?: JsonNullValueInput | InputJsonValue
    genres?: GenreUpdateManyWithoutMoviesNestedInput
    countryOfOrigin?: CountryUpdateOneRequiredWithoutMoviesNestedInput
    actors?: MovieActorUpdateManyWithoutMovieNestedInput
    directors?: MovieDirectorUpdateManyWithoutMovieNestedInput
    producers?: MovieProducerUpdateManyWithoutMovieNestedInput
    movieCinemaOverrides?: MovieCinemaOverrideUpdateManyWithoutMovieNestedInput
    movieProjections?: MovieProjectionUpdateManyWithoutMovieNestedInput
  }

  export type MovieUncheckedUpdateWithoutOriginalLanguageInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    originalTitle?: StringFieldUpdateOperationsInput | string
    localizedTitle?: NullableStringFieldUpdateOperationsInput | string | null
    plot?: StringFieldUpdateOperationsInput | string
    localizedPlot?: NullableStringFieldUpdateOperationsInput | string | null
    runtimeMinutes?: IntFieldUpdateOperationsInput | number
    countryOfOriginId?: StringFieldUpdateOperationsInput | string
    posterImages?: JsonNullValueInput | InputJsonValue
    videos?: JsonNullValueInput | InputJsonValue
    rating?: IntFieldUpdateOperationsInput | number
    releaseDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    externalId?: StringFieldUpdateOperationsInput | string
    externalType?: EnumInputProviderFieldUpdateOperationsInput | $Enums.InputProvider
    additionalData?: JsonNullValueInput | InputJsonValue
    genres?: GenreUncheckedUpdateManyWithoutMoviesNestedInput
    actors?: MovieActorUncheckedUpdateManyWithoutMovieNestedInput
    directors?: MovieDirectorUncheckedUpdateManyWithoutMovieNestedInput
    producers?: MovieProducerUncheckedUpdateManyWithoutMovieNestedInput
    movieCinemaOverrides?: MovieCinemaOverrideUncheckedUpdateManyWithoutMovieNestedInput
    movieProjections?: MovieProjectionUncheckedUpdateManyWithoutMovieNestedInput
  }

  export type MovieUncheckedUpdateManyWithoutOriginalLanguageInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    originalTitle?: StringFieldUpdateOperationsInput | string
    localizedTitle?: NullableStringFieldUpdateOperationsInput | string | null
    plot?: StringFieldUpdateOperationsInput | string
    localizedPlot?: NullableStringFieldUpdateOperationsInput | string | null
    runtimeMinutes?: IntFieldUpdateOperationsInput | number
    countryOfOriginId?: StringFieldUpdateOperationsInput | string
    posterImages?: JsonNullValueInput | InputJsonValue
    videos?: JsonNullValueInput | InputJsonValue
    rating?: IntFieldUpdateOperationsInput | number
    releaseDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    externalId?: StringFieldUpdateOperationsInput | string
    externalType?: EnumInputProviderFieldUpdateOperationsInput | $Enums.InputProvider
    additionalData?: JsonNullValueInput | InputJsonValue
  }

  export type MovieProjectionUpdateWithoutDubbedLanguageInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectionDateTime?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    options?: JsonNullValueInput | InputJsonValue
    movie?: MovieUpdateOneRequiredWithoutMovieProjectionsNestedInput
    cinemaTheater?: CinemaTheaterUpdateOneRequiredWithoutMovieProjectionsNestedInput
    projectionPrices?: ProjectionPriceUpdateManyWithoutMovieProjectionNestedInput
    reservations?: ReservationUpdateManyWithoutMovieProjectionNestedInput
  }

  export type MovieProjectionUncheckedUpdateWithoutDubbedLanguageInput = {
    id?: StringFieldUpdateOperationsInput | string
    movieId?: StringFieldUpdateOperationsInput | string
    cinemaTheaterId?: StringFieldUpdateOperationsInput | string
    projectionDateTime?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    options?: JsonNullValueInput | InputJsonValue
    projectionPrices?: ProjectionPriceUncheckedUpdateManyWithoutMovieProjectionNestedInput
    reservations?: ReservationUncheckedUpdateManyWithoutMovieProjectionNestedInput
  }

  export type MovieProjectionUncheckedUpdateManyWithoutDubbedLanguageInput = {
    id?: StringFieldUpdateOperationsInput | string
    movieId?: StringFieldUpdateOperationsInput | string
    cinemaTheaterId?: StringFieldUpdateOperationsInput | string
    projectionDateTime?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    options?: JsonNullValueInput | InputJsonValue
  }

  export type CityCreateManyCountryInput = {
    id?: string
    cityCode: string
    name: string
    postalCode: string
  }

  export type MovieCreateManyCountryOfOriginInput = {
    id?: string
    title?: string | null
    originalTitle: string
    localizedTitle?: string | null
    plot: string
    localizedPlot?: string | null
    runtimeMinutes: number
    originalLanguageId: string
    posterImages?: JsonNullValueInput | InputJsonValue
    videos?: JsonNullValueInput | InputJsonValue
    rating: number
    releaseDate: Date | string
    createdAt?: Date | string
    updatedAt: Date | string
    externalId: string
    externalType: $Enums.InputProvider
    additionalData?: JsonNullValueInput | InputJsonValue
  }

  export type CityUpdateWithoutCountryInput = {
    id?: StringFieldUpdateOperationsInput | string
    cityCode?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    postalCode?: StringFieldUpdateOperationsInput | string
    cinemas?: CinemaUpdateManyWithoutCityNestedInput
  }

  export type CityUncheckedUpdateWithoutCountryInput = {
    id?: StringFieldUpdateOperationsInput | string
    cityCode?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    postalCode?: StringFieldUpdateOperationsInput | string
    cinemas?: CinemaUncheckedUpdateManyWithoutCityNestedInput
  }

  export type CityUncheckedUpdateManyWithoutCountryInput = {
    id?: StringFieldUpdateOperationsInput | string
    cityCode?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    postalCode?: StringFieldUpdateOperationsInput | string
  }

  export type MovieUpdateWithoutCountryOfOriginInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    originalTitle?: StringFieldUpdateOperationsInput | string
    localizedTitle?: NullableStringFieldUpdateOperationsInput | string | null
    plot?: StringFieldUpdateOperationsInput | string
    localizedPlot?: NullableStringFieldUpdateOperationsInput | string | null
    runtimeMinutes?: IntFieldUpdateOperationsInput | number
    posterImages?: JsonNullValueInput | InputJsonValue
    videos?: JsonNullValueInput | InputJsonValue
    rating?: IntFieldUpdateOperationsInput | number
    releaseDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    externalId?: StringFieldUpdateOperationsInput | string
    externalType?: EnumInputProviderFieldUpdateOperationsInput | $Enums.InputProvider
    additionalData?: JsonNullValueInput | InputJsonValue
    genres?: GenreUpdateManyWithoutMoviesNestedInput
    originalLanguage?: LanguageUpdateOneRequiredWithoutOriginalLanguageMoviesNestedInput
    actors?: MovieActorUpdateManyWithoutMovieNestedInput
    directors?: MovieDirectorUpdateManyWithoutMovieNestedInput
    producers?: MovieProducerUpdateManyWithoutMovieNestedInput
    movieCinemaOverrides?: MovieCinemaOverrideUpdateManyWithoutMovieNestedInput
    movieProjections?: MovieProjectionUpdateManyWithoutMovieNestedInput
  }

  export type MovieUncheckedUpdateWithoutCountryOfOriginInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    originalTitle?: StringFieldUpdateOperationsInput | string
    localizedTitle?: NullableStringFieldUpdateOperationsInput | string | null
    plot?: StringFieldUpdateOperationsInput | string
    localizedPlot?: NullableStringFieldUpdateOperationsInput | string | null
    runtimeMinutes?: IntFieldUpdateOperationsInput | number
    originalLanguageId?: StringFieldUpdateOperationsInput | string
    posterImages?: JsonNullValueInput | InputJsonValue
    videos?: JsonNullValueInput | InputJsonValue
    rating?: IntFieldUpdateOperationsInput | number
    releaseDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    externalId?: StringFieldUpdateOperationsInput | string
    externalType?: EnumInputProviderFieldUpdateOperationsInput | $Enums.InputProvider
    additionalData?: JsonNullValueInput | InputJsonValue
    genres?: GenreUncheckedUpdateManyWithoutMoviesNestedInput
    actors?: MovieActorUncheckedUpdateManyWithoutMovieNestedInput
    directors?: MovieDirectorUncheckedUpdateManyWithoutMovieNestedInput
    producers?: MovieProducerUncheckedUpdateManyWithoutMovieNestedInput
    movieCinemaOverrides?: MovieCinemaOverrideUncheckedUpdateManyWithoutMovieNestedInput
    movieProjections?: MovieProjectionUncheckedUpdateManyWithoutMovieNestedInput
  }

  export type MovieUncheckedUpdateManyWithoutCountryOfOriginInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    originalTitle?: StringFieldUpdateOperationsInput | string
    localizedTitle?: NullableStringFieldUpdateOperationsInput | string | null
    plot?: StringFieldUpdateOperationsInput | string
    localizedPlot?: NullableStringFieldUpdateOperationsInput | string | null
    runtimeMinutes?: IntFieldUpdateOperationsInput | number
    originalLanguageId?: StringFieldUpdateOperationsInput | string
    posterImages?: JsonNullValueInput | InputJsonValue
    videos?: JsonNullValueInput | InputJsonValue
    rating?: IntFieldUpdateOperationsInput | number
    releaseDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    externalId?: StringFieldUpdateOperationsInput | string
    externalType?: EnumInputProviderFieldUpdateOperationsInput | $Enums.InputProvider
    additionalData?: JsonNullValueInput | InputJsonValue
  }

  export type CinemaCreateManyCityInput = {
    id?: string
    name: string
    description: string
    address: string
    rating: number
    phone?: JsonNullValueInput | InputJsonValue
    posterImages?: JsonNullValueInput | InputJsonValue
    geoLatitude?: Decimal | DecimalJsLike | number | string | null
    geoLongitude?: Decimal | DecimalJsLike | number | string | null
  }

  export type CinemaUpdateWithoutCityInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    phone?: JsonNullValueInput | InputJsonValue
    posterImages?: JsonNullValueInput | InputJsonValue
    geoLatitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    geoLongitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    cinemaTheaters?: CinemaTheaterUpdateManyWithoutCinemaNestedInput
    movieCinemaOverrides?: MovieCinemaOverrideUpdateManyWithoutCinemaNestedInput
  }

  export type CinemaUncheckedUpdateWithoutCityInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    phone?: JsonNullValueInput | InputJsonValue
    posterImages?: JsonNullValueInput | InputJsonValue
    geoLatitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    geoLongitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    cinemaTheaters?: CinemaTheaterUncheckedUpdateManyWithoutCinemaNestedInput
    movieCinemaOverrides?: MovieCinemaOverrideUncheckedUpdateManyWithoutCinemaNestedInput
  }

  export type CinemaUncheckedUpdateManyWithoutCityInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    phone?: JsonNullValueInput | InputJsonValue
    posterImages?: JsonNullValueInput | InputJsonValue
    geoLatitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    geoLongitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
  }

  export type CinemaTheaterCreateManyCinemaInput = {
    id?: string
    name: string
    supports3D?: boolean
    posterImages?: JsonNullValueInput | InputJsonValue
  }

  export type MovieCinemaOverrideCreateManyCinemaInput = {
    movieId: string
    movieDataOverrides?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type CinemaTheaterUpdateWithoutCinemaInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    supports3D?: BoolFieldUpdateOperationsInput | boolean
    posterImages?: JsonNullValueInput | InputJsonValue
    cinemaSeatGroups?: CinemaSeatGroupUpdateManyWithoutCinemaTheaterNestedInput
    movieProjections?: MovieProjectionUpdateManyWithoutCinemaTheaterNestedInput
  }

  export type CinemaTheaterUncheckedUpdateWithoutCinemaInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    supports3D?: BoolFieldUpdateOperationsInput | boolean
    posterImages?: JsonNullValueInput | InputJsonValue
    cinemaSeatGroups?: CinemaSeatGroupUncheckedUpdateManyWithoutCinemaTheaterNestedInput
    movieProjections?: MovieProjectionUncheckedUpdateManyWithoutCinemaTheaterNestedInput
  }

  export type CinemaTheaterUncheckedUpdateManyWithoutCinemaInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    supports3D?: BoolFieldUpdateOperationsInput | boolean
    posterImages?: JsonNullValueInput | InputJsonValue
  }

  export type MovieCinemaOverrideUpdateWithoutCinemaInput = {
    movieDataOverrides?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    movie?: MovieUpdateOneRequiredWithoutMovieCinemaOverridesNestedInput
  }

  export type MovieCinemaOverrideUncheckedUpdateWithoutCinemaInput = {
    movieId?: StringFieldUpdateOperationsInput | string
    movieDataOverrides?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MovieCinemaOverrideUncheckedUpdateManyWithoutCinemaInput = {
    movieId?: StringFieldUpdateOperationsInput | string
    movieDataOverrides?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CinemaSeatGroupCreateManyCinemaTheaterInput = {
    id?: string
    name: string
    rowCount: number
    columnCount: number
    position?: $Enums.CinemaSeatGroupPositionEnum
    options?: JsonNullValueInput | InputJsonValue
  }

  export type MovieProjectionCreateManyCinemaTheaterInput = {
    id?: string
    movieId: string
    projectionDateTime: Date | string
    createdAt?: Date | string
    updatedAt: Date | string
    dubbedLanguageId?: string | null
    options?: JsonNullValueInput | InputJsonValue
  }

  export type CinemaSeatGroupUpdateWithoutCinemaTheaterInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    rowCount?: IntFieldUpdateOperationsInput | number
    columnCount?: IntFieldUpdateOperationsInput | number
    position?: EnumCinemaSeatGroupPositionEnumFieldUpdateOperationsInput | $Enums.CinemaSeatGroupPositionEnum
    options?: JsonNullValueInput | InputJsonValue
    cinemaSeats?: CinemaSeatUpdateManyWithoutCinemaSeatGroupNestedInput
    projectionPrices?: ProjectionPriceUpdateManyWithoutCinemaSeatGroupNestedInput
  }

  export type CinemaSeatGroupUncheckedUpdateWithoutCinemaTheaterInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    rowCount?: IntFieldUpdateOperationsInput | number
    columnCount?: IntFieldUpdateOperationsInput | number
    position?: EnumCinemaSeatGroupPositionEnumFieldUpdateOperationsInput | $Enums.CinemaSeatGroupPositionEnum
    options?: JsonNullValueInput | InputJsonValue
    cinemaSeats?: CinemaSeatUncheckedUpdateManyWithoutCinemaSeatGroupNestedInput
    projectionPrices?: ProjectionPriceUncheckedUpdateManyWithoutCinemaSeatGroupNestedInput
  }

  export type CinemaSeatGroupUncheckedUpdateManyWithoutCinemaTheaterInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    rowCount?: IntFieldUpdateOperationsInput | number
    columnCount?: IntFieldUpdateOperationsInput | number
    position?: EnumCinemaSeatGroupPositionEnumFieldUpdateOperationsInput | $Enums.CinemaSeatGroupPositionEnum
    options?: JsonNullValueInput | InputJsonValue
  }

  export type MovieProjectionUpdateWithoutCinemaTheaterInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectionDateTime?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    options?: JsonNullValueInput | InputJsonValue
    movie?: MovieUpdateOneRequiredWithoutMovieProjectionsNestedInput
    dubbedLanguage?: LanguageUpdateOneWithoutDubbedLanguageMovieProjectionsNestedInput
    projectionPrices?: ProjectionPriceUpdateManyWithoutMovieProjectionNestedInput
    reservations?: ReservationUpdateManyWithoutMovieProjectionNestedInput
  }

  export type MovieProjectionUncheckedUpdateWithoutCinemaTheaterInput = {
    id?: StringFieldUpdateOperationsInput | string
    movieId?: StringFieldUpdateOperationsInput | string
    projectionDateTime?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dubbedLanguageId?: NullableStringFieldUpdateOperationsInput | string | null
    options?: JsonNullValueInput | InputJsonValue
    projectionPrices?: ProjectionPriceUncheckedUpdateManyWithoutMovieProjectionNestedInput
    reservations?: ReservationUncheckedUpdateManyWithoutMovieProjectionNestedInput
  }

  export type MovieProjectionUncheckedUpdateManyWithoutCinemaTheaterInput = {
    id?: StringFieldUpdateOperationsInput | string
    movieId?: StringFieldUpdateOperationsInput | string
    projectionDateTime?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dubbedLanguageId?: NullableStringFieldUpdateOperationsInput | string | null
    options?: JsonNullValueInput | InputJsonValue
  }

  export type CinemaSeatCreateManyCinemaSeatGroupInput = {
    id?: string
    seatRow: string
    seatColumn: string
    options?: JsonNullValueInput | InputJsonValue
  }

  export type ProjectionPriceCreateManyCinemaSeatGroupInput = {
    projectionId: string
    type?: $Enums.PriceType
    price: Decimal | DecimalJsLike | number | string
    currencyCode: $Enums.CurrencyCode
  }

  export type CinemaSeatUpdateWithoutCinemaSeatGroupInput = {
    id?: StringFieldUpdateOperationsInput | string
    seatRow?: StringFieldUpdateOperationsInput | string
    seatColumn?: StringFieldUpdateOperationsInput | string
    options?: JsonNullValueInput | InputJsonValue
    reservation?: ReservationSeatsUpdateManyWithoutCinemaSeatNestedInput
  }

  export type CinemaSeatUncheckedUpdateWithoutCinemaSeatGroupInput = {
    id?: StringFieldUpdateOperationsInput | string
    seatRow?: StringFieldUpdateOperationsInput | string
    seatColumn?: StringFieldUpdateOperationsInput | string
    options?: JsonNullValueInput | InputJsonValue
    reservation?: ReservationSeatsUncheckedUpdateManyWithoutCinemaSeatNestedInput
  }

  export type CinemaSeatUncheckedUpdateManyWithoutCinemaSeatGroupInput = {
    id?: StringFieldUpdateOperationsInput | string
    seatRow?: StringFieldUpdateOperationsInput | string
    seatColumn?: StringFieldUpdateOperationsInput | string
    options?: JsonNullValueInput | InputJsonValue
  }

  export type ProjectionPriceUpdateWithoutCinemaSeatGroupInput = {
    type?: EnumPriceTypeFieldUpdateOperationsInput | $Enums.PriceType
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currencyCode?: EnumCurrencyCodeFieldUpdateOperationsInput | $Enums.CurrencyCode
    movieProjection?: MovieProjectionUpdateOneRequiredWithoutProjectionPricesNestedInput
  }

  export type ProjectionPriceUncheckedUpdateWithoutCinemaSeatGroupInput = {
    projectionId?: StringFieldUpdateOperationsInput | string
    type?: EnumPriceTypeFieldUpdateOperationsInput | $Enums.PriceType
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currencyCode?: EnumCurrencyCodeFieldUpdateOperationsInput | $Enums.CurrencyCode
  }

  export type ProjectionPriceUncheckedUpdateManyWithoutCinemaSeatGroupInput = {
    projectionId?: StringFieldUpdateOperationsInput | string
    type?: EnumPriceTypeFieldUpdateOperationsInput | $Enums.PriceType
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currencyCode?: EnumCurrencyCodeFieldUpdateOperationsInput | $Enums.CurrencyCode
  }

  export type ReservationSeatsCreateManyCinemaSeatInput = {
    id?: string
    reservationId: string
    eventId: string
    options?: JsonNullValueInput | InputJsonValue
    deletedAt?: Date | string | null
    validatedAt?: Date | string | null
    validatedByAdminUserId?: string | null
  }

  export type ReservationSeatsUpdateWithoutCinemaSeatInput = {
    id?: StringFieldUpdateOperationsInput | string
    eventId?: StringFieldUpdateOperationsInput | string
    options?: JsonNullValueInput | InputJsonValue
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    validatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reservation?: ReservationUpdateOneRequiredWithoutReservationSeatsNestedInput
    validatedByAdminUser?: AdminUserUpdateOneWithoutValidatedReservationSeatsNestedInput
  }

  export type ReservationSeatsUncheckedUpdateWithoutCinemaSeatInput = {
    id?: StringFieldUpdateOperationsInput | string
    reservationId?: StringFieldUpdateOperationsInput | string
    eventId?: StringFieldUpdateOperationsInput | string
    options?: JsonNullValueInput | InputJsonValue
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    validatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    validatedByAdminUserId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ReservationSeatsUncheckedUpdateManyWithoutCinemaSeatInput = {
    id?: StringFieldUpdateOperationsInput | string
    reservationId?: StringFieldUpdateOperationsInput | string
    eventId?: StringFieldUpdateOperationsInput | string
    options?: JsonNullValueInput | InputJsonValue
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    validatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    validatedByAdminUserId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type MovieActorCreateManyMovieInput = {
    personId: string
    characterName: string
    castOrder: number
  }

  export type MovieDirectorCreateManyMovieInput = {
    personId: string
    type: $Enums.DirectorType
  }

  export type MovieProducerCreateManyMovieInput = {
    personId: string
    type: $Enums.ProducerType
  }

  export type MovieCinemaOverrideCreateManyMovieInput = {
    cinemaId: string
    movieDataOverrides?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type MovieProjectionCreateManyMovieInput = {
    id?: string
    cinemaTheaterId: string
    projectionDateTime: Date | string
    createdAt?: Date | string
    updatedAt: Date | string
    dubbedLanguageId?: string | null
    options?: JsonNullValueInput | InputJsonValue
  }

  export type GenreUpdateWithoutMoviesInput = {
    systemName?: StringFieldUpdateOperationsInput | string
    localizedName?: StringFieldUpdateOperationsInput | string
  }

  export type GenreUncheckedUpdateWithoutMoviesInput = {
    systemName?: StringFieldUpdateOperationsInput | string
    localizedName?: StringFieldUpdateOperationsInput | string
  }

  export type GenreUncheckedUpdateManyWithoutMoviesInput = {
    systemName?: StringFieldUpdateOperationsInput | string
    localizedName?: StringFieldUpdateOperationsInput | string
  }

  export type MovieActorUpdateWithoutMovieInput = {
    characterName?: StringFieldUpdateOperationsInput | string
    castOrder?: IntFieldUpdateOperationsInput | number
    person?: PersonUpdateOneRequiredWithoutActorInMoviesNestedInput
  }

  export type MovieActorUncheckedUpdateWithoutMovieInput = {
    personId?: StringFieldUpdateOperationsInput | string
    characterName?: StringFieldUpdateOperationsInput | string
    castOrder?: IntFieldUpdateOperationsInput | number
  }

  export type MovieActorUncheckedUpdateManyWithoutMovieInput = {
    personId?: StringFieldUpdateOperationsInput | string
    characterName?: StringFieldUpdateOperationsInput | string
    castOrder?: IntFieldUpdateOperationsInput | number
  }

  export type MovieDirectorUpdateWithoutMovieInput = {
    type?: EnumDirectorTypeFieldUpdateOperationsInput | $Enums.DirectorType
    person?: PersonUpdateOneRequiredWithoutDirectorInMoviesNestedInput
  }

  export type MovieDirectorUncheckedUpdateWithoutMovieInput = {
    personId?: StringFieldUpdateOperationsInput | string
    type?: EnumDirectorTypeFieldUpdateOperationsInput | $Enums.DirectorType
  }

  export type MovieDirectorUncheckedUpdateManyWithoutMovieInput = {
    personId?: StringFieldUpdateOperationsInput | string
    type?: EnumDirectorTypeFieldUpdateOperationsInput | $Enums.DirectorType
  }

  export type MovieProducerUpdateWithoutMovieInput = {
    type?: EnumProducerTypeFieldUpdateOperationsInput | $Enums.ProducerType
    person?: PersonUpdateOneRequiredWithoutProducerInMoviesNestedInput
  }

  export type MovieProducerUncheckedUpdateWithoutMovieInput = {
    personId?: StringFieldUpdateOperationsInput | string
    type?: EnumProducerTypeFieldUpdateOperationsInput | $Enums.ProducerType
  }

  export type MovieProducerUncheckedUpdateManyWithoutMovieInput = {
    personId?: StringFieldUpdateOperationsInput | string
    type?: EnumProducerTypeFieldUpdateOperationsInput | $Enums.ProducerType
  }

  export type MovieCinemaOverrideUpdateWithoutMovieInput = {
    movieDataOverrides?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cinema?: CinemaUpdateOneRequiredWithoutMovieCinemaOverridesNestedInput
  }

  export type MovieCinemaOverrideUncheckedUpdateWithoutMovieInput = {
    cinemaId?: StringFieldUpdateOperationsInput | string
    movieDataOverrides?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MovieCinemaOverrideUncheckedUpdateManyWithoutMovieInput = {
    cinemaId?: StringFieldUpdateOperationsInput | string
    movieDataOverrides?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MovieProjectionUpdateWithoutMovieInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectionDateTime?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    options?: JsonNullValueInput | InputJsonValue
    cinemaTheater?: CinemaTheaterUpdateOneRequiredWithoutMovieProjectionsNestedInput
    dubbedLanguage?: LanguageUpdateOneWithoutDubbedLanguageMovieProjectionsNestedInput
    projectionPrices?: ProjectionPriceUpdateManyWithoutMovieProjectionNestedInput
    reservations?: ReservationUpdateManyWithoutMovieProjectionNestedInput
  }

  export type MovieProjectionUncheckedUpdateWithoutMovieInput = {
    id?: StringFieldUpdateOperationsInput | string
    cinemaTheaterId?: StringFieldUpdateOperationsInput | string
    projectionDateTime?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dubbedLanguageId?: NullableStringFieldUpdateOperationsInput | string | null
    options?: JsonNullValueInput | InputJsonValue
    projectionPrices?: ProjectionPriceUncheckedUpdateManyWithoutMovieProjectionNestedInput
    reservations?: ReservationUncheckedUpdateManyWithoutMovieProjectionNestedInput
  }

  export type MovieProjectionUncheckedUpdateManyWithoutMovieInput = {
    id?: StringFieldUpdateOperationsInput | string
    cinemaTheaterId?: StringFieldUpdateOperationsInput | string
    projectionDateTime?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dubbedLanguageId?: NullableStringFieldUpdateOperationsInput | string | null
    options?: JsonNullValueInput | InputJsonValue
  }

  export type MovieActorCreateManyPersonInput = {
    movieId: string
    characterName: string
    castOrder: number
  }

  export type MovieDirectorCreateManyPersonInput = {
    movieId: string
    type: $Enums.DirectorType
  }

  export type MovieProducerCreateManyPersonInput = {
    movieId: string
    type: $Enums.ProducerType
  }

  export type MovieActorUpdateWithoutPersonInput = {
    characterName?: StringFieldUpdateOperationsInput | string
    castOrder?: IntFieldUpdateOperationsInput | number
    movie?: MovieUpdateOneRequiredWithoutActorsNestedInput
  }

  export type MovieActorUncheckedUpdateWithoutPersonInput = {
    movieId?: StringFieldUpdateOperationsInput | string
    characterName?: StringFieldUpdateOperationsInput | string
    castOrder?: IntFieldUpdateOperationsInput | number
  }

  export type MovieActorUncheckedUpdateManyWithoutPersonInput = {
    movieId?: StringFieldUpdateOperationsInput | string
    characterName?: StringFieldUpdateOperationsInput | string
    castOrder?: IntFieldUpdateOperationsInput | number
  }

  export type MovieDirectorUpdateWithoutPersonInput = {
    type?: EnumDirectorTypeFieldUpdateOperationsInput | $Enums.DirectorType
    movie?: MovieUpdateOneRequiredWithoutDirectorsNestedInput
  }

  export type MovieDirectorUncheckedUpdateWithoutPersonInput = {
    movieId?: StringFieldUpdateOperationsInput | string
    type?: EnumDirectorTypeFieldUpdateOperationsInput | $Enums.DirectorType
  }

  export type MovieDirectorUncheckedUpdateManyWithoutPersonInput = {
    movieId?: StringFieldUpdateOperationsInput | string
    type?: EnumDirectorTypeFieldUpdateOperationsInput | $Enums.DirectorType
  }

  export type MovieProducerUpdateWithoutPersonInput = {
    type?: EnumProducerTypeFieldUpdateOperationsInput | $Enums.ProducerType
    movie?: MovieUpdateOneRequiredWithoutProducersNestedInput
  }

  export type MovieProducerUncheckedUpdateWithoutPersonInput = {
    movieId?: StringFieldUpdateOperationsInput | string
    type?: EnumProducerTypeFieldUpdateOperationsInput | $Enums.ProducerType
  }

  export type MovieProducerUncheckedUpdateManyWithoutPersonInput = {
    movieId?: StringFieldUpdateOperationsInput | string
    type?: EnumProducerTypeFieldUpdateOperationsInput | $Enums.ProducerType
  }

  export type ProjectionPriceCreateManyMovieProjectionInput = {
    groupId: string
    type?: $Enums.PriceType
    price: Decimal | DecimalJsLike | number | string
    currencyCode: $Enums.CurrencyCode
  }

  export type ReservationCreateManyMovieProjectionInput = {
    id?: string
    customerInformation?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt: Date | string
    options?: JsonNullValueInput | InputJsonValue
    deletedAt?: Date | string | null
  }

  export type ProjectionPriceUpdateWithoutMovieProjectionInput = {
    type?: EnumPriceTypeFieldUpdateOperationsInput | $Enums.PriceType
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currencyCode?: EnumCurrencyCodeFieldUpdateOperationsInput | $Enums.CurrencyCode
    cinemaSeatGroup?: CinemaSeatGroupUpdateOneRequiredWithoutProjectionPricesNestedInput
  }

  export type ProjectionPriceUncheckedUpdateWithoutMovieProjectionInput = {
    groupId?: StringFieldUpdateOperationsInput | string
    type?: EnumPriceTypeFieldUpdateOperationsInput | $Enums.PriceType
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currencyCode?: EnumCurrencyCodeFieldUpdateOperationsInput | $Enums.CurrencyCode
  }

  export type ProjectionPriceUncheckedUpdateManyWithoutMovieProjectionInput = {
    groupId?: StringFieldUpdateOperationsInput | string
    type?: EnumPriceTypeFieldUpdateOperationsInput | $Enums.PriceType
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currencyCode?: EnumCurrencyCodeFieldUpdateOperationsInput | $Enums.CurrencyCode
  }

  export type ReservationUpdateWithoutMovieProjectionInput = {
    id?: StringFieldUpdateOperationsInput | string
    customerInformation?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    options?: JsonNullValueInput | InputJsonValue
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reservationSeats?: ReservationSeatsUpdateManyWithoutReservationNestedInput
  }

  export type ReservationUncheckedUpdateWithoutMovieProjectionInput = {
    id?: StringFieldUpdateOperationsInput | string
    customerInformation?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    options?: JsonNullValueInput | InputJsonValue
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reservationSeats?: ReservationSeatsUncheckedUpdateManyWithoutReservationNestedInput
  }

  export type ReservationUncheckedUpdateManyWithoutMovieProjectionInput = {
    id?: StringFieldUpdateOperationsInput | string
    customerInformation?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    options?: JsonNullValueInput | InputJsonValue
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ReservationSeatsCreateManyValidatedByAdminUserInput = {
    id?: string
    reservationId: string
    eventId: string
    seatId: string
    options?: JsonNullValueInput | InputJsonValue
    deletedAt?: Date | string | null
    validatedAt?: Date | string | null
  }

  export type ReservationSeatsUpdateWithoutValidatedByAdminUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    eventId?: StringFieldUpdateOperationsInput | string
    options?: JsonNullValueInput | InputJsonValue
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    validatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reservation?: ReservationUpdateOneRequiredWithoutReservationSeatsNestedInput
    cinemaSeat?: CinemaSeatUpdateOneRequiredWithoutReservationNestedInput
  }

  export type ReservationSeatsUncheckedUpdateWithoutValidatedByAdminUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    reservationId?: StringFieldUpdateOperationsInput | string
    eventId?: StringFieldUpdateOperationsInput | string
    seatId?: StringFieldUpdateOperationsInput | string
    options?: JsonNullValueInput | InputJsonValue
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    validatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ReservationSeatsUncheckedUpdateManyWithoutValidatedByAdminUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    reservationId?: StringFieldUpdateOperationsInput | string
    eventId?: StringFieldUpdateOperationsInput | string
    seatId?: StringFieldUpdateOperationsInput | string
    options?: JsonNullValueInput | InputJsonValue
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    validatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ReservationSeatsCreateManyReservationInput = {
    id?: string
    eventId: string
    seatId: string
    options?: JsonNullValueInput | InputJsonValue
    deletedAt?: Date | string | null
    validatedAt?: Date | string | null
    validatedByAdminUserId?: string | null
  }

  export type ReservationSeatsUpdateWithoutReservationInput = {
    id?: StringFieldUpdateOperationsInput | string
    eventId?: StringFieldUpdateOperationsInput | string
    options?: JsonNullValueInput | InputJsonValue
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    validatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cinemaSeat?: CinemaSeatUpdateOneRequiredWithoutReservationNestedInput
    validatedByAdminUser?: AdminUserUpdateOneWithoutValidatedReservationSeatsNestedInput
  }

  export type ReservationSeatsUncheckedUpdateWithoutReservationInput = {
    id?: StringFieldUpdateOperationsInput | string
    eventId?: StringFieldUpdateOperationsInput | string
    seatId?: StringFieldUpdateOperationsInput | string
    options?: JsonNullValueInput | InputJsonValue
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    validatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    validatedByAdminUserId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ReservationSeatsUncheckedUpdateManyWithoutReservationInput = {
    id?: StringFieldUpdateOperationsInput | string
    eventId?: StringFieldUpdateOperationsInput | string
    seatId?: StringFieldUpdateOperationsInput | string
    options?: JsonNullValueInput | InputJsonValue
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    validatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    validatedByAdminUserId?: NullableStringFieldUpdateOperationsInput | string | null
  }



  /**
   * Aliases for legacy arg types
   */
    /**
     * @deprecated Use GenreCountOutputTypeDefaultArgs instead
     */
    export type GenreCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = GenreCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use LanguageCountOutputTypeDefaultArgs instead
     */
    export type LanguageCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = LanguageCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CountryCountOutputTypeDefaultArgs instead
     */
    export type CountryCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CountryCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CityCountOutputTypeDefaultArgs instead
     */
    export type CityCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CityCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CinemaCountOutputTypeDefaultArgs instead
     */
    export type CinemaCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CinemaCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CinemaTheaterCountOutputTypeDefaultArgs instead
     */
    export type CinemaTheaterCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CinemaTheaterCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CinemaSeatGroupCountOutputTypeDefaultArgs instead
     */
    export type CinemaSeatGroupCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CinemaSeatGroupCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CinemaSeatCountOutputTypeDefaultArgs instead
     */
    export type CinemaSeatCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CinemaSeatCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use MovieCountOutputTypeDefaultArgs instead
     */
    export type MovieCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = MovieCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PersonCountOutputTypeDefaultArgs instead
     */
    export type PersonCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PersonCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use MovieProjectionCountOutputTypeDefaultArgs instead
     */
    export type MovieProjectionCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = MovieProjectionCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AdminUserCountOutputTypeDefaultArgs instead
     */
    export type AdminUserCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AdminUserCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ReservationCountOutputTypeDefaultArgs instead
     */
    export type ReservationCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ReservationCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use GenreDefaultArgs instead
     */
    export type GenreArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = GenreDefaultArgs<ExtArgs>
    /**
     * @deprecated Use LanguageDefaultArgs instead
     */
    export type LanguageArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = LanguageDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CountryDefaultArgs instead
     */
    export type CountryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CountryDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CityDefaultArgs instead
     */
    export type CityArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CityDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CinemaDefaultArgs instead
     */
    export type CinemaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CinemaDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CinemaTheaterDefaultArgs instead
     */
    export type CinemaTheaterArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CinemaTheaterDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CinemaSeatGroupDefaultArgs instead
     */
    export type CinemaSeatGroupArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CinemaSeatGroupDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CinemaSeatDefaultArgs instead
     */
    export type CinemaSeatArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CinemaSeatDefaultArgs<ExtArgs>
    /**
     * @deprecated Use MovieDefaultArgs instead
     */
    export type MovieArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = MovieDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PersonDefaultArgs instead
     */
    export type PersonArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PersonDefaultArgs<ExtArgs>
    /**
     * @deprecated Use MovieActorDefaultArgs instead
     */
    export type MovieActorArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = MovieActorDefaultArgs<ExtArgs>
    /**
     * @deprecated Use MovieDirectorDefaultArgs instead
     */
    export type MovieDirectorArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = MovieDirectorDefaultArgs<ExtArgs>
    /**
     * @deprecated Use MovieProducerDefaultArgs instead
     */
    export type MovieProducerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = MovieProducerDefaultArgs<ExtArgs>
    /**
     * @deprecated Use MovieCinemaOverrideDefaultArgs instead
     */
    export type MovieCinemaOverrideArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = MovieCinemaOverrideDefaultArgs<ExtArgs>
    /**
     * @deprecated Use MovieProjectionDefaultArgs instead
     */
    export type MovieProjectionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = MovieProjectionDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ProjectionPriceDefaultArgs instead
     */
    export type ProjectionPriceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ProjectionPriceDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AdminUserDefaultArgs instead
     */
    export type AdminUserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AdminUserDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ReservationDefaultArgs instead
     */
    export type ReservationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ReservationDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ReservationSeatsDefaultArgs instead
     */
    export type ReservationSeatsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ReservationSeatsDefaultArgs<ExtArgs>

  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}